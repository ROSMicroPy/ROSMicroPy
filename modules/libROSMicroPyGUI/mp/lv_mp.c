
/*
 * Auto-Generated file, DO NOT EDIT!
 *
 * Command line:
 * /opt/lv_micropython/lib/lv_bindings/gen/gen_mpy.py -M lvgl -MP lv -MD /opt/lv_micropython/ports/esp32/build/lv_mp.c.json -E /opt/lv_micropython/ports/esp32/build/lv_mp.c.pp /opt/lv_micropython/lib/lv_bindings/lvgl/lvgl.h
 *
 * Preprocessing command:
 * Preprocessing was disabled.
 *
 * Generating Objects: obj(None), image(obj), animimg(obj), arc(obj), label(obj), bar(obj), button(obj), buttonmatrix(obj), calendar(obj), calendar_header_arrow(obj), calendar_header_dropdown(obj), canvas(obj), chart(obj), checkbox(obj), dropdown(obj), imagebutton(obj), keyboard(obj), led(obj), line(obj), list(obj), menu(obj), menu_page(obj), menu_cont(obj), menu_section(obj), menu_separator(obj), msgbox(obj), roller(obj), scale(obj), slider(obj), spangroup(obj), textarea(obj), spinbox(obj), spinner(obj), switch(obj), table(obj), tabview(obj), tileview(obj), win(obj), barcode(obj), gif(obj), qrcode(obj)
 */

/*
 * Mpy includes
 */

#include <stdlib.h>
#include <string.h>
#include "py/obj.h"
#include "py/objint.h"
#include "py/objstr.h"
#include "py/runtime.h"
#include "py/binary.h"
#include "py/objarray.h"
#include "py/objtype.h"
#include "py/objexcept.h"

/*
 * lvgl includes
 */

#include "lvgl.h"


#define LV_OBJ_T lv_obj_t

typedef struct mp_lv_obj_type_t {
    const lv_obj_class_t *lv_obj_class;
    const mp_obj_type_t *mp_obj_type;
} mp_lv_obj_type_t;

STATIC const mp_lv_obj_type_t mp_lv_obj_type;
STATIC const mp_lv_obj_type_t *mp_lv_obj_types[];

STATIC inline const mp_obj_type_t *get_BaseObj_type()
{
    return mp_lv_obj_type.mp_obj_type;
}

MP_DEFINE_EXCEPTION(LvReferenceError, Exception)
    

/*
 * Helper functions
 */

#ifndef GENMPY_UNUSED
#ifdef __GNUC__
#define GENMPY_UNUSED __attribute__ ((unused))
#else
#define GENMPY_UNUSED
#endif // __GNUC__
#endif // GENMPY_UNUSED

// Custom function mp object

typedef mp_obj_t (*mp_fun_ptr_var_t)(size_t n, const mp_obj_t *, void *ptr);

typedef struct mp_lv_obj_fun_builtin_var_t {
    mp_obj_base_t base;
    mp_uint_t n_args;
    mp_fun_ptr_var_t mp_fun;
    void *lv_fun;
} mp_lv_obj_fun_builtin_var_t;

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);

GENMPY_UNUSED STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_type_fun_builtin_var,
    MP_QSTR_function,
    MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,
    call, lv_fun_builtin_var_call,
    unary_op, mp_unary_op,
    buffer, mp_func_get_buffer
);

GENMPY_UNUSED STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_type_fun_builtin_static_var,
    MP_QSTR_function,
    MP_TYPE_FLAG_BUILTIN_FUN,
    call, lv_fun_builtin_var_call,
    unary_op, mp_generic_unary_op,
    buffer, mp_func_get_buffer
);

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);
    mp_arg_check_num(n_args, n_kw, self->n_args, self->n_args, false);
    return self->mp_fun(n_args, args, self->lv_fun);
}

STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_fun;
    bufinfo->len = sizeof(self->lv_fun);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

#define MP_DEFINE_CONST_LV_FUN_OBJ_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_var}, n_args, mp_fun, lv_fun}

#define MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_static_var}, n_args, mp_fun, lv_fun}

// Casting

typedef struct mp_lv_struct_t
{
    mp_obj_base_t base;
    void *data;
} mp_lv_struct_t;

STATIC const mp_lv_struct_t mp_lv_null_obj;

#ifdef LV_OBJ_T
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);
#else
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags){ return 0; }
#endif

STATIC mp_int_t mp_blob_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);

STATIC mp_obj_t get_native_obj(mp_obj_t mp_obj)
{
    if (!MP_OBJ_IS_OBJ(mp_obj)) return mp_obj;
    const mp_obj_type_t *native_type = ((mp_obj_base_t*)mp_obj)->type;
    if (native_type == NULL)
        return NULL;
    if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(native_type, parent) == NULL ||
        (MP_OBJ_TYPE_GET_SLOT_OR_NULL(native_type, buffer) == mp_blob_get_buffer) ||
        (MP_OBJ_TYPE_GET_SLOT_OR_NULL(native_type, buffer) == mp_lv_obj_get_buffer))
       return mp_obj;
    while (MP_OBJ_TYPE_GET_SLOT_OR_NULL(native_type, parent)) native_type = MP_OBJ_TYPE_GET_SLOT(native_type, parent);
    return mp_obj_cast_to_native_base(mp_obj, MP_OBJ_FROM_PTR(native_type));
}

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type);

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args);

STATIC mp_obj_t cast(mp_obj_t mp_obj, const mp_obj_type_t *mp_type)
{
    mp_obj_t res = NULL;
    if (mp_obj == mp_const_none && MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_type, make_new) == &make_new_lv_struct) {
        res = MP_OBJ_FROM_PTR(&mp_lv_null_obj);
    } else if (MP_OBJ_IS_OBJ(mp_obj)) {
        res = get_native_obj(mp_obj);
        if (res){
            const mp_obj_type_t *res_type = ((mp_obj_base_t*)res)->type;
            if (res_type != mp_type){
                if (res_type == &mp_type_dict &&
                    MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_type, make_new) == &make_new_lv_struct)
                        res = dict_to_struct(res, mp_type);
                else res = NULL;
            }
        }
    }
    if (res == NULL) nlr_raise(
        mp_obj_new_exception_msg_varg(
            &mp_type_SyntaxError, MP_ERROR_TEXT("Can't convert %s to %s!"), mp_obj_get_type_str(mp_obj), qstr_str(mp_type->name)));
    return res;
}

// object handling
// This section is enabled only when objects are supported

#ifdef LV_OBJ_T

typedef struct mp_lv_obj_t {
    mp_obj_base_t base;
    LV_OBJ_T *lv_obj;
    LV_OBJ_T *callbacks;
} mp_lv_obj_t;

STATIC inline LV_OBJ_T *mp_to_lv(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_obj_t native_obj = get_native_obj(mp_obj);
    if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_obj_get_type(native_obj), buffer) != mp_lv_obj_get_buffer)
        return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(native_obj);
    if (mp_lv_obj->lv_obj == NULL) {
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_LvReferenceError, MP_ERROR_TEXT("Referenced object was deleted!")));
    }
    return mp_lv_obj->lv_obj;
}

STATIC inline LV_OBJ_T *mp_get_callbacks(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    if (mp_lv_obj == NULL)
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("'user_data' argument must be either a dict or None!")));
    if (!mp_lv_obj->callbacks) mp_lv_obj->callbacks = mp_obj_new_dict(0);
    return mp_lv_obj->callbacks;
}

STATIC inline const mp_obj_type_t *get_BaseObj_type();

STATIC void mp_lv_delete_cb(lv_event_t * e)
{
    LV_OBJ_T *lv_obj = e->current_target;
    if (lv_obj){
        mp_lv_obj_t *self = lv_obj->user_data;
        if (self) {
            self->lv_obj = NULL;
        }
    }
}

STATIC inline mp_obj_t lv_to_mp(LV_OBJ_T *lv_obj)
{
    if (lv_obj == NULL) return mp_const_none;
    mp_lv_obj_t *self = (mp_lv_obj_t*)lv_obj->user_data;
    if (!self)
    {
        // Find the object type
        const mp_obj_type_t *mp_obj_type = get_BaseObj_type();
        const lv_obj_class_t *lv_obj_class = lv_obj_get_class(lv_obj);
        const mp_lv_obj_type_t **iter = &mp_lv_obj_types[0];
        for (; *iter; iter++) {
            if ((*iter)->lv_obj_class == lv_obj_class) {
                mp_obj_type = (*iter)->mp_obj_type;
                break;
            }
        }

        // Create the MP object
        self = m_new_obj(mp_lv_obj_t);
        *self = (mp_lv_obj_t){
            .base = {(const mp_obj_type_t *)mp_obj_type},
            .lv_obj = lv_obj,
            .callbacks = NULL,
        };

        // Register the Python object in user_data
        lv_obj->user_data = self;

        // Register a "Delete" event callback
        lv_obj_add_event_cb(lv_obj, mp_lv_delete_cb, LV_EVENT_DELETE, NULL);
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC void* mp_to_ptr(mp_obj_t self_in);

STATIC mp_obj_t cast_obj_type(const mp_obj_type_t* type, mp_obj_t obj)
{
    mp_lv_obj_t *self = m_new_obj(mp_lv_obj_t);
    *self = (mp_lv_obj_t){
        .base = {type},
        .lv_obj = mp_to_ptr(obj),
        .callbacks = NULL,
    };
    if (!self->lv_obj) return mp_const_none;
    return MP_OBJ_FROM_PTR(self);
}

STATIC mp_obj_t cast_obj(mp_obj_t type_obj, mp_obj_t obj)
{
    return cast_obj_type((const mp_obj_type_t *)type_obj, obj);
}

STATIC mp_obj_t make_new(
    const mp_lv_obj_fun_builtin_var_t *lv_obj_var,
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    mp_obj_t lv_obj;
    if (n_args == 0 && n_kw == 0) // allow no args, and pass NULL as parent in such case
    {
        const mp_obj_t no_args[] = {mp_const_none};
        lv_obj = mp_call_function_n_kw(MP_OBJ_FROM_PTR(lv_obj_var), 1, 0, no_args);
    }
    else
    {
        lv_obj = mp_call_function_n_kw(MP_OBJ_FROM_PTR(lv_obj_var), n_args, n_kw, args);
    }

    if (!lv_obj) return mp_const_none;

    mp_lv_obj_t *self = MP_OBJ_TO_PTR(lv_obj);
    if (self->base.type != type)
        return cast_obj_type(type, lv_obj);
    return lv_obj;
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(cast_obj_obj, cast_obj);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(cast_obj_class_method, MP_ROM_PTR(&cast_obj_obj));

STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_obj_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_obj;
    bufinfo->len = sizeof(self->lv_obj);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

STATIC mp_obj_t mp_lv_obj_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in)
{
    mp_lv_obj_t *lhs = MP_OBJ_TO_PTR(lhs_in);
    mp_lv_obj_t *rhs = MP_OBJ_TO_PTR(rhs_in);
    switch (op)
    {
        case MP_BINARY_OP_EQUAL:
            return mp_obj_new_bool(lhs->lv_obj == rhs->lv_obj);
        case MP_BINARY_OP_NOT_EQUAL:
            return mp_obj_new_bool(lhs->lv_obj != rhs->lv_obj);
        default:
            return MP_OBJ_NULL;
    }
}

// Register LVGL root pointers
MP_REGISTER_ROOT_POINTER(void *mp_lv_roots);
MP_REGISTER_ROOT_POINTER(void *mp_lv_user_data);

void *mp_lv_roots;

void mp_lv_init_gc()
{
    static bool mp_lv_roots_initialized = false;
    if (!mp_lv_roots_initialized) {
        mp_lv_roots = MP_STATE_VM(mp_lv_roots) = m_new0(lv_global_t, 1);
        mp_lv_roots_initialized = true;
    }
}

#else // LV_OBJ_T

typedef struct mp_lv_obj_type_t {
    mp_obj_type_t *mp_obj_type;
} mp_lv_obj_type_t;

#endif

STATIC inline mp_obj_t convert_to_bool(bool b)
{
    return b? mp_const_true: mp_const_false;
}

STATIC inline mp_obj_t convert_to_str(const char *str)
{
    return str? mp_obj_new_str(str, strlen(str)): mp_const_none;
}

STATIC inline const char *convert_from_str(mp_obj_t str)
{
    if (str == NULL || str == mp_const_none)
        return NULL;

    if (MP_OBJ_IS_TYPE(str, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(str, &mp_type_memoryview)) {
            mp_buffer_info_t buffer_info;
            if (mp_get_buffer(str, &buffer_info, MP_BUFFER_READ)) {
                return buffer_info.buf;
            }
    }

    return mp_obj_str_get_str(str);
}

// struct handling

STATIC mp_lv_struct_t *mp_to_lv_struct(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_obj_t native_obj = get_native_obj(mp_obj);
    if ( (!MP_OBJ_IS_OBJ(native_obj)) || (MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_obj_get_type(native_obj), make_new) != &make_new_lv_struct) ) nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Expected Struct object!")));
    mp_lv_struct_t *mp_lv_struct = MP_OBJ_TO_PTR(native_obj);
    return mp_lv_struct;
}

STATIC inline size_t get_lv_struct_size(const mp_obj_type_t *type)
{
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(MP_OBJ_TYPE_GET_SLOT(type, locals_dict));
    mp_map_elem_t *elem = mp_map_lookup(&self->map, MP_OBJ_NEW_QSTR(MP_QSTR___SIZE__), MP_MAP_LOOKUP);
    if (elem == NULL) {
        return 0;
    } else {
        return (size_t)mp_obj_get_int(elem->value);
    }
}

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    if ((!MP_OBJ_IS_TYPE(type, &mp_type_type)) || MP_OBJ_TYPE_GET_SLOT_OR_NULL(type, make_new) != &make_new_lv_struct)
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Argument is not a struct type!")));
    size_t size = get_lv_struct_size(type);
    mp_arg_check_num(n_args, n_kw, 0, 1, false);
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    mp_lv_struct_t *other = (n_args > 0) && (!mp_obj_is_int(args[0])) ? mp_to_lv_struct(cast(args[0], type)): NULL;
    size_t count = (n_args > 0) && (mp_obj_is_int(args[0]))? mp_obj_get_int(args[0]): 1;
    *self = (mp_lv_struct_t){
        .base = {type},
        .data = (size == 0 || (other && other->data == NULL))? NULL: m_malloc(size * count)
    };
    if (self->data) {
        if (other) {
            memcpy(self->data, other->data, size * count);
        } else {
            memset(self->data, 0, size * count);
        }
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC mp_obj_t lv_struct_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in)
{
    mp_lv_struct_t *lhs = MP_OBJ_TO_PTR(lhs_in);
    mp_lv_struct_t *rhs = MP_OBJ_TO_PTR(rhs_in);
    switch (op)
    {
        case MP_BINARY_OP_EQUAL:
            return mp_obj_new_bool(lhs->data == rhs->data);
        case MP_BINARY_OP_NOT_EQUAL:
            return mp_obj_new_bool(lhs->data != rhs->data);
        default:
            return MP_OBJ_NULL;
    }
}

STATIC mp_obj_t lv_struct_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value)
{
    mp_lv_struct_t *self = mp_to_lv_struct(self_in);

    if ((!self) || (!self->data))
        return NULL;
    if (!mp_obj_is_int(index)) {
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Subscript index must be an integer!")));
    }

    const mp_obj_type_t *type = mp_obj_get_type(self_in);
    size_t element_size = get_lv_struct_size(type);
    if (element_size == 0) return mp_const_none;
    size_t element_index = mp_obj_get_int(index);
    void *element_addr = (byte*)self->data + element_size*element_index;

    if (value == MP_OBJ_NULL) {
        memset(element_addr, 0, element_size);
        return self_in;
    }

    mp_lv_struct_t *element_at_index = m_new_obj(mp_lv_struct_t);
    *element_at_index = (mp_lv_struct_t){
        .base = {type},
        .data = element_addr
    };

    if (value != MP_OBJ_SENTINEL){
        mp_lv_struct_t *other = mp_to_lv_struct(cast(value, type));
        if ((!other) || (!other->data))
            return NULL;
        memcpy(element_at_index->data, other->data, element_size);
    }

    return MP_OBJ_FROM_PTR(element_at_index);
}

GENMPY_UNUSED STATIC void *copy_buffer(const void *buffer, size_t size)
{
    void *new_buffer = m_malloc(size);
    memcpy(new_buffer, buffer, size);
    return new_buffer;
}

// Reference an existing lv struct (or part of it)

STATIC mp_obj_t lv_to_mp_struct(const mp_obj_type_t *type, void *lv_struct)
{
    if (lv_struct == NULL) return mp_const_none;
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {type},
        .data = lv_struct
    };
    return MP_OBJ_FROM_PTR(self);
}

STATIC void call_parent_methods(mp_obj_t obj, qstr attr, mp_obj_t *dest)
{
    const mp_obj_type_t *type = mp_obj_get_type(obj);
    while (MP_OBJ_TYPE_HAS_SLOT(type, locals_dict)) {
        // generic method lookup
        // this is a lookup in the object (ie not class or type)
        assert(MP_OBJ_TYPE_GET_SLOT(type, locals_dict)->base.type == &mp_type_dict); // MicroPython restriction, for now
        mp_map_t *locals_map = &MP_OBJ_TYPE_GET_SLOT(type, locals_dict)->map;
        mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
        if (elem != NULL) {
            mp_convert_member_lookup(obj, type, elem->value, dest);
            break;
        }
        if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(type, parent) == NULL) {
            break;
        }
        // search parents
        type = MP_OBJ_TYPE_GET_SLOT(type, parent);
    }
}

// Convert dict to struct

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type)
{
    mp_obj_t mp_struct = make_new_lv_struct(type, 0, 0, NULL);
    mp_obj_t native_dict = cast(dict, &mp_type_dict);
    mp_map_t *map = mp_obj_dict_get_map(native_dict);
    if (map == NULL) return mp_const_none;
    for (uint i = 0; i < map->alloc; i++) {
        mp_obj_t key = map->table[i].key;
        mp_obj_t value = map->table[i].value;
        if (key != MP_OBJ_NULL) {
            mp_obj_t dest[] = {MP_OBJ_SENTINEL, value};
            MP_OBJ_TYPE_GET_SLOT(type, attr)(mp_struct, mp_obj_str_get_qstr(key), dest);
            if (dest[0]) nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot set field %s on struct %s!"), qstr_str(mp_obj_str_get_qstr(key)), qstr_str(type->name)));
        }
    }
    return mp_struct;
}

// Convert mp object to ptr

STATIC void* mp_to_ptr(mp_obj_t self_in)
{
    mp_buffer_info_t buffer_info;
    if (self_in == NULL || self_in == mp_const_none)
        return NULL;

//    if (MP_OBJ_IS_INT(self_in))
//        return (void*)mp_obj_get_int(self_in);

    // If an object is user instance, take it as is so it could be used as user_data
    if (mp_obj_is_instance_type(mp_obj_get_type(self_in))){
        return MP_OBJ_TO_PTR(self_in);
    }

    if (!mp_get_buffer(self_in, &buffer_info, MP_BUFFER_READ)) {
        // No buffer protocol - this is not a Struct or a Blob, it's some other mp object.
        // We only allow setting dict directly, since it's useful to setting user_data for passing data to C.
        // On other cases throw an exception, to avoid a crash later
        if (MP_OBJ_IS_TYPE(self_in, &mp_type_dict))
            return MP_OBJ_TO_PTR(self_in);
        else nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert '%s' to pointer!"), mp_obj_get_type_str(self_in)));
    }

    if (MP_OBJ_IS_STR_OR_BYTES(self_in) ||
        MP_OBJ_IS_TYPE(self_in, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(self_in, &mp_type_memoryview))
            return buffer_info.buf;
    else
    {
        void *result;
        if (buffer_info.len != sizeof(result) || buffer_info.typecode != BYTEARRAY_TYPECODE){
            nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert %s to pointer! (buffer does not represent a pointer)"), mp_obj_get_type_str(self_in)));
        }
        memcpy(&result, buffer_info.buf, sizeof(result));
        return result;
    }
}

// Blob is a wrapper for void*

STATIC void mp_blob_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "Blob");
}

STATIC mp_int_t mp_blob_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->data;
    bufinfo->len = sizeof(self->data);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

STATIC const mp_obj_fun_builtin_var_t mp_lv_dereference_obj;

// Sometimes (but not always!) Blob represents a Micropython object.
// In such cases it's safe to cast the Blob back to the Micropython object
// cast argument is the underlying object type, and it's optional.

STATIC mp_obj_t mp_blob_cast(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self = argv[0];
    void *ptr = mp_to_ptr(self);
    if (argc == 1) return MP_OBJ_FROM_PTR(ptr);
    mp_obj_t type = argv[1];
    if (!MP_OBJ_IS_TYPE(type, &mp_type_type))
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Cast argument must be a type!")));
    return cast(MP_OBJ_FROM_PTR(ptr), type);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_blob_cast_obj, 1, 2, mp_blob_cast);

STATIC const mp_rom_map_elem_t mp_blob_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR___cast__), MP_ROM_PTR(&mp_blob_cast_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_blob_locals_dict, mp_blob_locals_dict_table);

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_blob_type,
    MP_QSTR_Blob,
    MP_TYPE_FLAG_NONE,
    binary_op, lv_struct_binary_op,
    print, mp_blob_print,
    locals_dict, &mp_blob_locals_dict,
    buffer, mp_blob_get_buffer
);

STATIC const mp_lv_struct_t mp_lv_null_obj = { {&mp_blob_type}, NULL };

STATIC inline mp_obj_t ptr_to_mp(void *data)
{
    return lv_to_mp_struct(&mp_blob_type, data);
}

// Cast pointer to struct

STATIC mp_obj_t mp_lv_cast(mp_obj_t type_obj, mp_obj_t ptr_obj)
{
    void *ptr = mp_to_ptr(ptr_obj);
    if (!ptr) return mp_const_none;
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {(const mp_obj_type_t*)type_obj},
        .data = ptr
    };
    return MP_OBJ_FROM_PTR(self);
}

// Cast instance. Can be used in ISR when memory allocation is prohibited

STATIC inline mp_obj_t mp_lv_cast_instance(mp_obj_t self_in, mp_obj_t ptr_obj)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    self->data = mp_to_ptr(ptr_obj);
    return self_in;
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_obj, mp_lv_cast);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(mp_lv_cast_class_method, MP_ROM_PTR(&mp_lv_cast_obj));

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_instance_obj, mp_lv_cast_instance);

// Dereference a struct/blob. This allows access to the raw data the struct holds

STATIC mp_obj_t mp_lv_dereference(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self_in = argv[0];
    mp_obj_t size_in = argc > 1? argv[1]: mp_const_none;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    size_t size = 0;
    if (size_in == mp_const_none){
        const mp_obj_type_t *type = self->base.type;
        size = get_lv_struct_size(type);
    } else {
        size = (size_t)mp_obj_get_int(size_in);
    }
    if (size == 0) return mp_const_none;
    mp_obj_array_t *view = MP_OBJ_TO_PTR(mp_obj_new_memoryview(BYTEARRAY_TYPECODE,
        size, self->data));
    view->typecode |= 0x80; // used to indicate writable buffer
    return MP_OBJ_FROM_PTR(view);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_lv_dereference_obj, 1, 2, mp_lv_dereference);

// Callback function handling
// Callback is either a callable object or a pointer. If it's a callable object, set user_data to the callback.
// Multiple callbacks are kept per object/struct using a dict that associate callback name with callback object
// In case of an lv_obj_t, user_data is mp_lv_obj_t which contains a member "callbacks" for that dict.
// In case of a struct, user_data is a pointer to that dict directly

STATIC mp_obj_t get_callback_dict_from_user_data(void *user_data)
{
    if (user_data){
        mp_obj_t obj = MP_OBJ_FROM_PTR(user_data);
#ifdef LV_OBJ_T
        return
            MP_OBJ_IS_TYPE(obj, &mp_type_dict)? obj: // Handle the case of dict for a struct
            mp_get_callbacks(obj); // Handle the case of mp_lv_obj_t for an lv_obj_t
#else
        return obj;
#endif
    }
    return NULL;
}

typedef void *(*mp_lv_get_user_data)(void *);
typedef void (*mp_lv_set_user_data)(void *, void *);

STATIC void *mp_lv_callback(mp_obj_t mp_callback, void *lv_callback, qstr callback_name,
     void **user_data_ptr, void *containing_struct, mp_lv_get_user_data get_user_data, mp_lv_set_user_data set_user_data)
{
    if (lv_callback && mp_obj_is_callable(mp_callback)) {
        void *user_data = NULL;
        if (user_data_ptr) {
            // user_data is either a dict of callbacks in case of struct, or a pointer to mp_lv_obj_t in case of lv_obj_t
            if (! (*user_data_ptr) ) *user_data_ptr = MP_OBJ_TO_PTR(mp_obj_new_dict(0)); // if it's NULL - it's a dict for a struct
            user_data = *user_data_ptr;
        }
        else if (get_user_data && set_user_data) {
            user_data = get_user_data(containing_struct);
            if (!user_data) {
                user_data = MP_OBJ_TO_PTR(mp_obj_new_dict(0));
                set_user_data(containing_struct, user_data);
            }
        }

        if (user_data) {
            mp_obj_t callbacks = get_callback_dict_from_user_data(user_data);
            mp_obj_dict_store(callbacks, MP_OBJ_NEW_QSTR(callback_name), mp_callback);
        }
        return lv_callback;
    } else {
        return mp_to_ptr(mp_callback);
    }
}

static int _nesting = 0;

// Function pointers wrapper

STATIC mp_obj_t mp_lv_funcptr(const mp_lv_obj_fun_builtin_var_t *mp_fun, void *lv_fun, void *lv_callback, qstr func_name, void *user_data)
{
    if (lv_fun == NULL)
        return mp_const_none;
    if (lv_fun == lv_callback) {
        mp_obj_t callbacks = get_callback_dict_from_user_data(user_data);
        if (callbacks)
            return mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(func_name));
    }
    mp_lv_obj_fun_builtin_var_t *funcptr = m_new_obj(mp_lv_obj_fun_builtin_var_t);
    *funcptr = *mp_fun;
    funcptr->lv_fun = lv_fun;
    return MP_OBJ_FROM_PTR(funcptr);
}

// Missing implementation for 64bit integer conversion

STATIC unsigned long long mp_obj_get_ull(mp_obj_t obj)
{
    if (mp_obj_is_small_int(obj))
        return MP_OBJ_SMALL_INT_VALUE(obj);

    unsigned long long val = 0;
    bool big_endian = !(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__);
    mp_obj_int_to_bytes_impl(obj, big_endian, sizeof(val), (byte*)&val);
    return val;
}


// Array of natives

typedef struct mp_lv_array_t
{
    mp_lv_struct_t base;
    size_t element_size;
    bool is_signed;
} mp_lv_array_t;

STATIC void mp_lv_array_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_lv_array_t *self = MP_OBJ_TO_PTR(self_in);
    size_t element_size = self->element_size;
    bool is_signed = self->is_signed;
    mp_printf(print, "C Array (%sint%d[])", is_signed? "": "u", element_size*8);
}

STATIC mp_obj_t lv_array_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value)
{
    mp_lv_array_t *self = MP_OBJ_TO_PTR(self_in);

    if ((!self) || (!self->base.data))
        return NULL;
    if (!mp_obj_is_int(index)) {
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Subscript index must be an integer!")));
    }

    size_t element_size = self->element_size;
    size_t element_index = mp_obj_get_int(index);
    void *element_addr = (byte*)self->base.data + element_size*element_index;
    bool is_signed = self->is_signed;
    union {
        long long val;
        unsigned long long uval;
    } element;
    memset(&element, 0, sizeof(element));

    if (value == MP_OBJ_NULL){
        memset(element_addr, 0, element_size);
    }
    else if (value == MP_OBJ_SENTINEL){
        memcpy(&element, element_addr, element_size);
        return is_signed? mp_obj_new_int_from_ll(element.val): mp_obj_new_int_from_ull(element.uval);
    } else {
        if (!mp_obj_is_int(value)) {
            nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Value '%s' must be an integer!"), mp_obj_get_type_str(value)));
        }
        element.uval = mp_obj_get_ull(value);
        memcpy(element_addr, &element, element_size);
    }

    return self_in;
}

STATIC const mp_rom_map_elem_t mp_base_struct_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___cast__), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR___cast_instance__), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_base_struct_locals_dict, mp_base_struct_locals_dict_table);

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_base_struct_type,
    MP_QSTR_Struct,
    MP_TYPE_FLAG_NONE,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    buffer, mp_blob_get_buffer,
    locals_dict, &mp_base_struct_locals_dict
);

// TODO: provide constructor
STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_array_type,
    MP_QSTR_C_Array,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_array_print,
    binary_op, lv_struct_binary_op,
    subscr, lv_array_subscr,
    buffer, mp_blob_get_buffer,
    locals_dict, &mp_base_struct_locals_dict
);

GENMPY_UNUSED STATIC mp_obj_t mp_array_from_ptr(void *lv_arr, size_t element_size, bool is_signed)
{
    mp_lv_array_t *self = m_new_obj(mp_lv_array_t);
    *self = (mp_lv_array_t){
        { {&mp_lv_array_type}, lv_arr },
        element_size,
        is_signed
    };
    return MP_OBJ_FROM_PTR(self);
}

GENMPY_UNUSED STATIC void *mp_array_to_ptr(mp_obj_t *mp_arr, size_t element_size, GENMPY_UNUSED bool is_signed)
{
    if (MP_OBJ_IS_STR_OR_BYTES(mp_arr) ||
        MP_OBJ_IS_TYPE(mp_arr, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(mp_arr, &mp_type_memoryview)){
            return mp_to_ptr(mp_arr);
    }

    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    void *lv_arr = m_malloc(len * element_size);
    byte *element_addr = (byte*)lv_arr;
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        union {
            long long val;
            unsigned long long uval;
        } element;
        if (!mp_obj_is_int(item)) {
            nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Value '%s' must be an integer!"), mp_obj_get_type_str(item)));
        }
        element.uval = mp_obj_get_ull(item);
        memcpy(element_addr, &element, element_size);
        element_addr += element_size;
    }
    return lv_arr;
}

#define MP_ARRAY_CONVERTOR(name, size, is_signed) GENMPY_UNUSED STATIC mp_obj_t mp_array_from_ ## name(void *lv_arr){    return mp_array_from_ptr(lv_arr, size, is_signed);}GENMPY_UNUSED STATIC void *mp_array_to_ ## name(mp_obj_t mp_arr){    return mp_array_to_ptr(mp_arr, size, is_signed);}

MP_ARRAY_CONVERTOR(u8ptr, 1, false)
MP_ARRAY_CONVERTOR(i8ptr, 1, true)
MP_ARRAY_CONVERTOR(u16ptr, 2, false)
MP_ARRAY_CONVERTOR(i16ptr, 2, true)
MP_ARRAY_CONVERTOR(u32ptr, 4, false)
MP_ARRAY_CONVERTOR(i32ptr, 4, true)
MP_ARRAY_CONVERTOR(u64ptr, 8, false)
MP_ARRAY_CONVERTOR(i64ptr, 8, true)



/*
 * LVGL string constants
 */

MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BULLET, LV_SYMBOL_BULLET);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_AUDIO, LV_SYMBOL_AUDIO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VIDEO, LV_SYMBOL_VIDEO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LIST, LV_SYMBOL_LIST);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_OK, LV_SYMBOL_OK);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CLOSE, LV_SYMBOL_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_POWER, LV_SYMBOL_POWER);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SETTINGS, LV_SYMBOL_SETTINGS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_HOME, LV_SYMBOL_HOME);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWNLOAD, LV_SYMBOL_DOWNLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DRIVE, LV_SYMBOL_DRIVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_REFRESH, LV_SYMBOL_REFRESH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MUTE, LV_SYMBOL_MUTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MID, LV_SYMBOL_VOLUME_MID);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MAX, LV_SYMBOL_VOLUME_MAX);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_IMAGE, LV_SYMBOL_IMAGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_TINT, LV_SYMBOL_TINT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PREV, LV_SYMBOL_PREV);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLAY, LV_SYMBOL_PLAY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PAUSE, LV_SYMBOL_PAUSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_STOP, LV_SYMBOL_STOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEXT, LV_SYMBOL_NEXT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EJECT, LV_SYMBOL_EJECT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LEFT, LV_SYMBOL_LEFT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_RIGHT, LV_SYMBOL_RIGHT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLUS, LV_SYMBOL_PLUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MINUS, LV_SYMBOL_MINUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_OPEN, LV_SYMBOL_EYE_OPEN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_CLOSE, LV_SYMBOL_EYE_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WARNING, LV_SYMBOL_WARNING);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SHUFFLE, LV_SYMBOL_SHUFFLE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UP, LV_SYMBOL_UP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWN, LV_SYMBOL_DOWN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LOOP, LV_SYMBOL_LOOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DIRECTORY, LV_SYMBOL_DIRECTORY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UPLOAD, LV_SYMBOL_UPLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CALL, LV_SYMBOL_CALL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CUT, LV_SYMBOL_CUT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_COPY, LV_SYMBOL_COPY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SAVE, LV_SYMBOL_SAVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BARS, LV_SYMBOL_BARS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_ENVELOPE, LV_SYMBOL_ENVELOPE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CHARGE, LV_SYMBOL_CHARGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PASTE, LV_SYMBOL_PASTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BELL, LV_SYMBOL_BELL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_KEYBOARD, LV_SYMBOL_KEYBOARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_GPS, LV_SYMBOL_GPS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_FILE, LV_SYMBOL_FILE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WIFI, LV_SYMBOL_WIFI);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_FULL, LV_SYMBOL_BATTERY_FULL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_3, LV_SYMBOL_BATTERY_3);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_2, LV_SYMBOL_BATTERY_2);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_1, LV_SYMBOL_BATTERY_1);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_EMPTY, LV_SYMBOL_BATTERY_EMPTY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_USB, LV_SYMBOL_USB);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BLUETOOTH, LV_SYMBOL_BLUETOOTH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_TRASH, LV_SYMBOL_TRASH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EDIT, LV_SYMBOL_EDIT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BACKSPACE, LV_SYMBOL_BACKSPACE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SD_CARD, LV_SYMBOL_SD_CARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEW_LINE, LV_SYMBOL_NEW_LINE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DUMMY, LV_SYMBOL_DUMMY);

/*
 * Helper Structs
 */
        

typedef union {
    void*           ptr_val;
    const char*     str_val;
    int             int_val;
    unsigned int    uint_val;
} C_Pointer;


/*
 * Struct C_Pointer
 */

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type();

STATIC inline void* mp_write_ptr_C_Pointer(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_C_Pointer_type()));
    return (C_Pointer*)self->data;
}

#define mp_write_C_Pointer(struct_obj) *((C_Pointer*)mp_write_ptr_C_Pointer(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_C_Pointer(void *field)
{
    return lv_to_mp_struct(get_mp_C_Pointer_type(), field);
}

#define mp_read_C_Pointer(field) mp_read_ptr_C_Pointer(copy_buffer(&field, sizeof(C_Pointer)))
#define mp_read_byref_C_Pointer(field) mp_read_ptr_C_Pointer(&field)

STATIC void mp_C_Pointer_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED C_Pointer *data = (C_Pointer*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_ptr_val: dest[0] = ptr_to_mp((void*)data->ptr_val); break; // converting from void *;
            case MP_QSTR_str_val: dest[0] = convert_to_str((void*)data->str_val); break; // converting from char *;
            case MP_QSTR_int_val: dest[0] = mp_obj_new_int(data->int_val); break; // converting from int;
            case MP_QSTR_uint_val: dest[0] = mp_obj_new_int_from_uint(data->uint_val); break; // converting from unsigned int;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_ptr_val: data->ptr_val = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_str_val: data->str_val = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_int_val: data->int_val = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_uint_val: data->uint_val = (unsigned int)mp_obj_get_int(dest[1]); break; // converting to unsigned int;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_C_Pointer_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct C_Pointer");
}

STATIC const mp_obj_dict_t mp_C_Pointer_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_C_Pointer_type,
    MP_QSTR_C_Pointer,
    MP_TYPE_FLAG_NONE,
    print, mp_C_Pointer_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_C_Pointer_attr,
    locals_dict, &mp_C_Pointer_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type()
{
    return &mp_C_Pointer_type;
}
    

/*
 * lvgl LV_RESULT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_RESULT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INVALID), MP_ROM_PTR(MP_ROM_INT(LV_RESULT_INVALID)) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_RESULT_OK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_RESULT_locals_dict, LV_RESULT_locals_dict_table);

STATIC void LV_RESULT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_RESULT");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_RESULT_type_base,
    MP_QSTR_LV_RESULT,
    MP_TYPE_FLAG_NONE,
    print, LV_RESULT_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_RESULT_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_RESULT_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_RESULT_type_base,
};
    

/*
 * lvgl ENUM_LV_LOG_LEVEL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LOG_LEVEL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRACE), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_TRACE)) },
    { MP_ROM_QSTR(MP_QSTR_INFO), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_INFO)) },
    { MP_ROM_QSTR(MP_QSTR_WARN), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_WARN)) },
    { MP_ROM_QSTR(MP_QSTR_ERROR), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_ERROR)) },
    { MP_ROM_QSTR(MP_QSTR_USER), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_USER)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_LOG_LEVEL_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LOG_LEVEL_locals_dict, LV_LOG_LEVEL_locals_dict_table);

STATIC void LV_LOG_LEVEL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LOG_LEVEL");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_ENUM_LV_LOG_LEVEL_type_base,
    MP_QSTR_ENUM_LV_LOG_LEVEL,
    MP_TYPE_FLAG_NONE,
    print, ENUM_LV_LOG_LEVEL_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &ENUM_LV_LOG_LEVEL_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_ENUM_LV_LOG_LEVEL_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_ENUM_LV_LOG_LEVEL_type_base,
};
    

/*
 * lvgl LV_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ALIGN_locals_dict, LV_ALIGN_locals_dict_table);

STATIC void LV_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ALIGN");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_ALIGN_type_base,
    MP_QSTR_LV_ALIGN,
    MP_TYPE_FLAG_NONE,
    print, LV_ALIGN_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_ALIGN_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_ALIGN_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_ALIGN_type_base,
};
    

/*
 * lvgl LV_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_DIR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DIR_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DIR_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_DIR_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_DIR_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_DIR_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_ALL), MP_ROM_PTR(MP_ROM_INT(LV_DIR_ALL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DIR_locals_dict, LV_DIR_locals_dict_table);

STATIC void LV_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DIR");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DIR_type_base,
    MP_QSTR_LV_DIR,
    MP_TYPE_FLAG_NONE,
    print, LV_DIR_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DIR_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DIR_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DIR_type_base,
};
    

/*
 * lvgl ENUM_LV_COORD object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_COORD_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAX), MP_ROM_PTR(MP_ROM_INT(LV_COORD_MAX)) },
    { MP_ROM_QSTR(MP_QSTR_MIN), MP_ROM_PTR(MP_ROM_INT(LV_COORD_MIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_COORD_locals_dict, LV_COORD_locals_dict_table);

STATIC void  LV_COORD_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_COORD");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_ENUM_LV_COORD_type_base,
    MP_QSTR_ENUM_LV_COORD,
    MP_TYPE_FLAG_NONE,
    print, ENUM_LV_COORD_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &ENUM_LV_COORD_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_ENUM_LV_COORD_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_ENUM_LV_COORD_type_base,
};
    

/*
 * lvgl LV_OPA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OPA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_OPA_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR__0), MP_ROM_PTR(MP_ROM_INT(LV_OPA_0)) },
    { MP_ROM_QSTR(MP_QSTR__10), MP_ROM_PTR(MP_ROM_INT(LV_OPA_10)) },
    { MP_ROM_QSTR(MP_QSTR__20), MP_ROM_PTR(MP_ROM_INT(LV_OPA_20)) },
    { MP_ROM_QSTR(MP_QSTR__30), MP_ROM_PTR(MP_ROM_INT(LV_OPA_30)) },
    { MP_ROM_QSTR(MP_QSTR__40), MP_ROM_PTR(MP_ROM_INT(LV_OPA_40)) },
    { MP_ROM_QSTR(MP_QSTR__50), MP_ROM_PTR(MP_ROM_INT(LV_OPA_50)) },
    { MP_ROM_QSTR(MP_QSTR__60), MP_ROM_PTR(MP_ROM_INT(LV_OPA_60)) },
    { MP_ROM_QSTR(MP_QSTR__70), MP_ROM_PTR(MP_ROM_INT(LV_OPA_70)) },
    { MP_ROM_QSTR(MP_QSTR__80), MP_ROM_PTR(MP_ROM_INT(LV_OPA_80)) },
    { MP_ROM_QSTR(MP_QSTR__90), MP_ROM_PTR(MP_ROM_INT(LV_OPA_90)) },
    { MP_ROM_QSTR(MP_QSTR__100), MP_ROM_PTR(MP_ROM_INT(LV_OPA_100)) },
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_OPA_COVER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OPA_locals_dict, LV_OPA_locals_dict_table);

STATIC void LV_OPA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OPA");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OPA_type_base,
    MP_QSTR_LV_OPA,
    MP_TYPE_FLAG_NONE,
    print, LV_OPA_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OPA_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OPA_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OPA_type_base,
};
    

/*
 * lvgl LV_COLOR_FORMAT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_COLOR_FORMAT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_UNKNOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RAW), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_RAW)) },
    { MP_ROM_QSTR(MP_QSTR_RAW_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_RAW_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_L8), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_L8)) },
    { MP_ROM_QSTR(MP_QSTR_I1), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I1)) },
    { MP_ROM_QSTR(MP_QSTR_I2), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I2)) },
    { MP_ROM_QSTR(MP_QSTR_I4), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I4)) },
    { MP_ROM_QSTR(MP_QSTR_I8), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I8)) },
    { MP_ROM_QSTR(MP_QSTR_A8), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_A8)) },
    { MP_ROM_QSTR(MP_QSTR_RGB565), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_RGB565)) },
    { MP_ROM_QSTR(MP_QSTR_RGB565A8), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_RGB565A8)) },
    { MP_ROM_QSTR(MP_QSTR_RGB888), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_RGB888)) },
    { MP_ROM_QSTR(MP_QSTR_ARGB8888), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_ARGB8888)) },
    { MP_ROM_QSTR(MP_QSTR_XRGB8888), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_XRGB8888)) },
    { MP_ROM_QSTR(MP_QSTR_A1), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_A1)) },
    { MP_ROM_QSTR(MP_QSTR_A2), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_A2)) },
    { MP_ROM_QSTR(MP_QSTR_A4), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_A4)) },
    { MP_ROM_QSTR(MP_QSTR_YUV_START), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_YUV_START)) },
    { MP_ROM_QSTR(MP_QSTR_I420), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I420)) },
    { MP_ROM_QSTR(MP_QSTR_I422), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I422)) },
    { MP_ROM_QSTR(MP_QSTR_I444), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I444)) },
    { MP_ROM_QSTR(MP_QSTR_I400), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_I400)) },
    { MP_ROM_QSTR(MP_QSTR_NV21), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_NV21)) },
    { MP_ROM_QSTR(MP_QSTR_NV12), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_NV12)) },
    { MP_ROM_QSTR(MP_QSTR_YUY2), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_YUY2)) },
    { MP_ROM_QSTR(MP_QSTR_UYVY), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_UYVY)) },
    { MP_ROM_QSTR(MP_QSTR_YUV_END), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_YUV_END)) },
    { MP_ROM_QSTR(MP_QSTR_NATIVE), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_NATIVE)) },
    { MP_ROM_QSTR(MP_QSTR_NATIVE_WITH_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_FORMAT_NATIVE_WITH_ALPHA)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_COLOR_FORMAT_locals_dict, LV_COLOR_FORMAT_locals_dict_table);

STATIC void LV_COLOR_FORMAT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_COLOR_FORMAT");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_COLOR_FORMAT_type_base,
    MP_QSTR_LV_COLOR_FORMAT,
    MP_TYPE_FLAG_NONE,
    print, LV_COLOR_FORMAT_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_COLOR_FORMAT_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_COLOR_FORMAT_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_COLOR_FORMAT_type_base,
};
    

/*
 * lvgl LV_FONT_SUBPX object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_SUBPX_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_VER)) },
    { MP_ROM_QSTR(MP_QSTR_BOTH), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_BOTH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_SUBPX_locals_dict, LV_FONT_SUBPX_locals_dict_table);

STATIC void LV_FONT_SUBPX_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_SUBPX");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FONT_SUBPX_type_base,
    MP_QSTR_LV_FONT_SUBPX,
    MP_TYPE_FLAG_NONE,
    print, LV_FONT_SUBPX_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FONT_SUBPX_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FONT_SUBPX_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FONT_SUBPX_type_base,
};
    

/*
 * lvgl LV_FONT_KERNING object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_KERNING_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_KERNING_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_FONT_KERNING_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_KERNING_locals_dict, LV_FONT_KERNING_locals_dict_table);

STATIC void LV_FONT_KERNING_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_KERNING");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FONT_KERNING_type_base,
    MP_QSTR_LV_FONT_KERNING,
    MP_TYPE_FLAG_NONE,
    print, LV_FONT_KERNING_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FONT_KERNING_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FONT_KERNING_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FONT_KERNING_type_base,
};
    

/*
 * lvgl LV_TEXT_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_FIT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_FIT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_FLAG_locals_dict, LV_TEXT_FLAG_locals_dict_table);

STATIC void LV_TEXT_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_FLAG");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_TEXT_FLAG_type_base,
    MP_QSTR_LV_TEXT_FLAG,
    MP_TYPE_FLAG_NONE,
    print, LV_TEXT_FLAG_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_TEXT_FLAG_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_TEXT_FLAG_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_TEXT_FLAG_type_base,
};
    

/*
 * lvgl LV_TEXT_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_RIGHT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_ALIGN_locals_dict, LV_TEXT_ALIGN_locals_dict_table);

STATIC void LV_TEXT_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_ALIGN");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_TEXT_ALIGN_type_base,
    MP_QSTR_LV_TEXT_ALIGN,
    MP_TYPE_FLAG_NONE,
    print, LV_TEXT_ALIGN_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_TEXT_ALIGN_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_TEXT_ALIGN_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_TEXT_ALIGN_type_base,
};
    

/*
 * lvgl LV_BASE_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BASE_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LTR), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_LTR)) },
    { MP_ROM_QSTR(MP_QSTR_RTL), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_RTL)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_NEUTRAL), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_NEUTRAL)) },
    { MP_ROM_QSTR(MP_QSTR_WEAK), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_WEAK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BASE_DIR_locals_dict, LV_BASE_DIR_locals_dict_table);

STATIC void LV_BASE_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BASE_DIR");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_BASE_DIR_type_base,
    MP_QSTR_LV_BASE_DIR,
    MP_TYPE_FLAG_NONE,
    print, LV_BASE_DIR_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_BASE_DIR_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_BASE_DIR_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_BASE_DIR_type_base,
};
    

/*
 * lvgl LV_BLEND_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BLEND_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_ADDITIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_ADDITIVE)) },
    { MP_ROM_QSTR(MP_QSTR_SUBTRACTIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_SUBTRACTIVE)) },
    { MP_ROM_QSTR(MP_QSTR_MULTIPLY), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_MULTIPLY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BLEND_MODE_locals_dict, LV_BLEND_MODE_locals_dict_table);

STATIC void LV_BLEND_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BLEND_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_BLEND_MODE_type_base,
    MP_QSTR_LV_BLEND_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_BLEND_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_BLEND_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_BLEND_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_BLEND_MODE_type_base,
};
    

/*
 * lvgl LV_TEXT_DECOR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_DECOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_UNDERLINE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_UNDERLINE)) },
    { MP_ROM_QSTR(MP_QSTR_STRIKETHROUGH), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_STRIKETHROUGH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_DECOR_locals_dict, LV_TEXT_DECOR_locals_dict_table);

STATIC void LV_TEXT_DECOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_DECOR");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_TEXT_DECOR_type_base,
    MP_QSTR_LV_TEXT_DECOR,
    MP_TYPE_FLAG_NONE,
    print, LV_TEXT_DECOR_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_TEXT_DECOR_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_TEXT_DECOR_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_TEXT_DECOR_type_base,
};
    

/*
 * lvgl LV_BORDER_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BORDER_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_INTERNAL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_INTERNAL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BORDER_SIDE_locals_dict, LV_BORDER_SIDE_locals_dict_table);

STATIC void LV_BORDER_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BORDER_SIDE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_BORDER_SIDE_type_base,
    MP_QSTR_LV_BORDER_SIDE,
    MP_TYPE_FLAG_NONE,
    print, LV_BORDER_SIDE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_BORDER_SIDE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_BORDER_SIDE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_BORDER_SIDE_type_base,
};
    

/*
 * lvgl LV_GRAD_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GRAD_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_HOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GRAD_DIR_locals_dict, LV_GRAD_DIR_locals_dict_table);

STATIC void LV_GRAD_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GRAD_DIR");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_GRAD_DIR_type_base,
    MP_QSTR_LV_GRAD_DIR,
    MP_TYPE_FLAG_NONE,
    print, LV_GRAD_DIR_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_GRAD_DIR_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_GRAD_DIR_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_GRAD_DIR_type_base,
};
    

/*
 * lvgl LV_STYLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STYLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PROP_INV), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PROP_INV)) },
    { MP_ROM_QSTR(MP_QSTR_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LENGTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LENGTH)) },
    { MP_ROM_QSTR(MP_QSTR_MIN_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MIN_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_MAX_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MAX_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_MIN_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MIN_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MAX_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MAX_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_X)) },
    { MP_ROM_QSTR(MP_QSTR_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_Y)) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_TOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_ROW), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_ROW)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_COLUMN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_COLUMN)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LAYOUT)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_TOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BG_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_DIR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_DIR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_MAIN_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_MAIN_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_MAIN_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_MAIN_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD)) },
    { MP_ROM_QSTR(MP_QSTR_BASE_DIR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BASE_DIR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMAGE_SRC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMAGE_SRC)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMAGE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMAGE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMAGE_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMAGE_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMAGE_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMAGE_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMAGE_TILED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMAGE_TILED)) },
    { MP_ROM_QSTR(MP_QSTR_CLIP_CORNER), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_CLIP_CORNER)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_SIDE)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_POST), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_POST)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_PAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_PAD)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFFSET_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFFSET_X)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFFSET_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFFSET_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_SPREAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_SPREAD)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_GAP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_GAP)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_ROUNDED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_ROUNDED)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_ROUNDED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_ROUNDED)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_IMAGE_SRC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_IMAGE_SRC)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_FONT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_FONT)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LETTER_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LETTER_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LINE_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LINE_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_DECOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_OPA_LAYERED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OPA_LAYERED)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FILTER_DSC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_COLOR_FILTER_DSC)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FILTER_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_COLOR_FILTER_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ANIM)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_DURATION), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ANIM_DURATION)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION)) },
    { MP_ROM_QSTR(MP_QSTR_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSLATE_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSLATE_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSLATE_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSLATE_Y)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_SCALE_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_SCALE_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_SCALE_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_SCALE_Y)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_ROTATION), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_ROTATION)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_PIVOT_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_PIVOT_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_PIVOT_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_PIVOT_Y)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_SKEW_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_SKEW_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_SKEW_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_SKEW_Y)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_FLOW), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_FLEX_FLOW)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_MAIN_PLACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_FLEX_MAIN_PLACE)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_CROSS_PLACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_FLEX_CROSS_PLACE)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_TRACK_PLACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_FLEX_TRACK_PLACE)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_GROW), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_FLEX_GROW)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_COLUMN_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_COLUMN_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_ROW_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_ROW_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_ROW_DSC_ARRAY), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_ROW_DSC_ARRAY)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_COLUMN_DSC_ARRAY), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_COLUMN_DSC_ARRAY)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_COLUMN_POS), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_COLUMN_POS)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_COLUMN_SPAN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_COLUMN_SPAN)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_X_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_X_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_ROW_POS), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_ROW_POS)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_ROW_SPAN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_ROW_SPAN)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CELL_Y_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_GRID_CELL_Y_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_PROP_ANY), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PROP_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STYLE_locals_dict, LV_STYLE_locals_dict_table);

STATIC void LV_STYLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STYLE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_STYLE_type_base,
    MP_QSTR_LV_STYLE,
    MP_TYPE_FLAG_NONE,
    print, LV_STYLE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_STYLE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_STYLE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_STYLE_type_base,
};
    

/*
 * lvgl LV_STYLE_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STYLE_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NOT_FOUND), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RES_NOT_FOUND)) },
    { MP_ROM_QSTR(MP_QSTR_FOUND), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RES_FOUND)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STYLE_RES_locals_dict, LV_STYLE_RES_locals_dict_table);

STATIC void LV_STYLE_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STYLE_RES");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_STYLE_RES_type_base,
    MP_QSTR_LV_STYLE_RES,
    MP_TYPE_FLAG_NONE,
    print, LV_STYLE_RES_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_STYLE_RES_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_STYLE_RES_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_STYLE_RES_type_base,
};
    

/*
 * lvgl LV_FS_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OK)) },
    { MP_ROM_QSTR(MP_QSTR_HW_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_HW_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_FS_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FS_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_EX), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_EX)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_LOCKED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_LOCKED)) },
    { MP_ROM_QSTR(MP_QSTR_DENIED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_DENIED)) },
    { MP_ROM_QSTR(MP_QSTR_BUSY), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_BUSY)) },
    { MP_ROM_QSTR(MP_QSTR_TOUT), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_TOUT)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_IMP), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_IMP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_OF_MEM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OUT_OF_MEM)) },
    { MP_ROM_QSTR(MP_QSTR_INV_PARAM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_INV_PARAM)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_RES_locals_dict, LV_FS_RES_locals_dict_table);

STATIC void LV_FS_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_RES");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FS_RES_type_base,
    MP_QSTR_LV_FS_RES,
    MP_TYPE_FLAG_NONE,
    print, LV_FS_RES_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FS_RES_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FS_RES_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FS_RES_type_base,
};
    

/*
 * lvgl LV_FS_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WR), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_WR)) },
    { MP_ROM_QSTR(MP_QSTR_RD), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_RD)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_MODE_locals_dict, LV_FS_MODE_locals_dict_table);

STATIC void LV_FS_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FS_MODE_type_base,
    MP_QSTR_LV_FS_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_FS_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FS_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FS_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FS_MODE_type_base,
};
    

/*
 * lvgl LV_IMAGE_SRC object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMAGE_SRC_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_VARIABLE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_SRC_VARIABLE)) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_SRC_FILE)) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_SRC_SYMBOL)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_SRC_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMAGE_SRC_locals_dict, LV_IMAGE_SRC_locals_dict_table);

STATIC void LV_IMAGE_SRC_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMAGE_SRC");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_IMAGE_SRC_type_base,
    MP_QSTR_LV_IMAGE_SRC,
    MP_TYPE_FLAG_NONE,
    print, LV_IMAGE_SRC_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_IMAGE_SRC_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_IMAGE_SRC_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_IMAGE_SRC_type_base,
};
    

/*
 * lvgl LV_SCROLLBAR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCROLLBAR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_ON)) },
    { MP_ROM_QSTR(MP_QSTR_ACTIVE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_ACTIVE)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_AUTO)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCROLLBAR_MODE_locals_dict, LV_SCROLLBAR_MODE_locals_dict_table);

STATIC void LV_SCROLLBAR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCROLLBAR_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SCROLLBAR_MODE_type_base,
    MP_QSTR_LV_SCROLLBAR_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_SCROLLBAR_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SCROLLBAR_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SCROLLBAR_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SCROLLBAR_MODE_type_base,
};
    

/*
 * lvgl LV_SCROLL_SNAP object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCROLL_SNAP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_START)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_END)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_CENTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCROLL_SNAP_locals_dict, LV_SCROLL_SNAP_locals_dict_table);

STATIC void LV_SCROLL_SNAP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCROLL_SNAP");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SCROLL_SNAP_type_base,
    MP_QSTR_LV_SCROLL_SNAP,
    MP_TYPE_FLAG_NONE,
    print, LV_SCROLL_SNAP_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SCROLL_SNAP_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SCROLL_SNAP_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SCROLL_SNAP_type_base,
};
    

/*
 * lvgl LV_KEY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(MP_ROM_INT(LV_KEY_UP)) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_ESC), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ESC)) },
    { MP_ROM_QSTR(MP_QSTR_DEL), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DEL)) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(MP_ROM_INT(LV_KEY_BACKSPACE)) },
    { MP_ROM_QSTR(MP_QSTR_ENTER), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ENTER)) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_KEY_PREV)) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(MP_ROM_INT(LV_KEY_HOME)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_KEY_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEY_locals_dict, LV_KEY_locals_dict_table);

STATIC void LV_KEY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEY");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_KEY_type_base,
    MP_QSTR_LV_KEY,
    MP_TYPE_FLAG_NONE,
    print, LV_KEY_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_KEY_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_KEY_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_KEY_type_base,
};
    

/*
 * lvgl LV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_CHECKED)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUS_KEY), MP_ROM_PTR(MP_ROM_INT(LV_STATE_FOCUS_KEY)) },
    { MP_ROM_QSTR(MP_QSTR_EDITED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_EDITED)) },
    { MP_ROM_QSTR(MP_QSTR_HOVERED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_HOVERED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_SCROLLED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_4)) },
    { MP_ROM_QSTR(MP_QSTR_ANY), MP_ROM_PTR(MP_ROM_INT(LV_STATE_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STATE_locals_dict, LV_STATE_locals_dict_table);

STATIC void LV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STATE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_STATE_type_base,
    MP_QSTR_LV_STATE,
    MP_TYPE_FLAG_NONE,
    print, LV_STATE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_STATE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_STATE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_STATE_type_base,
};
    

/*
 * lvgl LV_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_INDICATOR), MP_ROM_PTR(MP_ROM_INT(LV_PART_INDICATOR)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_PART_KNOB)) },
    { MP_ROM_QSTR(MP_QSTR_SELECTED), MP_ROM_PTR(MP_ROM_INT(LV_PART_SELECTED)) },
    { MP_ROM_QSTR(MP_QSTR_ITEMS), MP_ROM_PTR(MP_ROM_INT(LV_PART_ITEMS)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_PART_CURSOR)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_FIRST), MP_ROM_PTR(MP_ROM_INT(LV_PART_CUSTOM_FIRST)) },
    { MP_ROM_QSTR(MP_QSTR_ANY), MP_ROM_PTR(MP_ROM_INT(LV_PART_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PART_locals_dict, LV_PART_locals_dict_table);

STATIC void LV_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PART");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_PART_type_base,
    MP_QSTR_LV_PART,
    MP_TYPE_FLAG_NONE,
    print, LV_PART_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_PART_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_PART_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_PART_type_base,
};
    

/*
 * lvgl LV_FONT_FMT_TXT_CMAP object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_CMAP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_TINY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_CMAP_locals_dict, LV_FONT_FMT_TXT_CMAP_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_CMAP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT_CMAP");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FONT_FMT_TXT_CMAP_type_base,
    MP_QSTR_LV_FONT_FMT_TXT_CMAP,
    MP_TYPE_FLAG_NONE,
    print, LV_FONT_FMT_TXT_CMAP_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FONT_FMT_TXT_CMAP_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FONT_FMT_TXT_CMAP_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FONT_FMT_TXT_CMAP_type_base,
};
    

/*
 * lvgl LV_IMAGE_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMAGE_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_STRETCH), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_STRETCH)) },
    { MP_ROM_QSTR(MP_QSTR_TILE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_ALIGN_TILE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMAGE_ALIGN_locals_dict, LV_IMAGE_ALIGN_locals_dict_table);

STATIC void LV_IMAGE_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMAGE_ALIGN");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_IMAGE_ALIGN_type_base,
    MP_QSTR_LV_IMAGE_ALIGN,
    MP_TYPE_FLAG_NONE,
    print, LV_IMAGE_ALIGN_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_IMAGE_ALIGN_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_IMAGE_ALIGN_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_IMAGE_ALIGN_type_base,
};
    

/*
 * lvgl LV_ANIM_IMAGE_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ANIM_IMAGE_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_IMAGE_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ANIM_IMAGE_PART_locals_dict, LV_ANIM_IMAGE_PART_locals_dict_table);

STATIC void LV_ANIM_IMAGE_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ANIM_IMAGE_PART");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_ANIM_IMAGE_PART_type_base,
    MP_QSTR_LV_ANIM_IMAGE_PART,
    MP_TYPE_FLAG_NONE,
    print, LV_ANIM_IMAGE_PART_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_ANIM_IMAGE_PART_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_ANIM_IMAGE_PART_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_ANIM_IMAGE_PART_type_base,
};
    

/*
 * lvgl LV_ARC_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ARC_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_REVERSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ARC_MODE_locals_dict, LV_ARC_MODE_locals_dict_table);

STATIC void LV_ARC_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ARC_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_ARC_MODE_type_base,
    MP_QSTR_LV_ARC_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_ARC_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_ARC_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_ARC_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_ARC_MODE_type_base,
};
    

/*
 * lvgl LV_LABEL_LONG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LABEL_LONG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_DOT), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_DOT)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SCROLL)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SCROLL_CIRCULAR)) },
    { MP_ROM_QSTR(MP_QSTR_CLIP), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_CLIP)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LABEL_LONG_locals_dict, LV_LABEL_LONG_locals_dict_table);

STATIC void LV_LABEL_LONG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LABEL_LONG");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_LABEL_LONG_type_base,
    MP_QSTR_LV_LABEL_LONG,
    MP_TYPE_FLAG_NONE,
    print, LV_LABEL_LONG_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_LABEL_LONG_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_LABEL_LONG_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_LABEL_LONG_type_base,
};
    

/*
 * lvgl LV_BAR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BAR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_RANGE), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_RANGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BAR_MODE_locals_dict, LV_BAR_MODE_locals_dict_table);

STATIC void LV_BAR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BAR_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_BAR_MODE_type_base,
    MP_QSTR_LV_BAR_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_BAR_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_BAR_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_BAR_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_BAR_MODE_type_base,
};
    

/*
 * lvgl LV_BUTTONMATRIX_CTRL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BUTTONMATRIX_CTRL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HIDDEN), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_HIDDEN)) },
    { MP_ROM_QSTR(MP_QSTR_NO_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_NO_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKABLE), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_CHECKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_CHECKED)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_TRIG), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_CLICK_TRIG)) },
    { MP_ROM_QSTR(MP_QSTR_POPOVER), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_POPOVER)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_1), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_CUSTOM_1)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_2), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_CTRL_CUSTOM_2)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BUTTONMATRIX_CTRL_locals_dict, LV_BUTTONMATRIX_CTRL_locals_dict_table);

STATIC void LV_BUTTONMATRIX_CTRL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BUTTONMATRIX_CTRL");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_BUTTONMATRIX_CTRL_type_base,
    MP_QSTR_LV_BUTTONMATRIX_CTRL,
    MP_TYPE_FLAG_NONE,
    print, LV_BUTTONMATRIX_CTRL_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_BUTTONMATRIX_CTRL_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_BUTTONMATRIX_CTRL_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_BUTTONMATRIX_CTRL_type_base,
};
    

/*
 * lvgl LV_CHART_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_BAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_BAR)) },
    { MP_ROM_QSTR(MP_QSTR_SCATTER), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_SCATTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_TYPE_locals_dict, LV_CHART_TYPE_locals_dict_table);

STATIC void LV_CHART_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_CHART_TYPE_type_base,
    MP_QSTR_LV_CHART_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_CHART_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_CHART_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_CHART_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_CHART_TYPE_type_base,
};
    

/*
 * lvgl LV_CHART_UPDATE_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_UPDATE_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SHIFT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_SHIFT)) },
    { MP_ROM_QSTR(MP_QSTR_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_CIRCULAR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_UPDATE_MODE_locals_dict, LV_CHART_UPDATE_MODE_locals_dict_table);

STATIC void LV_CHART_UPDATE_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_UPDATE_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_CHART_UPDATE_MODE_type_base,
    MP_QSTR_LV_CHART_UPDATE_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_CHART_UPDATE_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_CHART_UPDATE_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_CHART_UPDATE_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_CHART_UPDATE_MODE_type_base,
};
    

/*
 * lvgl LV_CHART_AXIS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_AXIS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PRIMARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_PRIMARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SECONDARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SECONDARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_PRIMARY_X), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_PRIMARY_X)) },
    { MP_ROM_QSTR(MP_QSTR_SECONDARY_X), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SECONDARY_X)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_AXIS_locals_dict, LV_CHART_AXIS_locals_dict_table);

STATIC void LV_CHART_AXIS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_AXIS");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_CHART_AXIS_type_base,
    MP_QSTR_LV_CHART_AXIS,
    MP_TYPE_FLAG_NONE,
    print, LV_CHART_AXIS_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_CHART_AXIS_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_CHART_AXIS_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_CHART_AXIS_type_base,
};
    

/*
 * lvgl LV_KEYBOARD_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEYBOARD_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TEXT_LOWER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_LOWER)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_UPPER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_UPPER)) },
    { MP_ROM_QSTR(MP_QSTR_SPECIAL), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_SPECIAL)) },
    { MP_ROM_QSTR(MP_QSTR_NUMBER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_NUMBER)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEYBOARD_MODE_locals_dict, LV_KEYBOARD_MODE_locals_dict_table);

STATIC void LV_KEYBOARD_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEYBOARD_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_KEYBOARD_MODE_type_base,
    MP_QSTR_LV_KEYBOARD_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_KEYBOARD_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_KEYBOARD_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_KEYBOARD_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_KEYBOARD_MODE_type_base,
};
    

/*
 * lvgl LV_MENU_HEADER object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_MENU_HEADER_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TOP_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_TOP_FIXED)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_UNFIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_TOP_UNFIXED)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_BOTTOM_FIXED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_MENU_HEADER_locals_dict, LV_MENU_HEADER_locals_dict_table);

STATIC void LV_MENU_HEADER_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_MENU_HEADER");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_MENU_HEADER_type_base,
    MP_QSTR_LV_MENU_HEADER,
    MP_TYPE_FLAG_NONE,
    print, LV_MENU_HEADER_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_MENU_HEADER_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_MENU_HEADER_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_MENU_HEADER_type_base,
};
    

/*
 * lvgl LV_MENU_ROOT_BACK_BUTTON object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_MENU_ROOT_BACK_BUTTON_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_ROOT_BACK_BUTTON_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_ENABLED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_ROOT_BACK_BUTTON_ENABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_MENU_ROOT_BACK_BUTTON_locals_dict, LV_MENU_ROOT_BACK_BUTTON_locals_dict_table);

STATIC void LV_MENU_ROOT_BACK_BUTTON_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_MENU_ROOT_BACK_BUTTON");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_MENU_ROOT_BACK_BUTTON_type_base,
    MP_QSTR_LV_MENU_ROOT_BACK_BUTTON,
    MP_TYPE_FLAG_NONE,
    print, LV_MENU_ROOT_BACK_BUTTON_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_MENU_ROOT_BACK_BUTTON_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_MENU_ROOT_BACK_BUTTON_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_MENU_ROOT_BACK_BUTTON_type_base,
};
    

/*
 * lvgl LV_ROLLER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ROLLER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_INFINITE), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_INFINITE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ROLLER_MODE_locals_dict, LV_ROLLER_MODE_locals_dict_table);

STATIC void LV_ROLLER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ROLLER_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_ROLLER_MODE_type_base,
    MP_QSTR_LV_ROLLER_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_ROLLER_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_ROLLER_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_ROLLER_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_ROLLER_MODE_type_base,
};
    

/*
 * lvgl LV_SCALE_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCALE_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HORIZONTAL_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_HORIZONTAL_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_HORIZONTAL_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_HORIZONTAL_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_VERTICAL_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_VERTICAL_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_VERTICAL_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_VERTICAL_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_ROUND_INNER), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_ROUND_INNER)) },
    { MP_ROM_QSTR(MP_QSTR_ROUND_OUTER), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MODE_ROUND_OUTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCALE_MODE_locals_dict, LV_SCALE_MODE_locals_dict_table);

STATIC void LV_SCALE_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCALE_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SCALE_MODE_type_base,
    MP_QSTR_LV_SCALE_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_SCALE_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SCALE_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SCALE_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SCALE_MODE_type_base,
};
    

/*
 * lvgl LV_SLIDER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SLIDER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_RANGE), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_RANGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SLIDER_MODE_locals_dict, LV_SLIDER_MODE_locals_dict_table);

STATIC void LV_SLIDER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SLIDER_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SLIDER_MODE_type_base,
    MP_QSTR_LV_SLIDER_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_SLIDER_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SLIDER_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SLIDER_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SLIDER_MODE_type_base,
};
    

/*
 * lvgl LV_SPAN_OVERFLOW object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPAN_OVERFLOW_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CLIP), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_OVERFLOW_CLIP)) },
    { MP_ROM_QSTR(MP_QSTR_ELLIPSIS), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_OVERFLOW_ELLIPSIS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPAN_OVERFLOW_locals_dict, LV_SPAN_OVERFLOW_locals_dict_table);

STATIC void LV_SPAN_OVERFLOW_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPAN_OVERFLOW");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SPAN_OVERFLOW_type_base,
    MP_QSTR_LV_SPAN_OVERFLOW,
    MP_TYPE_FLAG_NONE,
    print, LV_SPAN_OVERFLOW_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SPAN_OVERFLOW_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SPAN_OVERFLOW_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SPAN_OVERFLOW_type_base,
};
    

/*
 * lvgl LV_SPAN_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPAN_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_FIXED)) },
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_BREAK), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_BREAK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPAN_MODE_locals_dict, LV_SPAN_MODE_locals_dict_table);

STATIC void LV_SPAN_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPAN_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SPAN_MODE_type_base,
    MP_QSTR_LV_SPAN_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_SPAN_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SPAN_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SPAN_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SPAN_MODE_type_base,
};
    

/*
 * lvgl LV_PART_TEXTAREA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PART_TEXTAREA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PLACEHOLDER), MP_ROM_PTR(MP_ROM_INT(LV_PART_TEXTAREA_PLACEHOLDER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PART_TEXTAREA_locals_dict, LV_PART_TEXTAREA_locals_dict_table);

STATIC void LV_PART_TEXTAREA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PART_TEXTAREA");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_PART_TEXTAREA_type_base,
    MP_QSTR_LV_PART_TEXTAREA,
    MP_TYPE_FLAG_NONE,
    print, LV_PART_TEXTAREA_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_PART_TEXTAREA_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_PART_TEXTAREA_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_PART_TEXTAREA_type_base,
};
    

/*
 * lvgl LV_TABLE_CELL_CTRL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABLE_CELL_CTRL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MERGE_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_MERGE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_CROP), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_TEXT_CROP)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_1), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_1)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_2), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_2)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_3), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_3)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_4), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABLE_CELL_CTRL_locals_dict, LV_TABLE_CELL_CTRL_locals_dict_table);

STATIC void LV_TABLE_CELL_CTRL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABLE_CELL_CTRL");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_TABLE_CELL_CTRL_type_base,
    MP_QSTR_LV_TABLE_CELL_CTRL,
    MP_TYPE_FLAG_NONE,
    print, LV_TABLE_CELL_CTRL_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_TABLE_CELL_CTRL_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_TABLE_CELL_CTRL_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_TABLE_CELL_CTRL_type_base,
};
    

/*
 * lvgl LV_DRAW_SW_MASK_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_SW_MASK_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_RES_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR_FULL_COVER), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_RES_FULL_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_RES_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_SW_MASK_RES_locals_dict, LV_DRAW_SW_MASK_RES_locals_dict_table);

STATIC void LV_DRAW_SW_MASK_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_SW_MASK_RES");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_SW_MASK_RES_type_base,
    MP_QSTR_LV_DRAW_SW_MASK_RES,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_SW_MASK_RES_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_SW_MASK_RES_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_SW_MASK_RES_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_SW_MASK_RES_type_base,
};
    

/*
 * lvgl LV_DRAW_SW_MASK_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_SW_MASK_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_ANGLE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_TYPE_ANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_TYPE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_FADE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_TYPE_FADE)) },
    { MP_ROM_QSTR(MP_QSTR_MAP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_TYPE_MAP)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_SW_MASK_TYPE_locals_dict, LV_DRAW_SW_MASK_TYPE_locals_dict_table);

STATIC void LV_DRAW_SW_MASK_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_SW_MASK_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_SW_MASK_TYPE_type_base,
    MP_QSTR_LV_DRAW_SW_MASK_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_SW_MASK_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_SW_MASK_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_SW_MASK_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_SW_MASK_TYPE_type_base,
};
    

/*
 * lvgl LV_DRAW_SW_MASK_LINE_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_SW_MASK_LINE_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_LINE_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_LINE_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_LINE_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_SW_MASK_LINE_SIDE_locals_dict, LV_DRAW_SW_MASK_LINE_SIDE_locals_dict_table);

STATIC void LV_DRAW_SW_MASK_LINE_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_SW_MASK_LINE_SIDE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_SW_MASK_LINE_SIDE_type_base,
    MP_QSTR_LV_DRAW_SW_MASK_LINE_SIDE,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_SW_MASK_LINE_SIDE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_SW_MASK_LINE_SIDE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_SW_MASK_LINE_SIDE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_SW_MASK_LINE_SIDE_type_base,
};
    

/*
 * lvgl LV_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_ON)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ANIM_locals_dict, LV_ANIM_locals_dict_table);

STATIC void LV_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ANIM");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_ANIM_type_base,
    MP_QSTR_LV_ANIM,
    MP_TYPE_FLAG_NONE,
    print, LV_ANIM_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_ANIM_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_ANIM_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_ANIM_type_base,
};
    

/*
 * lvgl LV_RB_COLOR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_RB_COLOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RED), MP_ROM_PTR(MP_ROM_INT(LV_RB_COLOR_RED)) },
    { MP_ROM_QSTR(MP_QSTR_BLACK), MP_ROM_PTR(MP_ROM_INT(LV_RB_COLOR_BLACK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_RB_COLOR_locals_dict, LV_RB_COLOR_locals_dict_table);

STATIC void LV_RB_COLOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_RB_COLOR");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_RB_COLOR_type_base,
    MP_QSTR_LV_RB_COLOR,
    MP_TYPE_FLAG_NONE,
    print, LV_RB_COLOR_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_RB_COLOR_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_RB_COLOR_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_RB_COLOR_type_base,
};
    

/*
 * lvgl LV_PALETTE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PALETTE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RED), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_RED)) },
    { MP_ROM_QSTR(MP_QSTR_PINK), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_PINK)) },
    { MP_ROM_QSTR(MP_QSTR_PURPLE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_PURPLE)) },
    { MP_ROM_QSTR(MP_QSTR_DEEP_PURPLE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_DEEP_PURPLE)) },
    { MP_ROM_QSTR(MP_QSTR_INDIGO), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_INDIGO)) },
    { MP_ROM_QSTR(MP_QSTR_BLUE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BLUE)) },
    { MP_ROM_QSTR(MP_QSTR_LIGHT_BLUE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIGHT_BLUE)) },
    { MP_ROM_QSTR(MP_QSTR_CYAN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_CYAN)) },
    { MP_ROM_QSTR(MP_QSTR_TEAL), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_TEAL)) },
    { MP_ROM_QSTR(MP_QSTR_GREEN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_GREEN)) },
    { MP_ROM_QSTR(MP_QSTR_LIGHT_GREEN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIGHT_GREEN)) },
    { MP_ROM_QSTR(MP_QSTR_LIME), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIME)) },
    { MP_ROM_QSTR(MP_QSTR_YELLOW), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_YELLOW)) },
    { MP_ROM_QSTR(MP_QSTR_AMBER), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_AMBER)) },
    { MP_ROM_QSTR(MP_QSTR_ORANGE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_ORANGE)) },
    { MP_ROM_QSTR(MP_QSTR_DEEP_ORANGE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_DEEP_ORANGE)) },
    { MP_ROM_QSTR(MP_QSTR_BROWN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BROWN)) },
    { MP_ROM_QSTR(MP_QSTR_BLUE_GREY), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BLUE_GREY)) },
    { MP_ROM_QSTR(MP_QSTR_GREY), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_GREY)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PALETTE_locals_dict, LV_PALETTE_locals_dict_table);

STATIC void LV_PALETTE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PALETTE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_PALETTE_type_base,
    MP_QSTR_LV_PALETTE,
    MP_TYPE_FLAG_NONE,
    print, LV_PALETTE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_PALETTE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_PALETTE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_PALETTE_type_base,
};
    

/*
 * lvgl LV_IMAGE_FLAGS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMAGE_FLAGS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PREMULTIPLIED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_PREMULTIPLIED)) },
    { MP_ROM_QSTR(MP_QSTR_MODIFIABLE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_MODIFIABLE)) },
    { MP_ROM_QSTR(MP_QSTR_VECTORS), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_VECTORS)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_COMPRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_ALLOCATED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_ALLOCATED)) },
    { MP_ROM_QSTR(MP_QSTR_USER1), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER1)) },
    { MP_ROM_QSTR(MP_QSTR_USER2), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER2)) },
    { MP_ROM_QSTR(MP_QSTR_USER3), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER3)) },
    { MP_ROM_QSTR(MP_QSTR_USER4), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER4)) },
    { MP_ROM_QSTR(MP_QSTR_USER5), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER5)) },
    { MP_ROM_QSTR(MP_QSTR_USER6), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER6)) },
    { MP_ROM_QSTR(MP_QSTR_USER7), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER7)) },
    { MP_ROM_QSTR(MP_QSTR_USER8), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_FLAGS_USER8)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMAGE_FLAGS_locals_dict, LV_IMAGE_FLAGS_locals_dict_table);

STATIC void LV_IMAGE_FLAGS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMAGE_FLAGS");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_IMAGE_FLAGS_type_base,
    MP_QSTR_LV_IMAGE_FLAGS,
    MP_TYPE_FLAG_NONE,
    print, LV_IMAGE_FLAGS_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_IMAGE_FLAGS_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_IMAGE_FLAGS_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_IMAGE_FLAGS_type_base,
};
    

/*
 * lvgl LV_IMAGE_COMPRESS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMAGE_COMPRESS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_COMPRESS_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_RLE), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_COMPRESS_RLE)) },
    { MP_ROM_QSTR(MP_QSTR_LZ4), MP_ROM_PTR(MP_ROM_INT(LV_IMAGE_COMPRESS_LZ4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMAGE_COMPRESS_locals_dict, LV_IMAGE_COMPRESS_locals_dict_table);

STATIC void LV_IMAGE_COMPRESS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMAGE_COMPRESS");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_IMAGE_COMPRESS_type_base,
    MP_QSTR_LV_IMAGE_COMPRESS,
    MP_TYPE_FLAG_NONE,
    print, LV_IMAGE_COMPRESS_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_IMAGE_COMPRESS_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_IMAGE_COMPRESS_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_IMAGE_COMPRESS_type_base,
};
    

/*
 * lvgl LV_THREAD_PRIO object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_THREAD_PRIO_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LOWEST), MP_ROM_PTR(MP_ROM_INT(LV_THREAD_PRIO_LOWEST)) },
    { MP_ROM_QSTR(MP_QSTR_LOW), MP_ROM_PTR(MP_ROM_INT(LV_THREAD_PRIO_LOW)) },
    { MP_ROM_QSTR(MP_QSTR_MID), MP_ROM_PTR(MP_ROM_INT(LV_THREAD_PRIO_MID)) },
    { MP_ROM_QSTR(MP_QSTR_HIGH), MP_ROM_PTR(MP_ROM_INT(LV_THREAD_PRIO_HIGH)) },
    { MP_ROM_QSTR(MP_QSTR_HIGHEST), MP_ROM_PTR(MP_ROM_INT(LV_THREAD_PRIO_HIGHEST)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_THREAD_PRIO_locals_dict, LV_THREAD_PRIO_locals_dict_table);

STATIC void LV_THREAD_PRIO_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_THREAD_PRIO");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_THREAD_PRIO_type_base,
    MP_QSTR_LV_THREAD_PRIO,
    MP_TYPE_FLAG_NONE,
    print, LV_THREAD_PRIO_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_THREAD_PRIO_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_THREAD_PRIO_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_THREAD_PRIO_type_base,
};
    

/*
 * lvgl LV_LAYOUT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LAYOUT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_FLEX)) },
    { MP_ROM_QSTR(MP_QSTR_GRID), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_GRID)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LAYOUT_locals_dict, LV_LAYOUT_locals_dict_table);

STATIC void LV_LAYOUT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LAYOUT");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_LAYOUT_type_base,
    MP_QSTR_LV_LAYOUT,
    MP_TYPE_FLAG_NONE,
    print, LV_LAYOUT_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_LAYOUT_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_LAYOUT_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_LAYOUT_type_base,
};
    

/*
 * lvgl LV_FLEX_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FLEX_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_START)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_END)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_EVENLY), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_EVENLY)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_AROUND), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_AROUND)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_BETWEEN), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_BETWEEN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FLEX_ALIGN_locals_dict, LV_FLEX_ALIGN_locals_dict_table);

STATIC void LV_FLEX_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FLEX_ALIGN");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FLEX_ALIGN_type_base,
    MP_QSTR_LV_FLEX_ALIGN,
    MP_TYPE_FLAG_NONE,
    print, LV_FLEX_ALIGN_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FLEX_ALIGN_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FLEX_ALIGN_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FLEX_ALIGN_type_base,
};
    

/*
 * lvgl LV_FLEX_FLOW object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FLEX_FLOW_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ROW), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_WRAP_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_WRAP_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_WRAP_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_WRAP_REVERSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FLEX_FLOW_locals_dict, LV_FLEX_FLOW_locals_dict_table);

STATIC void LV_FLEX_FLOW_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FLEX_FLOW");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FLEX_FLOW_type_base,
    MP_QSTR_LV_FLEX_FLOW,
    MP_TYPE_FLAG_NONE,
    print, LV_FLEX_FLOW_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FLEX_FLOW_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FLEX_FLOW_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FLEX_FLOW_type_base,
};
    

/*
 * lvgl LV_GRID_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GRID_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_START)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_END)) },
    { MP_ROM_QSTR(MP_QSTR_STRETCH), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_STRETCH)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_EVENLY), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_EVENLY)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_AROUND), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_AROUND)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_BETWEEN), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_BETWEEN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GRID_ALIGN_locals_dict, LV_GRID_ALIGN_locals_dict_table);

STATIC void LV_GRID_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GRID_ALIGN");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_GRID_ALIGN_type_base,
    MP_QSTR_LV_GRID_ALIGN,
    MP_TYPE_FLAG_NONE,
    print, LV_GRID_ALIGN_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_GRID_ALIGN_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_GRID_ALIGN_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_GRID_ALIGN_type_base,
};
    

/*
 * lvgl LV_EVENT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_EVENT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ALL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_ALL)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSING), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSING)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESS_LOST)) },
    { MP_ROM_QSTR(MP_QSTR_SHORT_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SHORT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_THROW_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL_THROW_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL_END)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_GESTURE)) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_KEY)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_DEFOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DEFOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_LEAVE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LEAVE)) },
    { MP_ROM_QSTR(MP_QSTR_HIT_TEST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_HIT_TEST)) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_RESET), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_INDEV_RESET)) },
    { MP_ROM_QSTR(MP_QSTR_COVER_CHECK), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_COVER_CHECK)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_EXT_DRAW_SIZE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFR_EXT_DRAW_SIZE)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN_END)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST_END)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_TASK_ADDED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_TASK_ADDED)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_VALUE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_INSERT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_INSERT)) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFRESH)) },
    { MP_ROM_QSTR(MP_QSTR_READY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_READY)) },
    { MP_ROM_QSTR(MP_QSTR_CANCEL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CANCEL)) },
    { MP_ROM_QSTR(MP_QSTR_CREATE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CREATE)) },
    { MP_ROM_QSTR(MP_QSTR_DELETE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DELETE)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CREATED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_CREATED)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_DELETED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_DELETED)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_UNLOAD_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_UNLOAD_START)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_LOAD_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_LOAD_START)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_LOADED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_LOADED)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_UNLOADED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_UNLOADED)) },
    { MP_ROM_QSTR(MP_QSTR_SIZE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SIZE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_STYLE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_STYLE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LAYOUT_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_GET_SELF_SIZE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_GET_SELF_SIZE)) },
    { MP_ROM_QSTR(MP_QSTR_INVALIDATE_AREA), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_INVALIDATE_AREA)) },
    { MP_ROM_QSTR(MP_QSTR_RESOLUTION_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RESOLUTION_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FORMAT_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_COLOR_FORMAT_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_REQUEST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFR_REQUEST)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFR_START)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_READY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFR_READY)) },
    { MP_ROM_QSTR(MP_QSTR_RENDER_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RENDER_START)) },
    { MP_ROM_QSTR(MP_QSTR_RENDER_READY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RENDER_READY)) },
    { MP_ROM_QSTR(MP_QSTR_FLUSH_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_FLUSH_START)) },
    { MP_ROM_QSTR(MP_QSTR_FLUSH_FINISH), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_FLUSH_FINISH)) },
    { MP_ROM_QSTR(MP_QSTR_VSYNC), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_VSYNC)) },
    { MP_ROM_QSTR(MP_QSTR_PREPROCESS), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PREPROCESS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_EVENT_locals_dict, LV_EVENT_locals_dict_table);

STATIC void LV_EVENT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_EVENT");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_EVENT_type_base,
    MP_QSTR_LV_EVENT,
    MP_TYPE_FLAG_NONE,
    print, LV_EVENT_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_EVENT_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_EVENT_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_EVENT_type_base,
};
    

/*
 * lvgl LV_FS_SEEK object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_SEEK_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SET), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_SET)) },
    { MP_ROM_QSTR(MP_QSTR_CUR), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_CUR)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_SEEK_locals_dict, LV_FS_SEEK_locals_dict_table);

STATIC void LV_FS_SEEK_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_SEEK");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FS_SEEK_type_base,
    MP_QSTR_LV_FS_SEEK,
    MP_TYPE_FLAG_NONE,
    print, LV_FS_SEEK_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FS_SEEK_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FS_SEEK_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FS_SEEK_type_base,
};
    

/*
 * lvgl LV_DRAW_TASK_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_TASK_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FILL), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_FILL)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_BORDER)) },
    { MP_ROM_QSTR(MP_QSTR_BOX_SHADOW), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_BOX_SHADOW)) },
    { MP_ROM_QSTR(MP_QSTR_LABEL), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_LABEL)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_IMAGE)) },
    { MP_ROM_QSTR(MP_QSTR_LAYER), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_LAYER)) },
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_ARC), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_ARC)) },
    { MP_ROM_QSTR(MP_QSTR_TRIANGLE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_TRIANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_MASK_RECTANGLE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_MASK_RECTANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_MASK_BITMAP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_MASK_BITMAP)) },
    { MP_ROM_QSTR(MP_QSTR_VECTOR), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_TYPE_VECTOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_TASK_TYPE_locals_dict, LV_DRAW_TASK_TYPE_locals_dict_table);

STATIC void LV_DRAW_TASK_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_TASK_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_TASK_TYPE_type_base,
    MP_QSTR_LV_DRAW_TASK_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_TASK_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_TASK_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_TASK_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_TASK_TYPE_type_base,
};
    

/*
 * lvgl LV_DRAW_TASK_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_TASK_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WAITING), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_STATE_WAITING)) },
    { MP_ROM_QSTR(MP_QSTR_QUEUED), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_STATE_QUEUED)) },
    { MP_ROM_QSTR(MP_QSTR_IN_PROGRESS), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_STATE_IN_PROGRESS)) },
    { MP_ROM_QSTR(MP_QSTR_READY), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_TASK_STATE_READY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_TASK_STATE_locals_dict, LV_DRAW_TASK_STATE_locals_dict_table);

STATIC void LV_DRAW_TASK_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_TASK_STATE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_TASK_STATE_type_base,
    MP_QSTR_LV_DRAW_TASK_STATE,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_TASK_STATE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_TASK_STATE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_TASK_STATE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_TASK_STATE_type_base,
};
    

/*
 * lvgl LV_DRAW_LETTER object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_LETTER_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BITMAP_FORMAT_INVALID), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LETTER_BITMAP_FORMAT_INVALID)) },
    { MP_ROM_QSTR(MP_QSTR_BITMAP_FORMAT_A8), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LETTER_BITMAP_FORMAT_A8)) },
    { MP_ROM_QSTR(MP_QSTR_BITMAP_FORMAT_IMAGE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LETTER_BITMAP_FORMAT_IMAGE)) },
    { MP_ROM_QSTR(MP_QSTR_VECTOR_FORMAT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LETTER_VECTOR_FORMAT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_LETTER_locals_dict, LV_DRAW_LETTER_locals_dict_table);

STATIC void LV_DRAW_LETTER_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_LETTER");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DRAW_LETTER_type_base,
    MP_QSTR_LV_DRAW_LETTER,
    MP_TYPE_FLAG_NONE,
    print, LV_DRAW_LETTER_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DRAW_LETTER_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DRAW_LETTER_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DRAW_LETTER_type_base,
};
    

/*
 * lvgl LV_DISPLAY_ROTATION object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DISPLAY_ROTATION_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR__0), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_ROTATION_0)) },
    { MP_ROM_QSTR(MP_QSTR__90), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_ROTATION_90)) },
    { MP_ROM_QSTR(MP_QSTR__180), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_ROTATION_180)) },
    { MP_ROM_QSTR(MP_QSTR__270), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_ROTATION_270)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DISPLAY_ROTATION_locals_dict, LV_DISPLAY_ROTATION_locals_dict_table);

STATIC void LV_DISPLAY_ROTATION_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DISPLAY_ROTATION");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DISPLAY_ROTATION_type_base,
    MP_QSTR_LV_DISPLAY_ROTATION,
    MP_TYPE_FLAG_NONE,
    print, LV_DISPLAY_ROTATION_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DISPLAY_ROTATION_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DISPLAY_ROTATION_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DISPLAY_ROTATION_type_base,
};
    

/*
 * lvgl LV_DISPLAY_RENDER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DISPLAY_RENDER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PARTIAL), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_RENDER_MODE_PARTIAL)) },
    { MP_ROM_QSTR(MP_QSTR_DIRECT), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_RENDER_MODE_DIRECT)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_DISPLAY_RENDER_MODE_FULL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DISPLAY_RENDER_MODE_locals_dict, LV_DISPLAY_RENDER_MODE_locals_dict_table);

STATIC void LV_DISPLAY_RENDER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DISPLAY_RENDER_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_DISPLAY_RENDER_MODE_type_base,
    MP_QSTR_LV_DISPLAY_RENDER_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_DISPLAY_RENDER_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_DISPLAY_RENDER_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_DISPLAY_RENDER_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_DISPLAY_RENDER_MODE_type_base,
};
    

/*
 * lvgl LV_SCR_LOAD_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCR_LOAD_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_IN), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_IN)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_ON)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_OUT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_OUT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCR_LOAD_ANIM_locals_dict, LV_SCR_LOAD_ANIM_locals_dict_table);

STATIC void LV_SCR_LOAD_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCR_LOAD_ANIM");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SCR_LOAD_ANIM_type_base,
    MP_QSTR_LV_SCR_LOAD_ANIM,
    MP_TYPE_FLAG_NONE,
    print, LV_SCR_LOAD_ANIM_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SCR_LOAD_ANIM_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SCR_LOAD_ANIM_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SCR_LOAD_ANIM_type_base,
};
    

/*
 * lvgl LV_OBJ_TREE_WALK object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_TREE_WALK_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_SKIP_CHILDREN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_SKIP_CHILDREN)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_TREE_WALK_locals_dict, LV_OBJ_TREE_WALK_locals_dict_table);

STATIC void LV_OBJ_TREE_WALK_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_TREE_WALK");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OBJ_TREE_WALK_type_base,
    MP_QSTR_LV_OBJ_TREE_WALK,
    MP_TYPE_FLAG_NONE,
    print, LV_OBJ_TREE_WALK_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OBJ_TREE_WALK_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OBJ_TREE_WALK_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OBJ_TREE_WALK_type_base,
};
    

/*
 * lvgl LV_LAYER_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LAYER_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_SIMPLE), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_SIMPLE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_TRANSFORM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LAYER_TYPE_locals_dict, LV_LAYER_TYPE_locals_dict_table);

STATIC void LV_LAYER_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LAYER_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_LAYER_TYPE_type_base,
    MP_QSTR_LV_LAYER_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_LAYER_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_LAYER_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_LAYER_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_LAYER_TYPE_type_base,
};
    

/*
 * lvgl LV_OBJ_CLASS_EDITABLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_CLASS_EDITABLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_INHERIT)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_TRUE)) },
    { MP_ROM_QSTR(MP_QSTR_FALSE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_FALSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_CLASS_EDITABLE_locals_dict, LV_OBJ_CLASS_EDITABLE_locals_dict_table);

STATIC void LV_OBJ_CLASS_EDITABLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_CLASS_EDITABLE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OBJ_CLASS_EDITABLE_type_base,
    MP_QSTR_LV_OBJ_CLASS_EDITABLE,
    MP_TYPE_FLAG_NONE,
    print, LV_OBJ_CLASS_EDITABLE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OBJ_CLASS_EDITABLE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OBJ_CLASS_EDITABLE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OBJ_CLASS_EDITABLE_type_base,
};
    

/*
 * lvgl LV_OBJ_CLASS_GROUP_DEF object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_CLASS_GROUP_DEF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_INHERIT)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_TRUE)) },
    { MP_ROM_QSTR(MP_QSTR_FALSE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_FALSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_CLASS_GROUP_DEF_locals_dict, LV_OBJ_CLASS_GROUP_DEF_locals_dict_table);

STATIC void LV_OBJ_CLASS_GROUP_DEF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_CLASS_GROUP_DEF");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OBJ_CLASS_GROUP_DEF_type_base,
    MP_QSTR_LV_OBJ_CLASS_GROUP_DEF,
    MP_TYPE_FLAG_NONE,
    print, LV_OBJ_CLASS_GROUP_DEF_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OBJ_CLASS_GROUP_DEF_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OBJ_CLASS_GROUP_DEF_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OBJ_CLASS_GROUP_DEF_type_base,
};
    

/*
 * lvgl LV_OBJ_CLASS_THEME_INHERITABLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_CLASS_THEME_INHERITABLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FALSE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_THEME_INHERITABLE_FALSE)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_THEME_INHERITABLE_TRUE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_CLASS_THEME_INHERITABLE_locals_dict, LV_OBJ_CLASS_THEME_INHERITABLE_locals_dict_table);

STATIC void LV_OBJ_CLASS_THEME_INHERITABLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_CLASS_THEME_INHERITABLE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OBJ_CLASS_THEME_INHERITABLE_type_base,
    MP_QSTR_LV_OBJ_CLASS_THEME_INHERITABLE,
    MP_TYPE_FLAG_NONE,
    print, LV_OBJ_CLASS_THEME_INHERITABLE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OBJ_CLASS_THEME_INHERITABLE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OBJ_CLASS_THEME_INHERITABLE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OBJ_CLASS_THEME_INHERITABLE_type_base,
};
    

/*
 * lvgl LV_GROUP_REFOCUS_POLICY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GROUP_REFOCUS_POLICY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_PREV)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GROUP_REFOCUS_POLICY_locals_dict, LV_GROUP_REFOCUS_POLICY_locals_dict_table);

STATIC void LV_GROUP_REFOCUS_POLICY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GROUP_REFOCUS_POLICY");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_GROUP_REFOCUS_POLICY_type_base,
    MP_QSTR_LV_GROUP_REFOCUS_POLICY,
    MP_TYPE_FLAG_NONE,
    print, LV_GROUP_REFOCUS_POLICY_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_GROUP_REFOCUS_POLICY_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_GROUP_REFOCUS_POLICY_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_GROUP_REFOCUS_POLICY_type_base,
};
    

/*
 * lvgl LV_INDEV_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_POINTER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_POINTER)) },
    { MP_ROM_QSTR(MP_QSTR_KEYPAD), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_KEYPAD)) },
    { MP_ROM_QSTR(MP_QSTR_BUTTON), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_BUTTON)) },
    { MP_ROM_QSTR(MP_QSTR_ENCODER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_ENCODER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_TYPE_locals_dict, LV_INDEV_TYPE_locals_dict_table);

STATIC void LV_INDEV_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_INDEV_TYPE_type_base,
    MP_QSTR_LV_INDEV_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_INDEV_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_INDEV_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_INDEV_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_INDEV_TYPE_type_base,
};
    

/*
 * lvgl LV_INDEV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_PRESSED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_STATE_locals_dict, LV_INDEV_STATE_locals_dict_table);

STATIC void LV_INDEV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_STATE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_INDEV_STATE_type_base,
    MP_QSTR_LV_INDEV_STATE,
    MP_TYPE_FLAG_NONE,
    print, LV_INDEV_STATE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_INDEV_STATE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_INDEV_STATE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_INDEV_STATE_type_base,
};
    

/*
 * lvgl LV_INDEV_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_MODE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_TIMER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_MODE_TIMER)) },
    { MP_ROM_QSTR(MP_QSTR_EVENT), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_MODE_EVENT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_MODE_locals_dict, LV_INDEV_MODE_locals_dict_table);

STATIC void LV_INDEV_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_MODE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_INDEV_MODE_type_base,
    MP_QSTR_LV_INDEV_MODE,
    MP_TYPE_FLAG_NONE,
    print, LV_INDEV_MODE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_INDEV_MODE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_INDEV_MODE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_INDEV_MODE_type_base,
};
    

/*
 * lvgl LV_COVER_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_COVER_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_COVER), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_NOT_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_MASKED), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_MASKED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_COVER_RES_locals_dict, LV_COVER_RES_locals_dict_table);

STATIC void LV_COVER_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_COVER_RES");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_COVER_RES_type_base,
    MP_QSTR_LV_COVER_RES,
    MP_TYPE_FLAG_NONE,
    print, LV_COVER_RES_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_COVER_RES_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_COVER_RES_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_COVER_RES_type_base,
};
    

/*
 * lvgl LV_OBJ_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HIDDEN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_HIDDEN)) },
    { MP_ROM_QSTR(MP_QSTR_CLICKABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CLICKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_FOCUSABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CLICK_FOCUSABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CHECKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLLABLE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ELASTIC), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ELASTIC)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_MOMENTUM), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_MOMENTUM)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ONE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ONE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN_HOR), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN_VER), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN_VER)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ON_FOCUS), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ON_FOCUS)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_WITH_ARROW), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_WITH_ARROW)) },
    { MP_ROM_QSTR(MP_QSTR_SNAPPABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SNAPPABLE)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOCK), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_PRESS_LOCK)) },
    { MP_ROM_QSTR(MP_QSTR_EVENT_BUBBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_EVENT_BUBBLE)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE_BUBBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_GESTURE_BUBBLE)) },
    { MP_ROM_QSTR(MP_QSTR_ADV_HITTEST), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_ADV_HITTEST)) },
    { MP_ROM_QSTR(MP_QSTR_IGNORE_LAYOUT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_IGNORE_LAYOUT)) },
    { MP_ROM_QSTR(MP_QSTR_FLOATING), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_FLOATING)) },
    { MP_ROM_QSTR(MP_QSTR_SEND_DRAW_TASK_EVENTS), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS)) },
    { MP_ROM_QSTR(MP_QSTR_OVERFLOW_VISIBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_OVERFLOW_VISIBLE)) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_IN_NEW_TRACK), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_FLEX_IN_NEW_TRACK)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_LAYOUT_1)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_LAYOUT_2)) },
    { MP_ROM_QSTR(MP_QSTR_WIDGET_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_WIDGET_1)) },
    { MP_ROM_QSTR(MP_QSTR_WIDGET_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_WIDGET_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_FLAG_locals_dict, LV_OBJ_FLAG_locals_dict_table);

STATIC void LV_OBJ_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_FLAG");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_OBJ_FLAG_type_base,
    MP_QSTR_LV_OBJ_FLAG,
    MP_TYPE_FLAG_NONE,
    print, LV_OBJ_FLAG_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_OBJ_FLAG_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_OBJ_FLAG_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_OBJ_FLAG_type_base,
};
    

/*
 * lvgl LV_FONT_FMT_TXT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PLAIN), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_PLAIN)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED_NO_PREFILTER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_locals_dict, LV_FONT_FMT_TXT_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_FONT_FMT_TXT_type_base,
    MP_QSTR_LV_FONT_FMT_TXT,
    MP_TYPE_FLAG_NONE,
    print, LV_FONT_FMT_TXT_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_FONT_FMT_TXT_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_FONT_FMT_TXT_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_FONT_FMT_TXT_type_base,
};
    

/*
 * lvgl LV_IMAGEBUTTON_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMAGEBUTTON_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_CHECKED_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_CHECKED_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_IMAGEBUTTON_STATE_CHECKED_DISABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMAGEBUTTON_STATE_locals_dict, LV_IMAGEBUTTON_STATE_locals_dict_table);

STATIC void LV_IMAGEBUTTON_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMAGEBUTTON_STATE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_IMAGEBUTTON_STATE_type_base,
    MP_QSTR_LV_IMAGEBUTTON_STATE,
    MP_TYPE_FLAG_NONE,
    print, LV_IMAGEBUTTON_STATE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_IMAGEBUTTON_STATE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_IMAGEBUTTON_STATE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_IMAGEBUTTON_STATE_type_base,
};
    

/*
 * lvgl LV_SUBJECT_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SUBJECT_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INVALID), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_INVALID)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_INT), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_INT)) },
    { MP_ROM_QSTR(MP_QSTR_POINTER), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_POINTER)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_GROUP), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_GROUP)) },
    { MP_ROM_QSTR(MP_QSTR_STRING), MP_ROM_PTR(MP_ROM_INT(LV_SUBJECT_TYPE_STRING)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SUBJECT_TYPE_locals_dict, LV_SUBJECT_TYPE_locals_dict_table);

STATIC void LV_SUBJECT_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SUBJECT_TYPE");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SUBJECT_TYPE_type_base,
    MP_QSTR_LV_SUBJECT_TYPE,
    MP_TYPE_FLAG_NONE,
    print, LV_SUBJECT_TYPE_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SUBJECT_TYPE_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SUBJECT_TYPE_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SUBJECT_TYPE_type_base,
};
    

/*
 * lvgl LV_SYMBOL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SYMBOL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BULLET), MP_ROM_PTR(&mp_LV_SYMBOL_BULLET) },
    { MP_ROM_QSTR(MP_QSTR_AUDIO), MP_ROM_PTR(&mp_LV_SYMBOL_AUDIO) },
    { MP_ROM_QSTR(MP_QSTR_VIDEO), MP_ROM_PTR(&mp_LV_SYMBOL_VIDEO) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(&mp_LV_SYMBOL_LIST) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(&mp_LV_SYMBOL_OK) },
    { MP_ROM_QSTR(MP_QSTR_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_POWER), MP_ROM_PTR(&mp_LV_SYMBOL_POWER) },
    { MP_ROM_QSTR(MP_QSTR_SETTINGS), MP_ROM_PTR(&mp_LV_SYMBOL_SETTINGS) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(&mp_LV_SYMBOL_HOME) },
    { MP_ROM_QSTR(MP_QSTR_DOWNLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_DOWNLOAD) },
    { MP_ROM_QSTR(MP_QSTR_DRIVE), MP_ROM_PTR(&mp_LV_SYMBOL_DRIVE) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(&mp_LV_SYMBOL_REFRESH) },
    { MP_ROM_QSTR(MP_QSTR_MUTE), MP_ROM_PTR(&mp_LV_SYMBOL_MUTE) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MID), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MID) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MAX), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MAX) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE), MP_ROM_PTR(&mp_LV_SYMBOL_IMAGE) },
    { MP_ROM_QSTR(MP_QSTR_TINT), MP_ROM_PTR(&mp_LV_SYMBOL_TINT) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(&mp_LV_SYMBOL_PREV) },
    { MP_ROM_QSTR(MP_QSTR_PLAY), MP_ROM_PTR(&mp_LV_SYMBOL_PLAY) },
    { MP_ROM_QSTR(MP_QSTR_PAUSE), MP_ROM_PTR(&mp_LV_SYMBOL_PAUSE) },
    { MP_ROM_QSTR(MP_QSTR_STOP), MP_ROM_PTR(&mp_LV_SYMBOL_STOP) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(&mp_LV_SYMBOL_NEXT) },
    { MP_ROM_QSTR(MP_QSTR_EJECT), MP_ROM_PTR(&mp_LV_SYMBOL_EJECT) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(&mp_LV_SYMBOL_LEFT) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(&mp_LV_SYMBOL_RIGHT) },
    { MP_ROM_QSTR(MP_QSTR_PLUS), MP_ROM_PTR(&mp_LV_SYMBOL_PLUS) },
    { MP_ROM_QSTR(MP_QSTR_MINUS), MP_ROM_PTR(&mp_LV_SYMBOL_MINUS) },
    { MP_ROM_QSTR(MP_QSTR_EYE_OPEN), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_OPEN) },
    { MP_ROM_QSTR(MP_QSTR_EYE_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_WARNING), MP_ROM_PTR(&mp_LV_SYMBOL_WARNING) },
    { MP_ROM_QSTR(MP_QSTR_SHUFFLE), MP_ROM_PTR(&mp_LV_SYMBOL_SHUFFLE) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(&mp_LV_SYMBOL_UP) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(&mp_LV_SYMBOL_DOWN) },
    { MP_ROM_QSTR(MP_QSTR_LOOP), MP_ROM_PTR(&mp_LV_SYMBOL_LOOP) },
    { MP_ROM_QSTR(MP_QSTR_DIRECTORY), MP_ROM_PTR(&mp_LV_SYMBOL_DIRECTORY) },
    { MP_ROM_QSTR(MP_QSTR_UPLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_UPLOAD) },
    { MP_ROM_QSTR(MP_QSTR_CALL), MP_ROM_PTR(&mp_LV_SYMBOL_CALL) },
    { MP_ROM_QSTR(MP_QSTR_CUT), MP_ROM_PTR(&mp_LV_SYMBOL_CUT) },
    { MP_ROM_QSTR(MP_QSTR_COPY), MP_ROM_PTR(&mp_LV_SYMBOL_COPY) },
    { MP_ROM_QSTR(MP_QSTR_SAVE), MP_ROM_PTR(&mp_LV_SYMBOL_SAVE) },
    { MP_ROM_QSTR(MP_QSTR_BARS), MP_ROM_PTR(&mp_LV_SYMBOL_BARS) },
    { MP_ROM_QSTR(MP_QSTR_ENVELOPE), MP_ROM_PTR(&mp_LV_SYMBOL_ENVELOPE) },
    { MP_ROM_QSTR(MP_QSTR_CHARGE), MP_ROM_PTR(&mp_LV_SYMBOL_CHARGE) },
    { MP_ROM_QSTR(MP_QSTR_PASTE), MP_ROM_PTR(&mp_LV_SYMBOL_PASTE) },
    { MP_ROM_QSTR(MP_QSTR_BELL), MP_ROM_PTR(&mp_LV_SYMBOL_BELL) },
    { MP_ROM_QSTR(MP_QSTR_KEYBOARD), MP_ROM_PTR(&mp_LV_SYMBOL_KEYBOARD) },
    { MP_ROM_QSTR(MP_QSTR_GPS), MP_ROM_PTR(&mp_LV_SYMBOL_GPS) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(&mp_LV_SYMBOL_FILE) },
    { MP_ROM_QSTR(MP_QSTR_WIFI), MP_ROM_PTR(&mp_LV_SYMBOL_WIFI) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_FULL), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_FULL) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_3), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_3) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_2), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_2) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_1), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_1) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_EMPTY), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_EMPTY) },
    { MP_ROM_QSTR(MP_QSTR_USB), MP_ROM_PTR(&mp_LV_SYMBOL_USB) },
    { MP_ROM_QSTR(MP_QSTR_BLUETOOTH), MP_ROM_PTR(&mp_LV_SYMBOL_BLUETOOTH) },
    { MP_ROM_QSTR(MP_QSTR_TRASH), MP_ROM_PTR(&mp_LV_SYMBOL_TRASH) },
    { MP_ROM_QSTR(MP_QSTR_EDIT), MP_ROM_PTR(&mp_LV_SYMBOL_EDIT) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(&mp_LV_SYMBOL_BACKSPACE) },
    { MP_ROM_QSTR(MP_QSTR_SD_CARD), MP_ROM_PTR(&mp_LV_SYMBOL_SD_CARD) },
    { MP_ROM_QSTR(MP_QSTR_NEW_LINE), MP_ROM_PTR(&mp_LV_SYMBOL_NEW_LINE) },
    { MP_ROM_QSTR(MP_QSTR_DUMMY), MP_ROM_PTR(&mp_LV_SYMBOL_DUMMY) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SYMBOL_locals_dict, LV_SYMBOL_locals_dict_table);

STATIC void LV_SYMBOL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SYMBOL");
}



STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_LV_SYMBOL_type_base,
    MP_QSTR_LV_SYMBOL,
    MP_TYPE_FLAG_NONE,
    print, LV_SYMBOL_print,
    
    
    attr, call_parent_methods,
    
    
    locals_dict, &LV_SYMBOL_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_LV_SYMBOL_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = NULL,
#endif
    .mp_obj_type = &mp_lv_LV_SYMBOL_type_base,
};
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_center(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_center(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_center_mpobj, 1, mp_lv_obj_center, lv_obj_center);
    

/*
 * lvgl extension definition for:
 * inline static lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_style_get_selector_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_state_t _res = ((lv_state_t (*)(lv_style_selector_t))lv_func_ptr)(selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_style_get_selector_state_mpobj, 1, mp_lv_obj_style_get_selector_state, lv_obj_style_get_selector_state);
    

/*
 * lvgl extension definition for:
 * inline static lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_style_get_selector_part(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_part_t _res = ((lv_part_t (*)(lv_style_selector_t))lv_func_ptr)(selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_style_get_selector_part_mpobj, 1, mp_lv_obj_style_get_selector_part, lv_obj_style_get_selector_part);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_obj_get_style_width(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_min_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_min_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_max_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_max_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_height_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_min_height_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_min_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_max_height_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_max_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_length_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_length);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_y);
    

/*
 * lvgl extension definition for:
 * inline static lv_align_t lv_obj_get_style_align(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_align_t _res = ((lv_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_align_mpobj, 2, mp_lv_obj_get_style_align, lv_obj_get_style_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_height_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_translate_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_translate_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_translate_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_translate_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_scale_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_scale_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_scale_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_scale_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_scale_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_scale_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_rotation_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_rotation);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_pivot_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_pivot_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_pivot_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_pivot_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_skew_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_skew_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_skew_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_skew_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_skew_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_skew_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_top_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_top);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_bottom_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_bottom);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_left_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_left);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_right_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_right);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_row_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_row);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_column_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_column);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_top_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_margin_top);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_bottom_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_margin_bottom);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_left_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_margin_left);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_right_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_margin_right);
    

/*
 * Struct lv_color_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_t_type();

STATIC inline void* mp_write_ptr_lv_color_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_t_type()));
    return (lv_color_t*)self->data;
}

#define mp_write_lv_color_t(struct_obj) *((lv_color_t*)mp_write_ptr_lv_color_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_color_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_color_t_type(), field);
}

#define mp_read_lv_color_t(field) mp_read_ptr_lv_color_t(copy_buffer(&field, sizeof(lv_color_t)))
#define mp_read_byref_lv_color_t(field) mp_read_ptr_lv_color_t(&field)

STATIC void mp_lv_color_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_color_t *data = (lv_color_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blue: dest[0] = mp_obj_new_int_from_uint(data->blue); break; // converting from uint8_t;
            case MP_QSTR_green: dest[0] = mp_obj_new_int_from_uint(data->green); break; // converting from uint8_t;
            case MP_QSTR_red: dest[0] = mp_obj_new_int_from_uint(data->red); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blue: data->blue = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_green: data->green = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_red: data->red = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_t");
}

STATIC const mp_obj_dict_t mp_lv_color_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_color_t_type,
    MP_QSTR_lv_color_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_color_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_color_t_attr,
    locals_dict, &mp_lv_color_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_color_t_type()
{
    return &mp_lv_color_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_obj_get_style_bg_color(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_color_filtered);
    

/*
 * lvgl extension definition for:
 * inline static lv_opa_t lv_obj_get_style_bg_opa(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_opa_t _res = ((lv_opa_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_grad_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_grad_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_grad_color_filtered);
    

/*
 * lvgl extension definition for:
 * inline static lv_grad_dir_t lv_obj_get_style_bg_grad_dir(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_grad_dir_t _res = ((lv_grad_dir_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_dir_mpobj, 2, mp_lv_obj_get_style_bg_grad_dir, lv_obj_get_style_bg_grad_dir);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_main_stop_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_bg_main_stop);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_stop_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_bg_grad_stop);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_main_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_main_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_main_opa);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_grad_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_grad_opa);
    

/*
 * Struct lv_gradient_stop_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_gradient_stop_t_type();

STATIC inline void* mp_write_ptr_lv_gradient_stop_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_gradient_stop_t_type()));
    return (lv_gradient_stop_t*)self->data;
}

#define mp_write_lv_gradient_stop_t(struct_obj) *((lv_gradient_stop_t*)mp_write_ptr_lv_gradient_stop_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_gradient_stop_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_gradient_stop_t_type(), field);
}

#define mp_read_lv_gradient_stop_t(field) mp_read_ptr_lv_gradient_stop_t(copy_buffer(&field, sizeof(lv_gradient_stop_t)))
#define mp_read_byref_lv_gradient_stop_t(field) mp_read_ptr_lv_gradient_stop_t(&field)

STATIC void mp_lv_gradient_stop_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_gradient_stop_t *data = (lv_gradient_stop_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_frac: dest[0] = mp_obj_new_int_from_uint(data->frac); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_frac: data->frac = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_gradient_stop_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_gradient_stop_t");
}

STATIC const mp_obj_dict_t mp_lv_gradient_stop_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_gradient_stop_t_type,
    MP_QSTR_lv_gradient_stop_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_gradient_stop_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_gradient_stop_t_attr,
    locals_dict, &mp_lv_gradient_stop_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_gradient_stop_t_type()
{
    return &mp_lv_gradient_stop_t_type;
}
    

/*
 * Array convertors for lv_gradient_stop_t [2]
 */

GENMPY_UNUSED STATIC lv_gradient_stop_t *mp_arr_to_lv_gradient_stop_t___2__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    lv_gradient_stop_t *lv_arr = (lv_gradient_stop_t*)m_malloc(len * sizeof(lv_gradient_stop_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_gradient_stop_t(item);
    }
    return (lv_gradient_stop_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_gradient_stop_t___2__(lv_gradient_stop_t *arr)
{
    mp_obj_t obj_arr[2];
    for (size_t i=0; i<2; i++){
        obj_arr[i] = mp_read_lv_gradient_stop_t(arr[i]);
    }
    return mp_obj_new_list(2, obj_arr); // TODO: return custom iterable object!
}


/*
 * Struct lv_grad_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_grad_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_grad_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_grad_dsc_t_type()));
    return (lv_grad_dsc_t*)self->data;
}

#define mp_write_lv_grad_dsc_t(struct_obj) *((lv_grad_dsc_t*)mp_write_ptr_lv_grad_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_grad_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_grad_dsc_t_type(), field);
}

#define mp_read_lv_grad_dsc_t(field) mp_read_ptr_lv_grad_dsc_t(copy_buffer(&field, sizeof(lv_grad_dsc_t)))
#define mp_read_byref_lv_grad_dsc_t(field) mp_read_ptr_lv_grad_dsc_t(&field)

STATIC void mp_lv_grad_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_grad_dsc_t *data = (lv_grad_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_stops: dest[0] = mp_arr_from_lv_gradient_stop_t___2__(data->stops); break; // converting from lv_gradient_stop_t [2];
            case MP_QSTR_stops_count: dest[0] = mp_obj_new_int_from_uint(data->stops_count); break; // converting from uint8_t;
            case MP_QSTR_dir: dest[0] = mp_obj_new_int_from_uint(data->dir); break; // converting from lv_grad_dir_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_stops: memcpy((void*)&data->stops, mp_arr_to_lv_gradient_stop_t___2__(dest[1]), sizeof(lv_gradient_stop_t)*2); break; // converting to lv_gradient_stop_t [2];
                case MP_QSTR_stops_count: data->stops_count = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_dir: data->dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_grad_dir_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_grad_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_grad_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_grad_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_grad_dsc_t_type,
    MP_QSTR_lv_grad_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_grad_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_grad_dsc_t_attr,
    locals_dict, &mp_lv_grad_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_grad_dsc_t_type()
{
    return &mp_lv_grad_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_grad_dsc_t *lv_obj_get_style_bg_grad(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_grad_dsc_t * _res = ((const lv_grad_dsc_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_grad_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_mpobj, 2, mp_lv_obj_get_style_bg_grad, lv_obj_get_style_bg_grad);
    

/*
 * lvgl extension definition for:
 * inline static const void *lv_obj_get_style_bg_image_src(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_image_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_src_mpobj, 2, mp_lv_obj_get_style_bg_image_src, lv_obj_get_style_bg_image_src);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_image_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_recolor_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_image_recolor);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_image_recolor_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_recolor_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_image_recolor_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_recolor_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_image_recolor_opa);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_obj_get_style_bg_image_tiled(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_bg_image_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_image_tiled_mpobj, 2, mp_lv_obj_get_style_bg_image_tiled, lv_obj_get_style_bg_image_tiled);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_border_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_border_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_border_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_border_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_border_width);
    

/*
 * lvgl extension definition for:
 * inline static lv_border_side_t lv_obj_get_style_border_side(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_border_side_t _res = ((lv_border_side_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_side_mpobj, 2, mp_lv_obj_get_style_border_side, lv_obj_get_style_border_side);
    
/* Reusing lv_obj_get_style_bg_image_tiled for lv_obj_get_style_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_post_mpobj, 2, mp_lv_obj_get_style_bg_image_tiled, lv_obj_get_style_border_post);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_outline_width);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_outline_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_outline_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_outline_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_outline_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_pad_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_outline_pad);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_offset_x_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_offset_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_offset_y_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_offset_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_spread_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_spread);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_shadow_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_shadow_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_shadow_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_shadow_opa);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_image_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_recolor_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_image_recolor);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_image_recolor_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_recolor_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_image_recolor_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_recolor_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_image_recolor_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_dash_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_gap_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_dash_gap);
    
/* Reusing lv_obj_get_style_bg_image_tiled for lv_obj_get_style_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_rounded_mpobj, 2, mp_lv_obj_get_style_bg_image_tiled, lv_obj_get_style_line_rounded);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_line_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_line_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_line_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_line_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_width_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_arc_width);
    
/* Reusing lv_obj_get_style_bg_image_tiled for lv_obj_get_style_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_rounded_mpobj, 2, mp_lv_obj_get_style_bg_image_tiled, lv_obj_get_style_arc_rounded);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_arc_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_arc_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_arc_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_arc_opa);
    
/* Reusing lv_obj_get_style_bg_image_src for lv_obj_get_style_arc_image_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_image_src_mpobj, 2, mp_lv_obj_get_style_bg_image_src, lv_obj_get_style_arc_image_src);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_color_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_color_filtered_mpobj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_text_opa);
    
#define funcptr_get_glyph_dsc NULL


/*
 * Struct lv_cache_entry_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_cache_entry_t_type();

STATIC inline void* mp_write_ptr_lv_cache_entry_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_cache_entry_t_type()));
    return (lv_cache_entry_t*)self->data;
}

#define mp_write_lv_cache_entry_t(struct_obj) *((lv_cache_entry_t*)mp_write_ptr_lv_cache_entry_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_cache_entry_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_cache_entry_t_type(), field);
}

#define mp_read_lv_cache_entry_t(field) mp_read_ptr_lv_cache_entry_t(copy_buffer(&field, sizeof(lv_cache_entry_t)))
#define mp_read_byref_lv_cache_entry_t(field) mp_read_ptr_lv_cache_entry_t(&field)

STATIC void mp_lv_cache_entry_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_cache_entry_t *data = (lv_cache_entry_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            ;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                ;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_cache_entry_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_cache_entry_t");
}

STATIC const mp_obj_dict_t mp_lv_cache_entry_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_cache_entry_t_type,
    MP_QSTR_lv_cache_entry_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_cache_entry_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_cache_entry_t_attr,
    locals_dict, &mp_lv_cache_entry_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_cache_entry_t_type()
{
    return &mp_lv_cache_entry_t_type;
}
    

/*
 * Struct lv_font_glyph_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_font_glyph_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_glyph_dsc_t_type()));
    return (lv_font_glyph_dsc_t*)self->data;
}

#define mp_write_lv_font_glyph_dsc_t(struct_obj) *((lv_font_glyph_dsc_t*)mp_write_ptr_lv_font_glyph_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_font_glyph_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_font_glyph_dsc_t_type(), field);
}

#define mp_read_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(copy_buffer(&field, sizeof(lv_font_glyph_dsc_t)))
#define mp_read_byref_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(&field)

STATIC void mp_lv_font_glyph_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_font_glyph_dsc_t *data = (lv_font_glyph_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_resolved_font: dest[0] = ptr_to_mp((void*)data->resolved_font); break; // converting from lv_font_t *;
            case MP_QSTR_adv_w: dest[0] = mp_obj_new_int_from_uint(data->adv_w); break; // converting from uint16_t;
            case MP_QSTR_box_w: dest[0] = mp_obj_new_int_from_uint(data->box_w); break; // converting from uint16_t;
            case MP_QSTR_box_h: dest[0] = mp_obj_new_int_from_uint(data->box_h); break; // converting from uint16_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from int16_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from int16_t;
            case MP_QSTR_bpp: dest[0] = mp_obj_new_int_from_uint(data->bpp); break; // converting from uint8_t;
            case MP_QSTR_is_placeholder: dest[0] = mp_obj_new_int_from_uint(data->is_placeholder); break; // converting from uint8_t;
            case MP_QSTR_glyph_index: dest[0] = mp_obj_new_int_from_uint(data->glyph_index); break; // converting from uint32_t;
            case MP_QSTR_entry: dest[0] = mp_read_ptr_lv_cache_entry_t((void*)data->entry); break; // converting from lv_cache_entry_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_resolved_font: data->resolved_font = (void*)mp_to_ptr(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_adv_w: data->adv_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_w: data->box_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_h: data->box_h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_bpp: data->bpp = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_is_placeholder: data->is_placeholder = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_glyph_index: data->glyph_index = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_entry: data->entry = (void*)mp_write_ptr_lv_cache_entry_t(dest[1]); break; // converting to lv_cache_entry_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_glyph_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_glyph_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_font_glyph_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_font_glyph_dsc_t_type,
    MP_QSTR_lv_font_glyph_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_font_glyph_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_font_glyph_dsc_t_attr,
    locals_dict, &mp_lv_font_glyph_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type()
{
    return &mp_lv_font_glyph_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool get_glyph_dsc(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */

STATIC mp_obj_t mp_funcptr_get_glyph_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *arg0 = (const lv_font_t *)mp_to_ptr(mp_args[0]);
    lv_font_glyph_dsc_t *arg1 = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t, uint32_t))lv_func_ptr)(arg0, arg1, letter, letter_next);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_dsc_mpobj, 4, mp_funcptr_get_glyph_dsc, funcptr_get_glyph_dsc);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_dsc(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_font_t_get_glyph_dsc_callback(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
#define funcptr_get_glyph_bitmap NULL


/*
 * Struct lv_image_header_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_image_header_t_type();

STATIC inline void* mp_write_ptr_lv_image_header_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_image_header_t_type()));
    return (lv_image_header_t*)self->data;
}

#define mp_write_lv_image_header_t(struct_obj) *((lv_image_header_t*)mp_write_ptr_lv_image_header_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_image_header_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_image_header_t_type(), field);
}

#define mp_read_lv_image_header_t(field) mp_read_ptr_lv_image_header_t(copy_buffer(&field, sizeof(lv_image_header_t)))
#define mp_read_byref_lv_image_header_t(field) mp_read_ptr_lv_image_header_t(&field)

STATIC void mp_lv_image_header_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_image_header_t *data = (lv_image_header_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_magic: dest[0] = mp_obj_new_int_from_uint(data->magic); break; // converting from uint32_t;
            case MP_QSTR_cf: dest[0] = mp_obj_new_int_from_uint(data->cf); break; // converting from uint32_t;
            case MP_QSTR_flags: dest[0] = mp_obj_new_int_from_uint(data->flags); break; // converting from uint32_t;
            case MP_QSTR_w: dest[0] = mp_obj_new_int_from_uint(data->w); break; // converting from uint32_t;
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint32_t;
            case MP_QSTR_stride: dest[0] = mp_obj_new_int_from_uint(data->stride); break; // converting from uint32_t;
            case MP_QSTR_reserved_2: dest[0] = mp_obj_new_int_from_uint(data->reserved_2); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_magic: data->magic = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_cf: data->cf = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_flags: data->flags = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_w: data->w = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_h: data->h = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_stride: data->stride = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_reserved_2: data->reserved_2 = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_image_header_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_image_header_t");
}

STATIC const mp_obj_dict_t mp_lv_image_header_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_header_t_type,
    MP_QSTR_lv_image_header_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_image_header_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_image_header_t_attr,
    locals_dict, &mp_lv_image_header_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_image_header_t_type()
{
    return &mp_lv_image_header_t_type;
}
    

/*
 * Struct lv_draw_buf_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_buf_t_type();

STATIC inline void* mp_write_ptr_lv_draw_buf_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_buf_t_type()));
    return (lv_draw_buf_t*)self->data;
}

#define mp_write_lv_draw_buf_t(struct_obj) *((lv_draw_buf_t*)mp_write_ptr_lv_draw_buf_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_buf_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_buf_t_type(), field);
}

#define mp_read_lv_draw_buf_t(field) mp_read_ptr_lv_draw_buf_t(copy_buffer(&field, sizeof(lv_draw_buf_t)))
#define mp_read_byref_lv_draw_buf_t(field) mp_read_ptr_lv_draw_buf_t(&field)

STATIC void mp_lv_draw_buf_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_buf_t *data = (lv_draw_buf_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_image_header_t(data->header); break; // converting from lv_image_header_t;
            case MP_QSTR_data_size: dest[0] = mp_obj_new_int_from_uint(data->data_size); break; // converting from uint32_t;
            case MP_QSTR_data: dest[0] = ptr_to_mp((void*)data->data); break; // converting from void *;
            case MP_QSTR_unaligned_data: dest[0] = ptr_to_mp((void*)data->unaligned_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_header: data->header = mp_write_lv_image_header_t(dest[1]); break; // converting to lv_image_header_t;
                case MP_QSTR_data_size: data->data_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_data: data->data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_unaligned_data: data->unaligned_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_buf_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_buf_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_buf_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_buf_t_type,
    MP_QSTR_lv_draw_buf_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_buf_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_buf_t_attr,
    locals_dict, &mp_lv_draw_buf_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_buf_t_type()
{
    return &mp_lv_draw_buf_t_type;
}
    

/*
 * lvgl extension definition for:
 * const void *get_glyph_bitmap(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *)
 */

STATIC mp_obj_t mp_funcptr_get_glyph_bitmap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_font_glyph_dsc_t *arg0 = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[0]);
    uint32_t arg1 = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_buf_t *arg2 = mp_write_ptr_lv_draw_buf_t(mp_args[2]);
    const void * _res = ((const void *(*)(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *))lv_func_ptr)(arg0, arg1, arg2);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_bitmap_mpobj, 3, mp_funcptr_get_glyph_bitmap, funcptr_get_glyph_bitmap);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_bitmap(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_font_t_get_glyph_bitmap_callback'
 * const void *(*get_glyph_bitmap)(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *)
 */
    
#define funcptr_release_glyph NULL


/*
 * lvgl extension definition for:
 * void release_glyph(const lv_font_t *, lv_font_glyph_dsc_t *)
 */

STATIC mp_obj_t mp_funcptr_release_glyph(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *arg0 = (const lv_font_t *)mp_to_ptr(mp_args[0]);
    lv_font_glyph_dsc_t *arg1 = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    ((void (*)(const lv_font_t *, lv_font_glyph_dsc_t *))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_release_glyph_mpobj, 2, mp_funcptr_release_glyph, funcptr_release_glyph);
    
STATIC inline mp_obj_t mp_lv_funcptr_release_glyph(void *func){ return mp_lv_funcptr(&mp_funcptr_release_glyph_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_font_t_release_glyph_callback(const lv_font_t *, lv_font_glyph_dsc_t *);

/*
 * Struct lv_font_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type();

STATIC inline void* mp_write_ptr_lv_font_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_t_type()));
    return (lv_font_t*)self->data;
}

#define mp_write_lv_font_t(struct_obj) *((lv_font_t*)mp_write_ptr_lv_font_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_font_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_font_t_type(), field);
}

#define mp_read_lv_font_t(field) mp_read_ptr_lv_font_t(copy_buffer(&field, sizeof(lv_font_t)))
#define mp_read_byref_lv_font_t(field) mp_read_ptr_lv_font_t(&field)

STATIC void mp_lv_font_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_font_t *data = (lv_font_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_get_glyph_dsc: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_mpobj, (void*)data->get_glyph_dsc, lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, data->user_data); break; // converting from callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
            case MP_QSTR_get_glyph_bitmap: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_mpobj, (void*)data->get_glyph_bitmap, NULL ,MP_QSTR_lv_font_t_get_glyph_bitmap, NULL); break; // converting from callback void *(*)(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *);
            case MP_QSTR_release_glyph: dest[0] = mp_lv_funcptr(&mp_funcptr_release_glyph_mpobj, (void*)data->release_glyph, lv_font_t_release_glyph_callback ,MP_QSTR_lv_font_t_release_glyph, data->user_data); break; // converting from callback void (*)(lv_font_t *, lv_font_glyph_dsc_t *);
            case MP_QSTR_line_height: dest[0] = mp_obj_new_int(data->line_height); break; // converting from int32_t;
            case MP_QSTR_base_line: dest[0] = mp_obj_new_int(data->base_line); break; // converting from int32_t;
            case MP_QSTR_subpx: dest[0] = mp_obj_new_int_from_uint(data->subpx); break; // converting from uint8_t;
            case MP_QSTR_kerning: dest[0] = mp_obj_new_int_from_uint(data->kerning); break; // converting from uint8_t;
            case MP_QSTR_underline_position: dest[0] = mp_obj_new_int(data->underline_position); break; // converting from int8_t;
            case MP_QSTR_underline_thickness: dest[0] = mp_obj_new_int(data->underline_thickness); break; // converting from int8_t;
            case MP_QSTR_dsc: dest[0] = ptr_to_mp((void*)data->dsc); break; // converting from void *;
            case MP_QSTR_fallback: dest[0] = ptr_to_mp((void*)data->fallback); break; // converting from lv_font_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_get_glyph_dsc: data->get_glyph_dsc = (void*)mp_lv_callback(dest[1], lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, &data->user_data, NULL, NULL, NULL); break; // converting to callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
                case MP_QSTR_get_glyph_bitmap: data->get_glyph_bitmap = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_font_t_get_glyph_bitmap, NULL, NULL, NULL, NULL); break; // converting to callback void *(*)(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *);
                case MP_QSTR_release_glyph: data->release_glyph = (void*)mp_lv_callback(dest[1], lv_font_t_release_glyph_callback ,MP_QSTR_lv_font_t_release_glyph, &data->user_data, NULL, NULL, NULL); break; // converting to callback void (*)(lv_font_t *, lv_font_glyph_dsc_t *);
                case MP_QSTR_line_height: data->line_height = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_base_line: data->base_line = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_subpx: data->subpx = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_kerning: data->kerning = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_underline_position: data->underline_position = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_underline_thickness: data->underline_thickness = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_dsc: data->dsc = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_fallback: data->fallback = (void*)mp_to_ptr(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_t");
}

STATIC const mp_obj_dict_t mp_lv_font_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_font_t_type,
    MP_QSTR_lv_font_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_font_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_font_t_attr,
    locals_dict, &mp_lv_font_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type()
{
    return &mp_lv_font_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_font_t *lv_obj_get_style_text_font(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t * _res = ((const lv_font_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_font_mpobj, 2, mp_lv_obj_get_style_text_font, lv_obj_get_style_text_font);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_letter_space_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_text_letter_space);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_line_space_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_text_line_space);
    

/*
 * lvgl extension definition for:
 * inline static lv_text_decor_t lv_obj_get_style_text_decor(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_text_decor_t _res = ((lv_text_decor_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_decor_mpobj, 2, mp_lv_obj_get_style_text_decor, lv_obj_get_style_text_decor);
    

/*
 * lvgl extension definition for:
 * inline static lv_text_align_t lv_obj_get_style_text_align(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_text_align_t _res = ((lv_text_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_align_mpobj, 2, mp_lv_obj_get_style_text_align, lv_obj_get_style_text_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_radius_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_radius);
    
/* Reusing lv_obj_get_style_bg_image_tiled for lv_obj_get_style_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_clip_corner_mpobj, 2, mp_lv_obj_get_style_bg_image_tiled, lv_obj_get_style_clip_corner);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_opa);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_opa_layered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_opa_layered_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_opa_layered);
    
#define funcptr_lv_color_filter_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */

STATIC mp_obj_t mp_funcptr_lv_color_filter_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_color_filter_dsc_t *arg0 = (const struct _lv_color_filter_dsc_t *)mp_to_ptr(mp_args[0]);
    lv_color_t arg1 = mp_write_lv_color_t(mp_args[1]);
    lv_opa_t arg2 = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t))lv_func_ptr)(arg0, arg1, arg2);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_color_filter_cb_t_mpobj, 3, mp_funcptr_lv_color_filter_cb_t, funcptr_lv_color_filter_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_color_filter_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_color_filter_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_color_t lv_color_filter_dsc_t_filter_cb_callback(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t);

/*
 * Struct lv_color_filter_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_filter_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_color_filter_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_filter_dsc_t_type()));
    return (lv_color_filter_dsc_t*)self->data;
}

#define mp_write_lv_color_filter_dsc_t(struct_obj) *((lv_color_filter_dsc_t*)mp_write_ptr_lv_color_filter_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_color_filter_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_color_filter_dsc_t_type(), field);
}

#define mp_read_lv_color_filter_dsc_t(field) mp_read_ptr_lv_color_filter_dsc_t(copy_buffer(&field, sizeof(lv_color_filter_dsc_t)))
#define mp_read_byref_lv_color_filter_dsc_t(field) mp_read_ptr_lv_color_filter_dsc_t(&field)

STATIC void mp_lv_color_filter_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_color_filter_dsc_t *data = (lv_color_filter_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_filter_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_color_filter_cb_t_mpobj, data->filter_cb, lv_color_filter_dsc_t_filter_cb_callback ,MP_QSTR_lv_color_filter_dsc_t_filter_cb, data->user_data); break; // converting from callback lv_color_filter_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_filter_cb: data->filter_cb = mp_lv_callback(dest[1], lv_color_filter_dsc_t_filter_cb_callback ,MP_QSTR_lv_color_filter_dsc_t_filter_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_color_filter_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_filter_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_filter_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_color_filter_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_color_filter_dsc_t_type,
    MP_QSTR_lv_color_filter_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_color_filter_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_color_filter_dsc_t_attr,
    locals_dict, &mp_lv_color_filter_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_color_filter_dsc_t_type()
{
    return &mp_lv_color_filter_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_color_filter_dsc_t *lv_obj_get_style_color_filter_dsc(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_color_filter_dsc_t * _res = ((const lv_color_filter_dsc_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_color_filter_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_color_filter_dsc_mpobj, 2, mp_lv_obj_get_style_color_filter_dsc, lv_obj_get_style_color_filter_dsc);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_color_filter_opa_mpobj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_color_filter_opa);
    
#define funcptr_lv_anim_exec_xcb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_exec_xcb_t(void *, int32_t)
 */

STATIC mp_obj_t mp_funcptr_lv_anim_exec_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *arg0 = mp_to_ptr(mp_args[0]);
    int32_t arg1 = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, int32_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_exec_xcb_t_mpobj, 2, mp_funcptr_lv_anim_exec_xcb_t, funcptr_lv_anim_exec_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_exec_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_anim_t_exec_cb_callback'
 * lv_anim_exec_xcb_t exec_cb
 */
    
#define funcptr_lv_anim_custom_exec_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_custom_exec_cb_t(lv_anim_t *, int32_t)
 */

STATIC mp_obj_t mp_funcptr_lv_anim_custom_exec_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    int32_t arg1 = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, int32_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_custom_exec_cb_t_mpobj, 2, mp_funcptr_lv_anim_custom_exec_cb_t, funcptr_lv_anim_custom_exec_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_custom_exec_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_custom_exec_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_anim_t_custom_exec_cb_callback(lv_anim_t *, int32_t);
#define funcptr_lv_anim_start_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_start_cb_t(lv_anim_t *)
 */

STATIC mp_obj_t mp_funcptr_lv_anim_start_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_anim_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_start_cb_t_mpobj, 1, mp_funcptr_lv_anim_start_cb_t, funcptr_lv_anim_start_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_start_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_anim_t_start_cb_callback(lv_anim_t *);
STATIC void lv_anim_t_completed_cb_callback(lv_anim_t *);
STATIC void lv_anim_t_deleted_cb_callback(lv_anim_t *);
#define funcptr_lv_anim_get_value_cb_t NULL


/*
 * lvgl extension definition for:
 * int32_t lv_anim_get_value_cb_t(lv_anim_t *)
 */

STATIC mp_obj_t mp_funcptr_lv_anim_get_value_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_anim_t *))lv_func_ptr)(arg0);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_get_value_cb_t_mpobj, 1, mp_funcptr_lv_anim_get_value_cb_t, funcptr_lv_anim_get_value_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_get_value_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC int32_t lv_anim_t_get_value_cb_callback(lv_anim_t *);
STATIC int32_t lv_anim_t_path_cb_callback(const lv_anim_t *);
typedef __typeof__( ((lv_anim_t*)(0))->parameter ) lv_anim_parameter_t;

/*
 * Struct lv_anim_bezier3_para_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_bezier3_para_t_type();

STATIC inline void* mp_write_ptr_lv_anim_bezier3_para_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_bezier3_para_t_type()));
    return (lv_anim_bezier3_para_t*)self->data;
}

#define mp_write_lv_anim_bezier3_para_t(struct_obj) *((lv_anim_bezier3_para_t*)mp_write_ptr_lv_anim_bezier3_para_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_anim_bezier3_para_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_bezier3_para_t_type(), field);
}

#define mp_read_lv_anim_bezier3_para_t(field) mp_read_ptr_lv_anim_bezier3_para_t(copy_buffer(&field, sizeof(lv_anim_bezier3_para_t)))
#define mp_read_byref_lv_anim_bezier3_para_t(field) mp_read_ptr_lv_anim_bezier3_para_t(&field)

STATIC void mp_lv_anim_bezier3_para_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_anim_bezier3_para_t *data = (lv_anim_bezier3_para_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x1: dest[0] = mp_obj_new_int(data->x1); break; // converting from int16_t;
            case MP_QSTR_y1: dest[0] = mp_obj_new_int(data->y1); break; // converting from int16_t;
            case MP_QSTR_x2: dest[0] = mp_obj_new_int(data->x2); break; // converting from int16_t;
            case MP_QSTR_y2: dest[0] = mp_obj_new_int(data->y2); break; // converting from int16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x1: data->x1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_y1: data->y1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_x2: data->x2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_y2: data->y2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_bezier3_para_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_bezier3_para_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_bezier3_para_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_anim_bezier3_para_t_type,
    MP_QSTR_lv_anim_bezier3_para_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_anim_bezier3_para_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_anim_bezier3_para_t_attr,
    locals_dict, &mp_lv_anim_bezier3_para_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_anim_bezier3_para_t_type()
{
    return &mp_lv_anim_bezier3_para_t_type;
}
    

/*
 * Struct lv_anim_parameter_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_parameter_t_type();

STATIC inline void* mp_write_ptr_lv_anim_parameter_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_parameter_t_type()));
    return (lv_anim_parameter_t*)self->data;
}

#define mp_write_lv_anim_parameter_t(struct_obj) *((lv_anim_parameter_t*)mp_write_ptr_lv_anim_parameter_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_anim_parameter_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_parameter_t_type(), field);
}

#define mp_read_lv_anim_parameter_t(field) mp_read_ptr_lv_anim_parameter_t(copy_buffer(&field, sizeof(lv_anim_parameter_t)))
#define mp_read_byref_lv_anim_parameter_t(field) mp_read_ptr_lv_anim_parameter_t(&field)

STATIC void mp_lv_anim_parameter_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_anim_parameter_t *data = (lv_anim_parameter_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_bezier3: dest[0] = mp_read_byref_lv_anim_bezier3_para_t(data->bezier3); break; // converting from lv_anim_bezier3_para_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_bezier3: data->bezier3 = mp_write_lv_anim_bezier3_para_t(dest[1]); break; // converting to lv_anim_bezier3_para_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_parameter_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_parameter_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_parameter_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_anim_parameter_t_type,
    MP_QSTR_lv_anim_parameter_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_anim_parameter_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_anim_parameter_t_attr,
    locals_dict, &mp_lv_anim_parameter_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_anim_parameter_t_type()
{
    return &mp_lv_anim_parameter_t_type;
}
    

/*
 * Struct lv_anim_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type();

STATIC inline void* mp_write_ptr_lv_anim_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_t_type()));
    return (lv_anim_t*)self->data;
}

#define mp_write_lv_anim_t(struct_obj) *((lv_anim_t*)mp_write_ptr_lv_anim_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_anim_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_t_type(), field);
}

#define mp_read_lv_anim_t(field) mp_read_ptr_lv_anim_t(copy_buffer(&field, sizeof(lv_anim_t)))
#define mp_read_byref_lv_anim_t(field) mp_read_ptr_lv_anim_t(&field)

STATIC void mp_lv_anim_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_anim_t *data = (lv_anim_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_var: dest[0] = ptr_to_mp((void*)data->var); break; // converting from void *;
            case MP_QSTR_exec_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_mpobj, data->exec_cb, NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL); break; // converting from callback lv_anim_exec_xcb_t;
            case MP_QSTR_custom_exec_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_custom_exec_cb_t_mpobj, data->custom_exec_cb, lv_anim_t_custom_exec_cb_callback ,MP_QSTR_lv_anim_t_custom_exec_cb, data->user_data); break; // converting from callback lv_anim_custom_exec_cb_t;
            case MP_QSTR_start_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_mpobj, data->start_cb, lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, data->user_data); break; // converting from callback lv_anim_start_cb_t;
            case MP_QSTR_completed_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_mpobj, data->completed_cb, lv_anim_t_completed_cb_callback ,MP_QSTR_lv_anim_t_completed_cb, data->user_data); break; // converting from callback lv_anim_completed_cb_t;
            case MP_QSTR_deleted_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_mpobj, data->deleted_cb, lv_anim_t_deleted_cb_callback ,MP_QSTR_lv_anim_t_deleted_cb, data->user_data); break; // converting from callback lv_anim_deleted_cb_t;
            case MP_QSTR_get_value_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_mpobj, data->get_value_cb, lv_anim_t_get_value_cb_callback ,MP_QSTR_lv_anim_t_get_value_cb, data->user_data); break; // converting from callback lv_anim_get_value_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_path_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_mpobj, data->path_cb, lv_anim_t_path_cb_callback ,MP_QSTR_lv_anim_t_path_cb, data->user_data); break; // converting from callback lv_anim_path_cb_t;
            case MP_QSTR_start_value: dest[0] = mp_obj_new_int(data->start_value); break; // converting from int32_t;
            case MP_QSTR_current_value: dest[0] = mp_obj_new_int(data->current_value); break; // converting from int32_t;
            case MP_QSTR_end_value: dest[0] = mp_obj_new_int(data->end_value); break; // converting from int32_t;
            case MP_QSTR_duration: dest[0] = mp_obj_new_int(data->duration); break; // converting from int32_t;
            case MP_QSTR_act_time: dest[0] = mp_obj_new_int(data->act_time); break; // converting from int32_t;
            case MP_QSTR_playback_delay: dest[0] = mp_obj_new_int_from_uint(data->playback_delay); break; // converting from uint32_t;
            case MP_QSTR_playback_duration: dest[0] = mp_obj_new_int_from_uint(data->playback_duration); break; // converting from uint32_t;
            case MP_QSTR_repeat_delay: dest[0] = mp_obj_new_int_from_uint(data->repeat_delay); break; // converting from uint32_t;
            case MP_QSTR_repeat_cnt: dest[0] = mp_obj_new_int_from_uint(data->repeat_cnt); break; // converting from uint16_t;
            case MP_QSTR_parameter: dest[0] = mp_read_byref_lv_anim_parameter_t(data->parameter); break; // converting from lv_anim_parameter_t;
            case MP_QSTR_early_apply: dest[0] = mp_obj_new_int_from_uint(data->early_apply); break; // converting from uint8_t;
            case MP_QSTR_last_timer_run: dest[0] = mp_obj_new_int_from_uint(data->last_timer_run); break; // converting from uint32_t;
            case MP_QSTR_playback_now: dest[0] = mp_obj_new_int_from_uint(data->playback_now); break; // converting from uint8_t;
            case MP_QSTR_run_round: dest[0] = mp_obj_new_int_from_uint(data->run_round); break; // converting from uint8_t;
            case MP_QSTR_start_cb_called: dest[0] = mp_obj_new_int_from_uint(data->start_cb_called); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_var: data->var = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_exec_cb: data->exec_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_anim_exec_xcb_t;
                case MP_QSTR_custom_exec_cb: data->custom_exec_cb = mp_lv_callback(dest[1], lv_anim_t_custom_exec_cb_callback ,MP_QSTR_lv_anim_t_custom_exec_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_custom_exec_cb_t;
                case MP_QSTR_start_cb: data->start_cb = mp_lv_callback(dest[1], lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_start_cb_t;
                case MP_QSTR_completed_cb: data->completed_cb = mp_lv_callback(dest[1], lv_anim_t_completed_cb_callback ,MP_QSTR_lv_anim_t_completed_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_completed_cb_t;
                case MP_QSTR_deleted_cb: data->deleted_cb = mp_lv_callback(dest[1], lv_anim_t_deleted_cb_callback ,MP_QSTR_lv_anim_t_deleted_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_deleted_cb_t;
                case MP_QSTR_get_value_cb: data->get_value_cb = mp_lv_callback(dest[1], lv_anim_t_get_value_cb_callback ,MP_QSTR_lv_anim_t_get_value_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_get_value_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_path_cb: data->path_cb = mp_lv_callback(dest[1], lv_anim_t_path_cb_callback ,MP_QSTR_lv_anim_t_path_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_anim_path_cb_t;
                case MP_QSTR_start_value: data->start_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_current_value: data->current_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_end_value: data->end_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_duration: data->duration = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_act_time: data->act_time = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_playback_delay: data->playback_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_playback_duration: data->playback_duration = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_delay: data->repeat_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_cnt: data->repeat_cnt = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_parameter: data->parameter = mp_write_lv_anim_parameter_t(dest[1]); break; // converting to lv_anim_parameter_t;
                case MP_QSTR_early_apply: data->early_apply = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_last_timer_run: data->last_timer_run = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_playback_now: data->playback_now = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_run_round: data->run_round = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_start_cb_called: data->start_cb_called = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_anim_t_type,
    MP_QSTR_lv_anim_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_anim_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_anim_t_attr,
    locals_dict, &mp_lv_anim_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type()
{
    return &mp_lv_anim_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_anim_t *lv_obj_get_style_anim(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_anim_t * _res = ((const lv_anim_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_anim_mpobj, 2, mp_lv_obj_get_style_anim, lv_obj_get_style_anim);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_obj_get_style_anim_duration(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_anim_duration(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_anim_duration_mpobj, 2, mp_lv_obj_get_style_anim_duration, lv_obj_get_style_anim_duration);
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_style_transition_dsc_t_path_xcb_callback'
 * lv_anim_path_cb_t path_xcb
 */
    

/*
 * Struct lv_style_transition_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_transition_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_style_transition_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_transition_dsc_t_type()));
    return (lv_style_transition_dsc_t*)self->data;
}

#define mp_write_lv_style_transition_dsc_t(struct_obj) *((lv_style_transition_dsc_t*)mp_write_ptr_lv_style_transition_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_style_transition_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_style_transition_dsc_t_type(), field);
}

#define mp_read_lv_style_transition_dsc_t(field) mp_read_ptr_lv_style_transition_dsc_t(copy_buffer(&field, sizeof(lv_style_transition_dsc_t)))
#define mp_read_byref_lv_style_transition_dsc_t(field) mp_read_ptr_lv_style_transition_dsc_t(&field)

STATIC void mp_lv_style_transition_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_style_transition_dsc_t *data = (lv_style_transition_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_props: dest[0] = ptr_to_mp((void*)data->props); break; // converting from lv_style_prop_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_path_xcb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_mpobj, data->path_xcb, NULL ,MP_QSTR_lv_style_transition_dsc_t_path_xcb, NULL); break; // converting from callback lv_anim_path_cb_t;
            case MP_QSTR_time: dest[0] = mp_obj_new_int_from_uint(data->time); break; // converting from uint32_t;
            case MP_QSTR_delay: dest[0] = mp_obj_new_int_from_uint(data->delay); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_props: data->props = (void*)mp_to_ptr(dest[1]); break; // converting to lv_style_prop_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_path_xcb: data->path_xcb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_style_transition_dsc_t_path_xcb, NULL, NULL, NULL, NULL); break; // converting to callback lv_anim_path_cb_t;
                case MP_QSTR_time: data->time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_delay: data->delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_transition_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_transition_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_style_transition_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_style_transition_dsc_t_type,
    MP_QSTR_lv_style_transition_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_style_transition_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_style_transition_dsc_t_attr,
    locals_dict, &mp_lv_style_transition_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_style_transition_dsc_t_type()
{
    return &mp_lv_style_transition_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_style_transition_dsc_t *lv_obj_get_style_transition(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_style_transition_dsc_t * _res = ((const lv_style_transition_dsc_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_style_transition_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_mpobj, 2, mp_lv_obj_get_style_transition, lv_obj_get_style_transition);
    

/*
 * lvgl extension definition for:
 * inline static lv_blend_mode_t lv_obj_get_style_blend_mode(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_blend_mode_t _res = ((lv_blend_mode_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_blend_mode_mpobj, 2, mp_lv_obj_get_style_blend_mode, lv_obj_get_style_blend_mode);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_obj_get_style_layout(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_layout_mpobj, 2, mp_lv_obj_get_style_layout, lv_obj_get_style_layout);
    

/*
 * lvgl extension definition for:
 * inline static lv_base_dir_t lv_obj_get_style_base_dir(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_base_dir_t _res = ((lv_base_dir_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_base_dir_mpobj, 2, mp_lv_obj_get_style_base_dir, lv_obj_get_style_base_dir);
    

/*
 * lvgl extension definition for:
 * inline static lv_flex_flow_t lv_obj_get_style_flex_flow(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_flex_flow_t _res = ((lv_flex_flow_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_flow_mpobj, 2, mp_lv_obj_get_style_flex_flow, lv_obj_get_style_flex_flow);
    

/*
 * lvgl extension definition for:
 * inline static lv_flex_align_t lv_obj_get_style_flex_main_place(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_flex_align_t _res = ((lv_flex_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_main_place_mpobj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_main_place);
    
/* Reusing lv_obj_get_style_flex_main_place for lv_obj_get_style_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_cross_place_mpobj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_cross_place);
    
/* Reusing lv_obj_get_style_flex_main_place for lv_obj_get_style_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_track_place_mpobj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_track_place);
    

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_obj_get_style_flex_grow(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint8_t _res = ((uint8_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_grow_mpobj, 2, mp_lv_obj_get_style_flex_grow, lv_obj_get_style_flex_grow);
    

/*
 * lvgl extension definition for:
 * inline static const int32_t *lv_obj_get_style_grid_column_dsc_array(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_grid_column_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const int32_t * _res = ((const int32_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_array_from_i32ptr((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_column_dsc_array_mpobj, 2, mp_lv_obj_get_style_grid_column_dsc_array, lv_obj_get_style_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * inline static lv_grid_align_t lv_obj_get_style_grid_column_align(const lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_grid_column_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_grid_align_t _res = ((lv_grid_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_column_align_mpobj, 2, mp_lv_obj_get_style_grid_column_align, lv_obj_get_style_grid_column_align);
    
/* Reusing lv_obj_get_style_grid_column_dsc_array for lv_obj_get_style_grid_row_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_row_dsc_array_mpobj, 2, mp_lv_obj_get_style_grid_column_dsc_array, lv_obj_get_style_grid_row_dsc_array);
    
/* Reusing lv_obj_get_style_grid_column_align for lv_obj_get_style_grid_row_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_row_align_mpobj, 2, mp_lv_obj_get_style_grid_column_align, lv_obj_get_style_grid_row_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_grid_cell_column_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_column_pos_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_grid_cell_column_pos);
    
/* Reusing lv_obj_get_style_grid_column_align for lv_obj_get_style_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_x_align_mpobj, 2, mp_lv_obj_get_style_grid_column_align, lv_obj_get_style_grid_cell_x_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_column_span_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_grid_cell_column_span);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_row_pos_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_grid_cell_row_pos);
    
/* Reusing lv_obj_get_style_grid_column_align for lv_obj_get_style_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_y_align_mpobj, 2, mp_lv_obj_get_style_grid_column_align, lv_obj_get_style_grid_cell_y_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_row_span_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_grid_cell_row_span);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_pad_all(lv_obj_t *obj, int32_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_pad_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_all_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_all);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_hor_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_hor);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_ver_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_ver);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_all_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_all);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_hor_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_hor);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_ver_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_ver);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_gap_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_gap);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_size(lv_obj_t *obj, int32_t width, int32_t height, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t width = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t height = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, int32_t, int32_t, lv_style_selector_t))lv_func_ptr)(obj, width, height, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_size_mpobj, 4, mp_lv_obj_set_style_size, lv_obj_set_style_size);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_scale */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_scale_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_scale);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_space_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_space_left_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_space_left);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_space_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_space_right_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_space_right);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_space_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_space_top_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_space_top);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_space_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_space_bottom_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_space_bottom);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_scale_x_safe */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_scale_x_safe_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_scale_x_safe);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_scale_y_safe */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_scale_y_safe_mpobj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_scale_y_safe);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_user_data(lv_obj_t *obj, void *user_data)
 */

STATIC mp_obj_t mp_lv_obj_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *, void *))lv_func_ptr)(obj, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_user_data_mpobj, 2, mp_lv_obj_set_user_data, lv_obj_set_user_data);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_obj_get_user_data(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void * _res = ((void *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_user_data_mpobj, 1, mp_lv_obj_get_user_data, lv_obj_get_user_data);
    
/* Reusing lv_obj_center for lv_obj_move_foreground */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_foreground_mpobj, 1, mp_lv_obj_center, lv_obj_move_foreground);
    
/* Reusing lv_obj_center for lv_obj_move_background */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_background_mpobj, 1, mp_lv_obj_center, lv_obj_move_background);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_flow(lv_obj_t *obj, lv_flex_flow_t flow)
 */

STATIC mp_obj_t mp_lv_obj_set_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_flow_t flow = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_flex_flow_t))lv_func_ptr)(obj, flow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_flow_mpobj, 2, mp_lv_obj_set_flex_flow, lv_obj_set_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_align(lv_obj_t *obj, lv_flex_align_t main_place, lv_flex_align_t cross_place, lv_flex_align_t track_cross_place)
 */

STATIC mp_obj_t mp_lv_obj_set_flex_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_align_t main_place = (int)mp_obj_get_int(mp_args[1]);
    lv_flex_align_t cross_place = (int)mp_obj_get_int(mp_args[2]);
    lv_flex_align_t track_cross_place = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_flex_align_t, lv_flex_align_t, lv_flex_align_t))lv_func_ptr)(obj, main_place, cross_place, track_cross_place);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_align_mpobj, 4, mp_lv_obj_set_flex_align, lv_obj_set_flex_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_grow(lv_obj_t *obj, uint8_t grow)
 */

STATIC mp_obj_t mp_lv_obj_set_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t grow = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint8_t))lv_func_ptr)(obj, grow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_grow_mpobj, 2, mp_lv_obj_set_flex_grow, lv_obj_set_flex_grow);
    

/*
 * Array convertors for int32_t []
 */

GENMPY_UNUSED STATIC int32_t *mp_arr_to_int32_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    int32_t *lv_arr = (int32_t*)m_malloc(len * sizeof(int32_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (int32_t)mp_obj_get_int(item);
    }
    return (int32_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_int32_t_____(const int32_t *arr)
{
    return mp_array_from_i32ptr((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_dsc_array(lv_obj_t *obj, const int32_t col_dsc[], const int32_t row_dsc[])
 */

STATIC mp_obj_t mp_lv_obj_set_grid_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const int32_t *col_dsc = (const int32_t *)mp_arr_to_int32_t_____(mp_args[1]);
    const int32_t *row_dsc = (const int32_t *)mp_arr_to_int32_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, const int32_t [], const int32_t []))lv_func_ptr)(obj, col_dsc, row_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_dsc_array_mpobj, 3, mp_lv_obj_set_grid_dsc_array, lv_obj_set_grid_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_align(lv_obj_t *obj, lv_grid_align_t column_align, lv_grid_align_t row_align)
 */

STATIC mp_obj_t mp_lv_obj_set_grid_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t column_align = (int)mp_obj_get_int(mp_args[1]);
    lv_grid_align_t row_align = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, lv_grid_align_t))lv_func_ptr)(obj, column_align, row_align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_align_mpobj, 3, mp_lv_obj_set_grid_align, lv_obj_set_grid_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_cell(lv_obj_t *obj, lv_grid_align_t column_align, int32_t col_pos, int32_t col_span, lv_grid_align_t row_align, int32_t row_pos, int32_t row_span)
 */

STATIC mp_obj_t mp_lv_obj_set_grid_cell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t column_align = (int)mp_obj_get_int(mp_args[1]);
    int32_t col_pos = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t col_span = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_grid_align_t row_align = (int)mp_obj_get_int(mp_args[4]);
    int32_t row_pos = (int32_t)mp_obj_get_int(mp_args[5]);
    int32_t row_span = (int32_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, int32_t, int32_t, lv_grid_align_t, int32_t, int32_t))lv_func_ptr)(obj, column_align, col_pos, col_span, row_align, row_pos, row_span);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_cell_mpobj, 7, mp_lv_obj_set_grid_cell, lv_obj_set_grid_cell);
    
/* Reusing lv_obj_center for lv_obj_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_delete_mpobj, 1, mp_lv_obj_center, lv_obj_delete);
    
/* Reusing lv_obj_center for lv_obj_clean */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clean_mpobj, 1, mp_lv_obj_center, lv_obj_clean);
    

/*
 * lvgl extension definition for:
 * void lv_obj_delete_delayed(lv_obj_t *obj, uint32_t delay_ms)
 */

STATIC mp_obj_t mp_lv_obj_delete_delayed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t delay_ms = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, delay_ms);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_delete_delayed_mpobj, 2, mp_lv_obj_delete_delayed, lv_obj_delete_delayed);
    
/* Reusing funcptr_lv_anim_start_cb_t for lv_obj_delete_anim_completed_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_delete_anim_completed_cb_mpobj, 1, mp_funcptr_lv_anim_start_cb_t, lv_obj_delete_anim_completed_cb);
    
/* Reusing lv_obj_center for lv_obj_delete_async */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_delete_async_mpobj, 1, mp_lv_obj_center, lv_obj_delete_async);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_parent(lv_obj_t *obj, lv_obj_t *parent)
 */

STATIC mp_obj_t mp_lv_obj_set_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t *parent = mp_to_lv(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(obj, parent);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_parent_mpobj, 2, mp_lv_obj_set_parent, lv_obj_set_parent);
    
/* Reusing lv_obj_set_parent for lv_obj_swap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_swap_mpobj, 2, mp_lv_obj_set_parent, lv_obj_swap);
    

/*
 * lvgl extension definition for:
 * void lv_obj_move_to_index(lv_obj_t *obj, int32_t index)
 */

STATIC mp_obj_t mp_lv_obj_move_to_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t index = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int32_t))lv_func_ptr)(obj, index);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_to_index_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_move_to_index);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_get_screen(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_screen(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_screen_mpobj, 1, mp_lv_obj_get_screen, lv_obj_get_screen);
    

/*
 * Struct lv_display_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_display_t_type();

STATIC inline void* mp_write_ptr_lv_display_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_display_t_type()));
    return (lv_display_t*)self->data;
}

#define mp_write_lv_display_t(struct_obj) *((lv_display_t*)mp_write_ptr_lv_display_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_display_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_display_t_type(), field);
}

#define mp_read_lv_display_t(field) mp_read_ptr_lv_display_t(copy_buffer(&field, sizeof(lv_display_t)))
#define mp_read_byref_lv_display_t(field) mp_read_ptr_lv_display_t(&field)

STATIC void mp_lv_display_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_display_t *data = (lv_display_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            ;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                ;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_display_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_display_t");
}

STATIC const mp_obj_dict_t mp_lv_display_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_display_t_type,
    MP_QSTR_lv_display_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_display_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_display_t_attr,
    locals_dict, &mp_lv_display_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_display_t_type()
{
    return &mp_lv_display_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_display_t *lv_obj_get_display(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_display(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_display_t * _res = ((lv_display_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_display_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_display_mpobj, 1, mp_lv_obj_get_display, lv_obj_get_display);
    
/* Reusing lv_obj_get_screen for lv_obj_get_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_parent_mpobj, 1, mp_lv_obj_get_screen, lv_obj_get_parent);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_get_child(const lv_obj_t *obj, int32_t idx)
 */

STATIC mp_obj_t mp_lv_obj_get_child(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    int32_t idx = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *, int32_t))lv_func_ptr)(obj, idx);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_mpobj, 2, mp_lv_obj_get_child, lv_obj_get_child);
    
#define funcptr_constructor_cb NULL


/*
 * lvgl extension definition for:
 * void constructor_cb(const lv_obj_class_t *class_p, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_funcptr_constructor_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_to_ptr(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(const lv_obj_class_t *, lv_obj_t *))lv_func_ptr)(class_p, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_constructor_cb_mpobj, 2, mp_funcptr_constructor_cb, funcptr_constructor_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_constructor_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_constructor_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_obj_class_t_constructor_cb_callback(const lv_obj_class_t *class_p, lv_obj_t *obj);
STATIC void lv_obj_class_t_destructor_cb_callback(const lv_obj_class_t *class_p, lv_obj_t *obj);
#define funcptr_event_cb NULL


/*
 * Struct lv_event_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_event_t_type();

STATIC inline void* mp_write_ptr_lv_event_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_event_t_type()));
    return (lv_event_t*)self->data;
}

#define mp_write_lv_event_t(struct_obj) *((lv_event_t*)mp_write_ptr_lv_event_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_event_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_event_t_type(), field);
}

#define mp_read_lv_event_t(field) mp_read_ptr_lv_event_t(copy_buffer(&field, sizeof(lv_event_t)))
#define mp_read_byref_lv_event_t(field) mp_read_ptr_lv_event_t(&field)

STATIC void mp_lv_event_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_event_t *data = (lv_event_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_current_target: dest[0] = ptr_to_mp((void*)data->current_target); break; // converting from void *;
            case MP_QSTR_original_target: dest[0] = ptr_to_mp((void*)data->original_target); break; // converting from void *;
            case MP_QSTR_code: dest[0] = mp_obj_new_int(data->code); break; // converting from lv_event_code_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_param: dest[0] = ptr_to_mp((void*)data->param); break; // converting from void *;
            case MP_QSTR_prev: dest[0] = ptr_to_mp((void*)data->prev); break; // converting from lv_event_t *;
            case MP_QSTR_deleted: dest[0] = mp_obj_new_int_from_uint(data->deleted); break; // converting from uint8_t;
            case MP_QSTR_stop_processing: dest[0] = mp_obj_new_int_from_uint(data->stop_processing); break; // converting from uint8_t;
            case MP_QSTR_stop_bubbling: dest[0] = mp_obj_new_int_from_uint(data->stop_bubbling); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_current_target: data->current_target = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_original_target: data->original_target = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_code: data->code = (int)mp_obj_get_int(dest[1]); break; // converting to lv_event_code_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_param: data->param = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_prev: data->prev = (void*)mp_to_ptr(dest[1]); break; // converting to lv_event_t *;
                case MP_QSTR_deleted: data->deleted = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_stop_processing: data->stop_processing = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_stop_bubbling: data->stop_bubbling = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_event_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_event_t");
}

STATIC const mp_obj_dict_t mp_lv_event_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_event_t_type,
    MP_QSTR_lv_event_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_event_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_event_t_attr,
    locals_dict, &mp_lv_event_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_event_t_type()
{
    return &mp_lv_event_t_type;
}
    

/*
 * lvgl extension definition for:
 * void event_cb(const lv_obj_class_t *class_p, lv_event_t *e)
 */

STATIC mp_obj_t mp_funcptr_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_to_ptr(mp_args[0]);
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[1]);
    ((void (*)(const lv_obj_class_t *, lv_event_t *))lv_func_ptr)(class_p, e);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_event_cb_mpobj, 2, mp_funcptr_event_cb, funcptr_event_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_event_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_event_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_obj_class_t_event_cb_callback(const lv_obj_class_t *class_p, lv_event_t *e);

/*
 * Struct lv_obj_class_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_obj_class_t_type();

STATIC inline void* mp_write_ptr_lv_obj_class_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_obj_class_t_type()));
    return (lv_obj_class_t*)self->data;
}

#define mp_write_lv_obj_class_t(struct_obj) *((lv_obj_class_t*)mp_write_ptr_lv_obj_class_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_obj_class_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_obj_class_t_type(), field);
}

#define mp_read_lv_obj_class_t(field) mp_read_ptr_lv_obj_class_t(copy_buffer(&field, sizeof(lv_obj_class_t)))
#define mp_read_byref_lv_obj_class_t(field) mp_read_ptr_lv_obj_class_t(&field)

STATIC void mp_lv_obj_class_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_obj_class_t *data = (lv_obj_class_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base_class: dest[0] = ptr_to_mp((void*)data->base_class); break; // converting from lv_obj_class_t *;
            case MP_QSTR_constructor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_constructor_cb_mpobj, (void*)data->constructor_cb, lv_obj_class_t_constructor_cb_callback ,MP_QSTR_lv_obj_class_t_constructor_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
            case MP_QSTR_destructor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_constructor_cb_mpobj, (void*)data->destructor_cb, lv_obj_class_t_destructor_cb_callback ,MP_QSTR_lv_obj_class_t_destructor_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
            case MP_QSTR_event_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_event_cb_mpobj, (void*)data->event_cb, lv_obj_class_t_event_cb_callback ,MP_QSTR_lv_obj_class_t_event_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_event_t *e);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_name: dest[0] = convert_to_str((void*)data->name); break; // converting from char *;
            case MP_QSTR_width_def: dest[0] = mp_obj_new_int(data->width_def); break; // converting from int32_t;
            case MP_QSTR_height_def: dest[0] = mp_obj_new_int(data->height_def); break; // converting from int32_t;
            case MP_QSTR_editable: dest[0] = mp_obj_new_int_from_uint(data->editable); break; // converting from uint32_t;
            case MP_QSTR_group_def: dest[0] = mp_obj_new_int_from_uint(data->group_def); break; // converting from uint32_t;
            case MP_QSTR_instance_size: dest[0] = mp_obj_new_int_from_uint(data->instance_size); break; // converting from uint32_t;
            case MP_QSTR_theme_inheritable: dest[0] = mp_obj_new_int_from_uint(data->theme_inheritable); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base_class: data->base_class = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_class_t *;
                case MP_QSTR_constructor_cb: data->constructor_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_constructor_cb_callback ,MP_QSTR_lv_obj_class_t_constructor_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
                case MP_QSTR_destructor_cb: data->destructor_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_destructor_cb_callback ,MP_QSTR_lv_obj_class_t_destructor_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
                case MP_QSTR_event_cb: data->event_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_event_cb_callback ,MP_QSTR_lv_obj_class_t_event_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_event_t *e);
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_name: data->name = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_width_def: data->width_def = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_height_def: data->height_def = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_editable: data->editable = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_group_def: data->group_def = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_instance_size: data->instance_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_theme_inheritable: data->theme_inheritable = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_obj_class_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_obj_class_t");
}

STATIC const mp_obj_dict_t mp_lv_obj_class_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_obj_class_t_type,
    MP_QSTR_lv_obj_class_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_obj_class_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_obj_class_t_attr,
    locals_dict, &mp_lv_obj_class_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_obj_class_t_type()
{
    return &mp_lv_obj_class_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_get_child_by_type(const lv_obj_t *obj, int32_t idx, const lv_obj_class_t *class_p)
 */

STATIC mp_obj_t mp_lv_obj_get_child_by_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    int32_t idx = (int32_t)mp_obj_get_int(mp_args[1]);
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *, int32_t, const lv_obj_class_t *))lv_func_ptr)(obj, idx, class_p);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_by_type_mpobj, 3, mp_lv_obj_get_child_by_type, lv_obj_get_child_by_type);
    
/* Reusing lv_obj_get_child for lv_obj_get_sibling */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_sibling_mpobj, 2, mp_lv_obj_get_child, lv_obj_get_sibling);
    
/* Reusing lv_obj_get_child_by_type for lv_obj_get_sibling_by_type */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_sibling_by_type_mpobj, 3, mp_lv_obj_get_child_by_type, lv_obj_get_sibling_by_type);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_obj_get_child_count(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_child_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_count_mpobj, 1, mp_lv_obj_get_child_count, lv_obj_get_child_count);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_obj_get_child_count_by_type(const lv_obj_t *obj, const lv_obj_class_t *class_p)
 */

STATIC mp_obj_t mp_lv_obj_get_child_count_by_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, const lv_obj_class_t *))lv_func_ptr)(obj, class_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_count_by_type_mpobj, 2, mp_lv_obj_get_child_count_by_type, lv_obj_get_child_count_by_type);
    

/*
 * lvgl extension definition for:
 * int32_t lv_obj_get_index(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_index_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_index);
    

/*
 * lvgl extension definition for:
 * int32_t lv_obj_get_index_by_type(const lv_obj_t *obj, const lv_obj_class_t *class_p)
 */

STATIC mp_obj_t mp_lv_obj_get_index_by_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[1]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *, const lv_obj_class_t *))lv_func_ptr)(obj, class_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_index_by_type_mpobj, 2, mp_lv_obj_get_index_by_type, lv_obj_get_index_by_type);
    

/*
 * Callback function lv_obj_tree_walk_cb
 * lv_obj_tree_walk_res_t lv_obj_tree_walk_cb_t(lv_obj_t *, void *)
 */

GENMPY_UNUSED STATIC lv_obj_tree_walk_res_t lv_obj_tree_walk_cb_callback(lv_obj_t *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg1);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_tree_walk_cb)) , 2, 0, mp_args);
    _nesting--;
    return (int)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_obj_tree_walk(lv_obj_t *start_obj, lv_obj_tree_walk_cb_t cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_obj_tree_walk(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *cb = mp_lv_callback(mp_args[1], &lv_obj_tree_walk_cb_callback, MP_QSTR_lv_obj_tree_walk_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_obj_t *start_obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *, lv_obj_tree_walk_cb_t, void *))lv_func_ptr)(start_obj, cb, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_tree_walk_mpobj, 3, mp_lv_obj_tree_walk, lv_obj_tree_walk);
    
/* Reusing lv_obj_center for lv_obj_dump_tree */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_dump_tree_mpobj, 1, mp_lv_obj_center, lv_obj_dump_tree);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_pos(lv_obj_t *obj, int32_t x, int32_t y)
 */

STATIC mp_obj_t mp_lv_obj_set_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, int32_t))lv_func_ptr)(obj, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_pos_mpobj, 3, mp_lv_obj_set_pos, lv_obj_set_pos);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_x_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_x);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_y_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_y);
    
/* Reusing lv_obj_set_pos for lv_obj_set_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_size_mpobj, 3, mp_lv_obj_set_pos, lv_obj_set_size);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_refr_size(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_refr_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refr_size_mpobj, 1, mp_lv_obj_refr_size, lv_obj_refr_size);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_width_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_width);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_height_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_height);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_content_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_content_width_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_content_width);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_content_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_content_height_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_content_height);
    
/* Reusing lv_obj_delete_delayed for lv_obj_set_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_layout_mpobj, 2, mp_lv_obj_delete_delayed, lv_obj_set_layout);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_is_layout_positioned(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_is_layout_positioned(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_layout_positioned_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_layout_positioned);
    
/* Reusing lv_obj_center for lv_obj_mark_layout_as_dirty */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_mark_layout_as_dirty_mpobj, 1, mp_lv_obj_center, lv_obj_mark_layout_as_dirty);
    

/*
 * lvgl extension definition for:
 * void lv_obj_update_layout(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_update_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    ((void (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_update_layout_mpobj, 1, mp_lv_obj_update_layout, lv_obj_update_layout);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_align(lv_obj_t *obj, lv_align_t align)
 */

STATIC mp_obj_t mp_lv_obj_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_align_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_align_mpobj, 2, mp_lv_obj_set_align, lv_obj_set_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align(lv_obj_t *obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs)
 */

STATIC mp_obj_t mp_lv_obj_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    int32_t x_ofs = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t y_ofs = (int32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_align_t, int32_t, int32_t))lv_func_ptr)(obj, align, x_ofs, y_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_mpobj, 4, mp_lv_obj_align, lv_obj_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align_to(lv_obj_t *obj, const lv_obj_t *base, lv_align_t align, int32_t x_ofs, int32_t y_ofs)
 */

STATIC mp_obj_t mp_lv_obj_align_to(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_t *base = (const lv_obj_t *)mp_to_lv(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    int32_t x_ofs = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t y_ofs = (int32_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, const lv_obj_t *, lv_align_t, int32_t, int32_t))lv_func_ptr)(obj, base, align, x_ofs, y_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_to_mpobj, 5, mp_lv_obj_align_to, lv_obj_align_to);
    

/*
 * Struct lv_area_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type();

STATIC inline void* mp_write_ptr_lv_area_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_area_t_type()));
    return (lv_area_t*)self->data;
}

#define mp_write_lv_area_t(struct_obj) *((lv_area_t*)mp_write_ptr_lv_area_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_area_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_area_t_type(), field);
}

#define mp_read_lv_area_t(field) mp_read_ptr_lv_area_t(copy_buffer(&field, sizeof(lv_area_t)))
#define mp_read_byref_lv_area_t(field) mp_read_ptr_lv_area_t(&field)

STATIC void mp_lv_area_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_area_t *data = (lv_area_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x1: dest[0] = mp_obj_new_int(data->x1); break; // converting from int32_t;
            case MP_QSTR_y1: dest[0] = mp_obj_new_int(data->y1); break; // converting from int32_t;
            case MP_QSTR_x2: dest[0] = mp_obj_new_int(data->x2); break; // converting from int32_t;
            case MP_QSTR_y2: dest[0] = mp_obj_new_int(data->y2); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x1: data->x1 = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y1: data->y1 = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_x2: data->x2 = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y2: data->y2 = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_area_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_area_t");
}

STATIC const mp_obj_dict_t mp_lv_area_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_area_t_type,
    MP_QSTR_lv_area_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_area_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_area_t_attr,
    locals_dict, &mp_lv_area_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type()
{
    return &mp_lv_area_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_coords(const lv_obj_t *obj, lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_obj_get_coords(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_coords_mpobj, 2, mp_lv_obj_get_coords, lv_obj_get_coords);
    
/* Reusing lv_obj_get_index for lv_obj_get_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_x);
    
/* Reusing lv_obj_get_index for lv_obj_get_x2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x2_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_x2);
    
/* Reusing lv_obj_get_index for lv_obj_get_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_y);
    
/* Reusing lv_obj_get_index for lv_obj_get_y2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y2_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_y2);
    
/* Reusing lv_obj_get_index for lv_obj_get_x_aligned */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x_aligned_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_x_aligned);
    
/* Reusing lv_obj_get_index for lv_obj_get_y_aligned */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y_aligned_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_y_aligned);
    
/* Reusing lv_obj_get_index for lv_obj_get_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_width);
    
/* Reusing lv_obj_get_index for lv_obj_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_height);
    
/* Reusing lv_obj_get_index for lv_obj_get_content_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_width_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_content_width);
    
/* Reusing lv_obj_get_index for lv_obj_get_content_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_height_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_content_height);
    
/* Reusing lv_obj_get_coords for lv_obj_get_content_coords */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_coords_mpobj, 2, mp_lv_obj_get_coords, lv_obj_get_content_coords);
    
/* Reusing lv_obj_get_index for lv_obj_get_self_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_self_width_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_self_width);
    
/* Reusing lv_obj_get_index for lv_obj_get_self_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_self_height_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_self_height);
    
/* Reusing lv_obj_refr_size for lv_obj_refresh_self_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_self_size_mpobj, 1, mp_lv_obj_refr_size, lv_obj_refresh_self_size);
    
/* Reusing lv_obj_center for lv_obj_refr_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refr_pos_mpobj, 1, mp_lv_obj_center, lv_obj_refr_pos);
    
/* Reusing lv_obj_set_pos for lv_obj_move_to */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_to_mpobj, 3, mp_lv_obj_set_pos, lv_obj_move_to);
    

/*
 * lvgl extension definition for:
 * void lv_obj_move_children_by(lv_obj_t *obj, int32_t x_diff, int32_t y_diff, bool ignore_floating)
 */

STATIC mp_obj_t mp_lv_obj_move_children_by(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x_diff = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y_diff = (int32_t)mp_obj_get_int(mp_args[2]);
    bool ignore_floating = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_obj_t *, int32_t, int32_t, bool))lv_func_ptr)(obj, x_diff, y_diff, ignore_floating);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_children_by_mpobj, 4, mp_lv_obj_move_children_by, lv_obj_move_children_by);
    

/*
 * Struct lv_point_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type();

STATIC inline void* mp_write_ptr_lv_point_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_point_t_type()));
    return (lv_point_t*)self->data;
}

#define mp_write_lv_point_t(struct_obj) *((lv_point_t*)mp_write_ptr_lv_point_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_point_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_point_t_type(), field);
}

#define mp_read_lv_point_t(field) mp_read_ptr_lv_point_t(copy_buffer(&field, sizeof(lv_point_t)))
#define mp_read_byref_lv_point_t(field) mp_read_ptr_lv_point_t(&field)

STATIC void mp_lv_point_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_point_t *data = (lv_point_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x: dest[0] = mp_obj_new_int(data->x); break; // converting from int32_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x: data->x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y: data->y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_point_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_point_t");
}

STATIC const mp_obj_dict_t mp_lv_point_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_point_t_type,
    MP_QSTR_lv_point_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_point_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_point_t_attr,
    locals_dict, &mp_lv_point_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type()
{
    return &mp_lv_point_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_transform_point(const lv_obj_t *obj, lv_point_t *p, bool recursive, bool inv)
 */

STATIC mp_obj_t mp_lv_obj_transform_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_point_t *p = mp_write_ptr_lv_point_t(mp_args[1]);
    bool recursive = mp_obj_is_true(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(const lv_obj_t *, lv_point_t *, bool, bool))lv_func_ptr)(obj, p, recursive, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_transform_point_mpobj, 4, mp_lv_obj_transform_point, lv_obj_transform_point);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_transformed_area(const lv_obj_t *obj, lv_area_t *area, bool recursive, bool inv)
 */

STATIC mp_obj_t mp_lv_obj_get_transformed_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    bool recursive = mp_obj_is_true(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(const lv_obj_t *, lv_area_t *, bool, bool))lv_func_ptr)(obj, area, recursive, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_transformed_area_mpobj, 4, mp_lv_obj_get_transformed_area, lv_obj_get_transformed_area);
    

/*
 * lvgl extension definition for:
 * void lv_obj_invalidate_area(const lv_obj_t *obj, const lv_area_t *area)
 */

STATIC mp_obj_t mp_lv_obj_invalidate_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_area_t *area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const lv_obj_t *, const lv_area_t *))lv_func_ptr)(obj, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_area_mpobj, 2, mp_lv_obj_invalidate_area, lv_obj_invalidate_area);
    
/* Reusing lv_obj_update_layout for lv_obj_invalidate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_mpobj, 1, mp_lv_obj_update_layout, lv_obj_invalidate);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_area_is_visible(const lv_obj_t *obj, lv_area_t *area)
 */

STATIC mp_obj_t mp_lv_obj_area_is_visible(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, area);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_area_is_visible_mpobj, 2, mp_lv_obj_area_is_visible, lv_obj_area_is_visible);
    
/* Reusing lv_obj_is_layout_positioned for lv_obj_is_visible */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_visible_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_visible);
    
/* Reusing lv_obj_move_to_index for lv_obj_set_ext_click_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_ext_click_area_mpobj, 2, mp_lv_obj_move_to_index, lv_obj_set_ext_click_area);
    
/* Reusing lv_obj_get_coords for lv_obj_get_click_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_click_area_mpobj, 2, mp_lv_obj_get_coords, lv_obj_get_click_area);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_hit_test(lv_obj_t *obj, const lv_point_t *point)
 */

STATIC mp_obj_t mp_lv_obj_hit_test(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_point_t *point = (const lv_point_t *)mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, const lv_point_t *))lv_func_ptr)(obj, point);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_hit_test_mpobj, 2, mp_lv_obj_hit_test, lv_obj_hit_test);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scrollbar_mode(lv_obj_t *obj, lv_scrollbar_mode_t mode)
 */

STATIC mp_obj_t mp_lv_obj_set_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_scrollbar_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scrollbar_mode_mpobj, 2, mp_lv_obj_set_scrollbar_mode, lv_obj_set_scrollbar_mode);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scroll_dir(lv_obj_t *obj, lv_dir_t dir)
 */

STATIC mp_obj_t mp_lv_obj_set_scroll_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_dir_t))lv_func_ptr)(obj, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_dir_mpobj, 2, mp_lv_obj_set_scroll_dir, lv_obj_set_scroll_dir);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scroll_snap_x(lv_obj_t *obj, lv_scroll_snap_t align)
 */

STATIC mp_obj_t mp_lv_obj_set_scroll_snap_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scroll_snap_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_scroll_snap_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_snap_x_mpobj, 2, mp_lv_obj_set_scroll_snap_x, lv_obj_set_scroll_snap_x);
    
/* Reusing lv_obj_set_scroll_snap_x for lv_obj_set_scroll_snap_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_snap_y_mpobj, 2, mp_lv_obj_set_scroll_snap_x, lv_obj_set_scroll_snap_y);
    

/*
 * lvgl extension definition for:
 * lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t _res = ((lv_scrollbar_mode_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scrollbar_mode_mpobj, 1, mp_lv_obj_get_scrollbar_mode, lv_obj_get_scrollbar_mode);
    

/*
 * lvgl extension definition for:
 * lv_dir_t lv_obj_get_scroll_dir(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_scroll_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_dir_t _res = ((lv_dir_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_dir_mpobj, 1, mp_lv_obj_get_scroll_dir, lv_obj_get_scroll_dir);
    

/*
 * lvgl extension definition for:
 * lv_scroll_snap_t lv_obj_get_scroll_snap_x(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_scroll_snap_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_scroll_snap_t _res = ((lv_scroll_snap_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_snap_x_mpobj, 1, mp_lv_obj_get_scroll_snap_x, lv_obj_get_scroll_snap_x);
    
/* Reusing lv_obj_get_scroll_snap_x for lv_obj_get_scroll_snap_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_snap_y_mpobj, 1, mp_lv_obj_get_scroll_snap_x, lv_obj_get_scroll_snap_y);
    
/* Reusing lv_obj_get_index for lv_obj_get_scroll_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_x_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_scroll_x);
    
/* Reusing lv_obj_get_index for lv_obj_get_scroll_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_y_mpobj, 1, mp_lv_obj_get_index, lv_obj_get_scroll_y);
    

/*
 * lvgl extension definition for:
 * int32_t lv_obj_get_scroll_top(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_scroll_top(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_top_mpobj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_top);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_bottom_mpobj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_bottom);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_left_mpobj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_left);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_right_mpobj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_right);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_scroll_end(lv_obj_t *obj, lv_point_t *end)
 */

STATIC mp_obj_t mp_lv_obj_get_scroll_end(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *end = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_end_mpobj, 2, mp_lv_obj_get_scroll_end, lv_obj_get_scroll_end);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_by(lv_obj_t *obj, int32_t x, int32_t y, lv_anim_enable_t anim_en)
 */

STATIC mp_obj_t mp_lv_obj_scroll_by(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, int32_t, int32_t, lv_anim_enable_t))lv_func_ptr)(obj, x, y, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_by_mpobj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_by);
    
/* Reusing lv_obj_scroll_by for lv_obj_scroll_by_bounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_by_bounded_mpobj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_by_bounded);
    
/* Reusing lv_obj_scroll_by for lv_obj_scroll_to */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_mpobj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_to);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_to_x(lv_obj_t *obj, int32_t x, lv_anim_enable_t anim_en)
 */

STATIC mp_obj_t mp_lv_obj_scroll_to_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, lv_anim_enable_t))lv_func_ptr)(obj, x, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_x_mpobj, 3, mp_lv_obj_scroll_to_x, lv_obj_scroll_to_x);
    
/* Reusing lv_obj_scroll_to_x for lv_obj_scroll_to_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_y_mpobj, 3, mp_lv_obj_scroll_to_x, lv_obj_scroll_to_y);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_to_view(lv_obj_t *obj, lv_anim_enable_t anim_en)
 */

STATIC mp_obj_t mp_lv_obj_scroll_to_view(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_view_mpobj, 2, mp_lv_obj_scroll_to_view, lv_obj_scroll_to_view);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_scroll_to_view_recursive */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_view_recursive_mpobj, 2, mp_lv_obj_scroll_to_view, lv_obj_scroll_to_view_recursive);
    
/* Reusing lv_obj_is_layout_positioned for lv_obj_is_scrolling */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_scrolling_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_scrolling);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_update_snap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_update_snap_mpobj, 2, mp_lv_obj_scroll_to_view, lv_obj_update_snap);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_scrollbar_area(lv_obj_t *obj, lv_area_t *hor, lv_area_t *ver)
 */

STATIC mp_obj_t mp_lv_obj_get_scrollbar_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *hor = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_area_t *ver = mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_area_t *, lv_area_t *))lv_func_ptr)(obj, hor, ver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scrollbar_area_mpobj, 3, mp_lv_obj_get_scrollbar_area, lv_obj_get_scrollbar_area);
    
/* Reusing lv_obj_center for lv_obj_scrollbar_invalidate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scrollbar_invalidate_mpobj, 1, mp_lv_obj_center, lv_obj_scrollbar_invalidate);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_readjust_scroll */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_readjust_scroll_mpobj, 2, mp_lv_obj_scroll_to_view, lv_obj_readjust_scroll);
    

/*
 * Struct lv_style_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type();

STATIC inline void* mp_write_ptr_lv_style_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_t_type()));
    return (lv_style_t*)self->data;
}

#define mp_write_lv_style_t(struct_obj) *((lv_style_t*)mp_write_ptr_lv_style_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_style_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_style_t_type(), field);
}

#define mp_read_lv_style_t(field) mp_read_ptr_lv_style_t(copy_buffer(&field, sizeof(lv_style_t)))
#define mp_read_byref_lv_style_t(field) mp_read_ptr_lv_style_t(&field)

STATIC void mp_lv_style_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_style_t *data = (lv_style_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_values_and_props: dest[0] = ptr_to_mp((void*)data->values_and_props); break; // converting from void *;
            case MP_QSTR_has_group: dest[0] = mp_obj_new_int_from_uint(data->has_group); break; // converting from uint32_t;
            case MP_QSTR_prop_cnt: dest[0] = mp_obj_new_int_from_uint(data->prop_cnt); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_values_and_props: data->values_and_props = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_has_group: data->has_group = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_prop_cnt: data->prop_cnt = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_t");
}

STATIC const mp_obj_dict_t mp_lv_style_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_style_t_type,
    MP_QSTR_lv_style_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_style_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_style_t_attr,
    locals_dict, &mp_lv_style_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type()
{
    return &mp_lv_style_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_style(lv_obj_t *obj, const lv_style_t *style, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_add_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_style_t *style = (const lv_style_t *)mp_write_ptr_lv_style_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_style_t *, lv_style_selector_t))lv_func_ptr)(obj, style, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_style_mpobj, 3, mp_lv_obj_add_style, lv_obj_add_style);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_replace_style(lv_obj_t *obj, const lv_style_t *old_style, const lv_style_t *new_style, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_replace_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_style_t *old_style = (const lv_style_t *)mp_write_ptr_lv_style_t(mp_args[1]);
    const lv_style_t *new_style = (const lv_style_t *)mp_write_ptr_lv_style_t(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(lv_obj_t *, const lv_style_t *, const lv_style_t *, lv_style_selector_t))lv_func_ptr)(obj, old_style, new_style, selector);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_replace_style_mpobj, 4, mp_lv_obj_replace_style, lv_obj_replace_style);
    
/* Reusing lv_obj_add_style for lv_obj_remove_style */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_mpobj, 3, mp_lv_obj_add_style, lv_obj_remove_style);
    
/* Reusing lv_obj_center for lv_obj_remove_style_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_all_mpobj, 1, mp_lv_obj_center, lv_obj_remove_style_all);
    

/*
 * lvgl extension definition for:
 * void lv_obj_report_style_change(lv_style_t *style)
 */

STATIC mp_obj_t mp_lv_obj_report_style_change(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    ((void (*)(lv_style_t *))lv_func_ptr)(style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_report_style_change_mpobj, 1, mp_lv_obj_report_style_change, lv_obj_report_style_change);
    

/*
 * lvgl extension definition for:
 * void lv_obj_refresh_style(lv_obj_t *obj, lv_part_t part, lv_style_prop_t prop)
 */

STATIC mp_obj_t mp_lv_obj_refresh_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_part_t, lv_style_prop_t))lv_func_ptr)(obj, part, prop);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_style_mpobj, 3, mp_lv_obj_refresh_style, lv_obj_refresh_style);
    

/*
 * lvgl extension definition for:
 * void lv_obj_enable_style_refresh(bool en)
 */

STATIC mp_obj_t mp_lv_obj_enable_style_refresh(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    bool en = mp_obj_is_true(mp_args[0]);
    ((void (*)(bool))lv_func_ptr)(en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_enable_style_refresh_mpobj, 1, mp_lv_obj_enable_style_refresh, lv_obj_enable_style_refresh);
    

/*
 * Struct lv_style_value_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_value_t_type();

STATIC inline void* mp_write_ptr_lv_style_value_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_value_t_type()));
    return (lv_style_value_t*)self->data;
}

#define mp_write_lv_style_value_t(struct_obj) *((lv_style_value_t*)mp_write_ptr_lv_style_value_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_style_value_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_style_value_t_type(), field);
}

#define mp_read_lv_style_value_t(field) mp_read_ptr_lv_style_value_t(copy_buffer(&field, sizeof(lv_style_value_t)))
#define mp_read_byref_lv_style_value_t(field) mp_read_ptr_lv_style_value_t(&field)

STATIC void mp_lv_style_value_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_style_value_t *data = (lv_style_value_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_num: dest[0] = mp_obj_new_int(data->num); break; // converting from int32_t;
            case MP_QSTR_ptr: dest[0] = ptr_to_mp((void*)data->ptr); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_num: data->num = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ptr: data->ptr = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_value_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_value_t");
}

STATIC const mp_obj_dict_t mp_lv_style_value_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_style_value_t_type,
    MP_QSTR_lv_style_value_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_style_value_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_style_value_t_attr,
    locals_dict, &mp_lv_style_value_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_style_value_t_type()
{
    return &mp_lv_style_value_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_style_value_t lv_obj_get_style_prop(const lv_obj_t *obj, lv_part_t part, lv_style_prop_t prop)
 */

STATIC mp_obj_t mp_lv_obj_get_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_style_value_t _res = ((lv_style_value_t (*)(const lv_obj_t *, lv_part_t, lv_style_prop_t))lv_func_ptr)(obj, part, prop);
    return mp_read_lv_style_value_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_prop_mpobj, 3, mp_lv_obj_get_style_prop, lv_obj_get_style_prop);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_has_style_prop(const lv_obj_t *obj, lv_style_selector_t selector, lv_style_prop_t prop)
 */

STATIC mp_obj_t mp_lv_obj_has_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_style_selector_t, lv_style_prop_t))lv_func_ptr)(obj, selector, prop);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_style_prop_mpobj, 3, mp_lv_obj_has_style_prop, lv_obj_has_style_prop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_local_style_prop(lv_obj_t *obj, lv_style_prop_t prop, lv_style_value_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_value_t value = mp_write_lv_style_value_t(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_style_prop_t, lv_style_value_t, lv_style_selector_t))lv_func_ptr)(obj, prop, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_local_style_prop_mpobj, 4, mp_lv_obj_set_local_style_prop, lv_obj_set_local_style_prop);
    

/*
 * lvgl extension definition for:
 * lv_style_res_t lv_obj_get_local_style_prop(lv_obj_t *obj, lv_style_prop_t prop, lv_style_value_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_get_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_value_t *value = mp_write_ptr_lv_style_value_t(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_style_res_t _res = ((lv_style_res_t (*)(lv_obj_t *, lv_style_prop_t, lv_style_value_t *, lv_style_selector_t))lv_func_ptr)(obj, prop, value, selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_local_style_prop_mpobj, 4, mp_lv_obj_get_local_style_prop, lv_obj_get_local_style_prop);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_local_style_prop(lv_obj_t *obj, lv_style_prop_t prop, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_remove_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, lv_style_prop_t, lv_style_selector_t))lv_func_ptr)(obj, prop, selector);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_local_style_prop_mpobj, 3, mp_lv_obj_remove_local_style_prop, lv_obj_remove_local_style_prop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_fade_in(lv_obj_t *obj, uint32_t time, uint32_t delay)
 */

STATIC mp_obj_t mp_lv_obj_fade_in(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t))lv_func_ptr)(obj, time, delay);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_in_mpobj, 3, mp_lv_obj_fade_in, lv_obj_fade_in);
    
/* Reusing lv_obj_fade_in for lv_obj_fade_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_out_mpobj, 3, mp_lv_obj_fade_in, lv_obj_fade_out);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_min_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_min_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_max_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_max_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_height_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_min_height_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_min_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_max_height_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_max_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_length_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_length);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_y);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_align(lv_obj_t *obj, lv_align_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_align_mpobj, 3, mp_lv_obj_set_style_align, lv_obj_set_style_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_height_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_translate_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_translate_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_translate_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_translate_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_scale_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_scale_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_scale_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_scale_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_scale_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_scale_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_rotation_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_rotation);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_pivot_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_pivot_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_pivot_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_pivot_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_skew_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_skew_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_skew_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_skew_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_skew_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_skew_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_top_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_top);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_bottom_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_bottom);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_left_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_left);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_right_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_right);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_row_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_row);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_column_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_column);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_top_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_top);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_bottom_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_bottom);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_left_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_left);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_margin_right_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_margin_right);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_color(lv_obj_t *obj, lv_color_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t value = mp_write_lv_color_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_color_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_opa(lv_obj_t *obj, lv_opa_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_opa_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_grad_color);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_grad_dir(lv_obj_t *obj, lv_grad_dir_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_grad_dir_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_dir_mpobj, 3, mp_lv_obj_set_style_bg_grad_dir, lv_obj_set_style_bg_grad_dir);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_main_stop_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_bg_main_stop);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_stop_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_bg_grad_stop);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_main_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_main_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_main_opa);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_grad_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_grad_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_grad(lv_obj_t *obj, const lv_grad_dsc_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_grad_dsc_t *value = (const lv_grad_dsc_t *)mp_write_ptr_lv_grad_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_grad_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_mpobj, 3, mp_lv_obj_set_style_bg_grad, lv_obj_set_style_bg_grad);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_image_src(lv_obj_t *obj, const void *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_image_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *value = (const void *)mp_to_ptr(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const void *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_image_src_mpobj, 3, mp_lv_obj_set_style_bg_image_src, lv_obj_set_style_bg_image_src);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_image_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_image_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_bg_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_image_recolor_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_image_recolor);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_image_recolor_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_image_recolor_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_image_tiled(lv_obj_t *obj, bool value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_bg_image_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool value = mp_obj_is_true(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, bool, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_image_tiled_mpobj, 3, mp_lv_obj_set_style_bg_image_tiled, lv_obj_set_style_bg_image_tiled);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_border_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_border_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_border_width);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_border_side(lv_obj_t *obj, lv_border_side_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_border_side_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_side_mpobj, 3, mp_lv_obj_set_style_border_side, lv_obj_set_style_border_side);
    
/* Reusing lv_obj_set_style_bg_image_tiled for lv_obj_set_style_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_post_mpobj, 3, mp_lv_obj_set_style_bg_image_tiled, lv_obj_set_style_border_post);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_outline_width);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_outline_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_outline_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_pad_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_outline_pad);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_offset_x_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_offset_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_offset_y_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_offset_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_spread_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_spread);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_shadow_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_shadow_opa);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_image_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_image_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_image_recolor_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_image_recolor);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_image_recolor_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_image_recolor_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_dash_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_dash_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_dash_gap_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_dash_gap);
    
/* Reusing lv_obj_set_style_bg_image_tiled for lv_obj_set_style_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_rounded_mpobj, 3, mp_lv_obj_set_style_bg_image_tiled, lv_obj_set_style_line_rounded);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_line_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_line_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_width_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_arc_width);
    
/* Reusing lv_obj_set_style_bg_image_tiled for lv_obj_set_style_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_rounded_mpobj, 3, mp_lv_obj_set_style_bg_image_tiled, lv_obj_set_style_arc_rounded);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_arc_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_arc_opa);
    
/* Reusing lv_obj_set_style_bg_image_src for lv_obj_set_style_arc_image_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_image_src_mpobj, 3, mp_lv_obj_set_style_bg_image_src, lv_obj_set_style_arc_image_src);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_color_mpobj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_text_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_text_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_font(lv_obj_t *obj, const lv_font_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_font_t *value = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_font_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_font_mpobj, 3, mp_lv_obj_set_style_text_font, lv_obj_set_style_text_font);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_letter_space_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_text_letter_space);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_line_space_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_text_line_space);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_decor(lv_obj_t *obj, lv_text_decor_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_text_decor_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_decor_mpobj, 3, mp_lv_obj_set_style_text_decor, lv_obj_set_style_text_decor);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_align(lv_obj_t *obj, lv_text_align_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_text_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_align_mpobj, 3, mp_lv_obj_set_style_text_align, lv_obj_set_style_text_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_radius_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_radius);
    
/* Reusing lv_obj_set_style_bg_image_tiled for lv_obj_set_style_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_clip_corner_mpobj, 3, mp_lv_obj_set_style_bg_image_tiled, lv_obj_set_style_clip_corner);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_opa);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_opa_layered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_opa_layered_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_opa_layered);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_color_filter_dsc(lv_obj_t *obj, const lv_color_filter_dsc_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_color_filter_dsc_t *value = (const lv_color_filter_dsc_t *)mp_write_ptr_lv_color_filter_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_color_filter_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_color_filter_dsc_mpobj, 3, mp_lv_obj_set_style_color_filter_dsc, lv_obj_set_style_color_filter_dsc);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_color_filter_opa_mpobj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_color_filter_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_anim(lv_obj_t *obj, const lv_anim_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_anim_t *value = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_anim_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_anim_mpobj, 3, mp_lv_obj_set_style_anim, lv_obj_set_style_anim);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_anim_duration(lv_obj_t *obj, uint32_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_anim_duration(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t value = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_anim_duration_mpobj, 3, mp_lv_obj_set_style_anim_duration, lv_obj_set_style_anim_duration);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_transition(lv_obj_t *obj, const lv_style_transition_dsc_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_style_transition_dsc_t *value = (const lv_style_transition_dsc_t *)mp_write_ptr_lv_style_transition_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_style_transition_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transition_mpobj, 3, mp_lv_obj_set_style_transition, lv_obj_set_style_transition);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_blend_mode(lv_obj_t *obj, lv_blend_mode_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_blend_mode_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_blend_mode_mpobj, 3, mp_lv_obj_set_style_blend_mode, lv_obj_set_style_blend_mode);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_layout(lv_obj_t *obj, uint16_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t value = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_layout_mpobj, 3, mp_lv_obj_set_style_layout, lv_obj_set_style_layout);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_base_dir(lv_obj_t *obj, lv_base_dir_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_base_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_base_dir_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_base_dir_mpobj, 3, mp_lv_obj_set_style_base_dir, lv_obj_set_style_base_dir);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_flow(lv_obj_t *obj, lv_flex_flow_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_flow_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_flex_flow_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_flow_mpobj, 3, mp_lv_obj_set_style_flex_flow, lv_obj_set_style_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_main_place(lv_obj_t *obj, lv_flex_align_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_align_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_flex_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_main_place_mpobj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_main_place);
    
/* Reusing lv_obj_set_style_flex_main_place for lv_obj_set_style_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_cross_place_mpobj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_cross_place);
    
/* Reusing lv_obj_set_style_flex_main_place for lv_obj_set_style_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_track_place_mpobj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_track_place);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_grow(lv_obj_t *obj, uint8_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_grow_mpobj, 3, mp_lv_obj_set_style_flex_grow, lv_obj_set_style_flex_grow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_grid_column_dsc_array(lv_obj_t *obj, const int32_t *value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_grid_column_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const int32_t *value = (const int32_t *)mp_array_to_i32ptr(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const int32_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_column_dsc_array_mpobj, 3, mp_lv_obj_set_style_grid_column_dsc_array, lv_obj_set_style_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_grid_column_align(lv_obj_t *obj, lv_grid_align_t value, lv_style_selector_t selector)
 */

STATIC mp_obj_t mp_lv_obj_set_style_grid_column_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_column_align_mpobj, 3, mp_lv_obj_set_style_grid_column_align, lv_obj_set_style_grid_column_align);
    
/* Reusing lv_obj_set_style_grid_column_dsc_array for lv_obj_set_style_grid_row_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_row_dsc_array_mpobj, 3, mp_lv_obj_set_style_grid_column_dsc_array, lv_obj_set_style_grid_row_dsc_array);
    
/* Reusing lv_obj_set_style_grid_column_align for lv_obj_set_style_grid_row_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_row_align_mpobj, 3, mp_lv_obj_set_style_grid_column_align, lv_obj_set_style_grid_row_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_grid_cell_column_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_column_pos_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_grid_cell_column_pos);
    
/* Reusing lv_obj_set_style_grid_column_align for lv_obj_set_style_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_x_align_mpobj, 3, mp_lv_obj_set_style_grid_column_align, lv_obj_set_style_grid_cell_x_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_column_span_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_grid_cell_column_span);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_row_pos_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_grid_cell_row_pos);
    
/* Reusing lv_obj_set_style_grid_column_align for lv_obj_set_style_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_y_align_mpobj, 3, mp_lv_obj_set_style_grid_column_align, lv_obj_set_style_grid_cell_y_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_row_span_mpobj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_grid_cell_row_span);
    

/*
 * lvgl extension definition for:
 * lv_text_align_t lv_obj_calculate_style_text_align(const lv_obj_t *obj, lv_part_t part, const char *txt)
 */

STATIC mp_obj_t mp_lv_obj_calculate_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[2]);
    lv_text_align_t _res = ((lv_text_align_t (*)(const lv_obj_t *, lv_part_t, const char *))lv_func_ptr)(obj, part, txt);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_calculate_style_text_align_mpobj, 3, mp_lv_obj_calculate_style_text_align, lv_obj_calculate_style_text_align);
    

/*
 * lvgl extension definition for:
 * lv_opa_t lv_obj_get_style_opa_recursive(const lv_obj_t *obj, lv_part_t part)
 */

STATIC mp_obj_t mp_lv_obj_get_style_opa_recursive(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_opa_t _res = ((lv_opa_t (*)(const lv_obj_t *, lv_part_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_opa_recursive_mpobj, 2, mp_lv_obj_get_style_opa_recursive, lv_obj_get_style_opa_recursive);
    

/*
 * Struct lv_draw_task_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_task_t_type();

STATIC inline void* mp_write_ptr_lv_draw_task_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_task_t_type()));
    return (lv_draw_task_t*)self->data;
}

#define mp_write_lv_draw_task_t(struct_obj) *((lv_draw_task_t*)mp_write_ptr_lv_draw_task_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_task_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_task_t_type(), field);
}

#define mp_read_lv_draw_task_t(field) mp_read_ptr_lv_draw_task_t(copy_buffer(&field, sizeof(lv_draw_task_t)))
#define mp_read_byref_lv_draw_task_t(field) mp_read_ptr_lv_draw_task_t(&field)

STATIC void mp_lv_draw_task_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_task_t *data = (lv_draw_task_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_next: dest[0] = ptr_to_mp((void*)data->next); break; // converting from lv_draw_task_t *;
            case MP_QSTR_type: dest[0] = mp_obj_new_int(data->type); break; // converting from lv_draw_task_type_t;
            case MP_QSTR_area: dest[0] = mp_read_byref_lv_area_t(data->area); break; // converting from lv_area_t;
            case MP_QSTR__real_area: dest[0] = mp_read_byref_lv_area_t(data->_real_area); break; // converting from lv_area_t;
            case MP_QSTR_clip_area_original: dest[0] = mp_read_byref_lv_area_t(data->clip_area_original); break; // converting from lv_area_t;
            case MP_QSTR_clip_area: dest[0] = mp_read_byref_lv_area_t(data->clip_area); break; // converting from lv_area_t;
            case MP_QSTR_state: dest[0] = mp_obj_new_int(data->state); break; // converting from int;
            case MP_QSTR_draw_dsc: dest[0] = ptr_to_mp((void*)data->draw_dsc); break; // converting from void *;
            case MP_QSTR_preferred_draw_unit_id: dest[0] = mp_obj_new_int_from_uint(data->preferred_draw_unit_id); break; // converting from uint8_t;
            case MP_QSTR_preference_score: dest[0] = mp_obj_new_int_from_uint(data->preference_score); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_next: data->next = (void*)mp_to_ptr(dest[1]); break; // converting to lv_draw_task_t *;
                case MP_QSTR_type: data->type = (int)mp_obj_get_int(dest[1]); break; // converting to lv_draw_task_type_t;
                case MP_QSTR_area: data->area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR__real_area: data->_real_area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_clip_area_original: data->clip_area_original = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_clip_area: data->clip_area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_state: data->state = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_draw_dsc: data->draw_dsc = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_preferred_draw_unit_id: data->preferred_draw_unit_id = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_preference_score: data->preference_score = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_task_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_task_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_task_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_task_t_type,
    MP_QSTR_lv_draw_task_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_task_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_task_t_attr,
    locals_dict, &mp_lv_draw_task_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_task_t_type()
{
    return &mp_lv_draw_task_t_type;
}
    

/*
 * Struct lv_layer_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_layer_t_type();

STATIC inline void* mp_write_ptr_lv_layer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_layer_t_type()));
    return (lv_layer_t*)self->data;
}

#define mp_write_lv_layer_t(struct_obj) *((lv_layer_t*)mp_write_ptr_lv_layer_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_layer_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_layer_t_type(), field);
}

#define mp_read_lv_layer_t(field) mp_read_ptr_lv_layer_t(copy_buffer(&field, sizeof(lv_layer_t)))
#define mp_read_byref_lv_layer_t(field) mp_read_ptr_lv_layer_t(&field)

STATIC void mp_lv_layer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_layer_t *data = (lv_layer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_draw_buf: dest[0] = mp_read_ptr_lv_draw_buf_t((void*)data->draw_buf); break; // converting from lv_draw_buf_t *;
            case MP_QSTR_buf_area: dest[0] = mp_read_byref_lv_area_t(data->buf_area); break; // converting from lv_area_t;
            case MP_QSTR_color_format: dest[0] = mp_obj_new_int_from_uint(data->color_format); break; // converting from lv_color_format_t;
            case MP_QSTR__clip_area: dest[0] = mp_read_byref_lv_area_t(data->_clip_area); break; // converting from lv_area_t;
            case MP_QSTR_draw_task_head: dest[0] = mp_read_ptr_lv_draw_task_t((void*)data->draw_task_head); break; // converting from lv_draw_task_t *;
            case MP_QSTR_parent: dest[0] = ptr_to_mp((void*)data->parent); break; // converting from lv_layer_t *;
            case MP_QSTR_next: dest[0] = ptr_to_mp((void*)data->next); break; // converting from lv_layer_t *;
            case MP_QSTR_all_tasks_added: dest[0] = convert_to_bool(data->all_tasks_added); break; // converting from bool;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_draw_buf: data->draw_buf = (void*)mp_write_ptr_lv_draw_buf_t(dest[1]); break; // converting to lv_draw_buf_t *;
                case MP_QSTR_buf_area: data->buf_area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_color_format: data->color_format = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_color_format_t;
                case MP_QSTR__clip_area: data->_clip_area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_draw_task_head: data->draw_task_head = (void*)mp_write_ptr_lv_draw_task_t(dest[1]); break; // converting to lv_draw_task_t *;
                case MP_QSTR_parent: data->parent = (void*)mp_to_ptr(dest[1]); break; // converting to lv_layer_t *;
                case MP_QSTR_next: data->next = (void*)mp_to_ptr(dest[1]); break; // converting to lv_layer_t *;
                case MP_QSTR_all_tasks_added: data->all_tasks_added = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_layer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_layer_t");
}

STATIC const mp_obj_dict_t mp_lv_layer_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_layer_t_type,
    MP_QSTR_lv_layer_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_layer_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_layer_t_attr,
    locals_dict, &mp_lv_layer_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_layer_t_type()
{
    return &mp_lv_layer_t_type;
}
    

/*
 * Struct lv_draw_dsc_base_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_dsc_base_t_type();

STATIC inline void* mp_write_ptr_lv_draw_dsc_base_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_dsc_base_t_type()));
    return (lv_draw_dsc_base_t*)self->data;
}

#define mp_write_lv_draw_dsc_base_t(struct_obj) *((lv_draw_dsc_base_t*)mp_write_ptr_lv_draw_dsc_base_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_dsc_base_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_dsc_base_t_type(), field);
}

#define mp_read_lv_draw_dsc_base_t(field) mp_read_ptr_lv_draw_dsc_base_t(copy_buffer(&field, sizeof(lv_draw_dsc_base_t)))
#define mp_read_byref_lv_draw_dsc_base_t(field) mp_read_ptr_lv_draw_dsc_base_t(&field)

STATIC void mp_lv_draw_dsc_base_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_dsc_base_t *data = (lv_draw_dsc_base_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_obj: dest[0] = lv_to_mp((void*)data->obj); break; // converting from lv_obj_t *;
            case MP_QSTR_part: dest[0] = mp_obj_new_int_from_uint(data->part); break; // converting from uint32_t;
            case MP_QSTR_id1: dest[0] = mp_obj_new_int_from_uint(data->id1); break; // converting from uint32_t;
            case MP_QSTR_id2: dest[0] = mp_obj_new_int_from_uint(data->id2); break; // converting from uint32_t;
            case MP_QSTR_layer: dest[0] = mp_read_ptr_lv_layer_t((void*)data->layer); break; // converting from lv_layer_t *;
            case MP_QSTR_dsc_size: dest[0] = mp_obj_new_int_from_uint(data->dsc_size); break; // converting from size_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_obj: data->obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_part: data->part = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_id1: data->id1 = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_id2: data->id2 = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_layer: data->layer = (void*)mp_write_ptr_lv_layer_t(dest[1]); break; // converting to lv_layer_t *;
                case MP_QSTR_dsc_size: data->dsc_size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_dsc_base_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_dsc_base_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_dsc_base_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_dsc_base_t_type,
    MP_QSTR_lv_draw_dsc_base_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_dsc_base_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_dsc_base_t_attr,
    locals_dict, &mp_lv_draw_dsc_base_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_dsc_base_t_type()
{
    return &mp_lv_draw_dsc_base_t_type;
}
    

/*
 * Struct lv_draw_rect_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_rect_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_rect_dsc_t_type()));
    return (lv_draw_rect_dsc_t*)self->data;
}

#define mp_write_lv_draw_rect_dsc_t(struct_obj) *((lv_draw_rect_dsc_t*)mp_write_ptr_lv_draw_rect_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_rect_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_rect_dsc_t_type(), field);
}

#define mp_read_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(copy_buffer(&field, sizeof(lv_draw_rect_dsc_t)))
#define mp_read_byref_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(&field)

STATIC void mp_lv_draw_rect_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_rect_dsc_t *data = (lv_draw_rect_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_grad: dest[0] = mp_read_byref_lv_grad_dsc_t(data->bg_grad); break; // converting from lv_grad_dsc_t;
            case MP_QSTR_bg_image_src: dest[0] = ptr_to_mp((void*)data->bg_image_src); break; // converting from void *;
            case MP_QSTR_bg_image_symbol_font: dest[0] = ptr_to_mp((void*)data->bg_image_symbol_font); break; // converting from void *;
            case MP_QSTR_bg_image_recolor: dest[0] = mp_read_byref_lv_color_t(data->bg_image_recolor); break; // converting from lv_color_t;
            case MP_QSTR_bg_image_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_image_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_image_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_image_recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_image_tiled: dest[0] = mp_obj_new_int_from_uint(data->bg_image_tiled); break; // converting from uint8_t;
            case MP_QSTR_border_color: dest[0] = mp_read_byref_lv_color_t(data->border_color); break; // converting from lv_color_t;
            case MP_QSTR_border_width: dest[0] = mp_obj_new_int(data->border_width); break; // converting from int32_t;
            case MP_QSTR_border_opa: dest[0] = mp_obj_new_int_from_uint(data->border_opa); break; // converting from lv_opa_t;
            case MP_QSTR_border_side: dest[0] = mp_obj_new_int_from_uint(data->border_side); break; // converting from lv_border_side_t;
            case MP_QSTR_border_post: dest[0] = mp_obj_new_int_from_uint(data->border_post); break; // converting from uint8_t;
            case MP_QSTR_outline_color: dest[0] = mp_read_byref_lv_color_t(data->outline_color); break; // converting from lv_color_t;
            case MP_QSTR_outline_width: dest[0] = mp_obj_new_int(data->outline_width); break; // converting from int32_t;
            case MP_QSTR_outline_pad: dest[0] = mp_obj_new_int(data->outline_pad); break; // converting from int32_t;
            case MP_QSTR_outline_opa: dest[0] = mp_obj_new_int_from_uint(data->outline_opa); break; // converting from lv_opa_t;
            case MP_QSTR_shadow_color: dest[0] = mp_read_byref_lv_color_t(data->shadow_color); break; // converting from lv_color_t;
            case MP_QSTR_shadow_width: dest[0] = mp_obj_new_int(data->shadow_width); break; // converting from int32_t;
            case MP_QSTR_shadow_offset_x: dest[0] = mp_obj_new_int(data->shadow_offset_x); break; // converting from int32_t;
            case MP_QSTR_shadow_offset_y: dest[0] = mp_obj_new_int(data->shadow_offset_y); break; // converting from int32_t;
            case MP_QSTR_shadow_spread: dest[0] = mp_obj_new_int(data->shadow_spread); break; // converting from int32_t;
            case MP_QSTR_shadow_opa: dest[0] = mp_obj_new_int_from_uint(data->shadow_opa); break; // converting from lv_opa_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_grad: data->bg_grad = mp_write_lv_grad_dsc_t(dest[1]); break; // converting to lv_grad_dsc_t;
                case MP_QSTR_bg_image_src: data->bg_image_src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_bg_image_symbol_font: data->bg_image_symbol_font = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_bg_image_recolor: data->bg_image_recolor = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_image_opa: data->bg_image_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_image_recolor_opa: data->bg_image_recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_image_tiled: data->bg_image_tiled = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_border_color: data->border_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_border_width: data->border_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_border_opa: data->border_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_border_side: data->border_side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_border_side_t;
                case MP_QSTR_border_post: data->border_post = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_outline_color: data->outline_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_outline_width: data->outline_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_outline_pad: data->outline_pad = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_outline_opa: data->outline_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_shadow_color: data->shadow_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_shadow_width: data->shadow_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_shadow_offset_x: data->shadow_offset_x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_shadow_offset_y: data->shadow_offset_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_shadow_spread: data->shadow_spread = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_shadow_opa: data->shadow_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_rect_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_rect_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_rect_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_rect_dsc_t_type,
    MP_QSTR_lv_draw_rect_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_rect_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_rect_dsc_t_attr,
    locals_dict, &mp_lv_draw_rect_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type()
{
    return &mp_lv_draw_rect_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_rect_dsc(lv_obj_t *obj, uint32_t part, lv_draw_rect_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_obj_init_draw_rect_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_draw_rect_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_rect_dsc_mpobj, 3, mp_lv_obj_init_draw_rect_dsc, lv_obj_init_draw_rect_dsc);
    

/*
 * Struct lv_draw_label_hint_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type();

STATIC inline void* mp_write_ptr_lv_draw_label_hint_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_hint_t_type()));
    return (lv_draw_label_hint_t*)self->data;
}

#define mp_write_lv_draw_label_hint_t(struct_obj) *((lv_draw_label_hint_t*)mp_write_ptr_lv_draw_label_hint_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_hint_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_hint_t_type(), field);
}

#define mp_read_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(copy_buffer(&field, sizeof(lv_draw_label_hint_t)))
#define mp_read_byref_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(&field)

STATIC void mp_lv_draw_label_hint_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_label_hint_t *data = (lv_draw_label_hint_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_line_start: dest[0] = mp_obj_new_int(data->line_start); break; // converting from int32_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from int32_t;
            case MP_QSTR_coord_y: dest[0] = mp_obj_new_int(data->coord_y); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_line_start: data->line_start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y: data->y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_coord_y: data->coord_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_hint_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_hint_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_hint_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_label_hint_t_type,
    MP_QSTR_lv_draw_label_hint_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_label_hint_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_label_hint_t_attr,
    locals_dict, &mp_lv_draw_label_hint_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type()
{
    return &mp_lv_draw_label_hint_t_type;
}
    

/*
 * Struct lv_draw_label_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_label_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_dsc_t_type()));
    return (lv_draw_label_dsc_t*)self->data;
}

#define mp_write_lv_draw_label_dsc_t(struct_obj) *((lv_draw_label_dsc_t*)mp_write_ptr_lv_draw_label_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_dsc_t_type(), field);
}

#define mp_read_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(copy_buffer(&field, sizeof(lv_draw_label_dsc_t)))
#define mp_read_byref_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(&field)

STATIC void mp_lv_draw_label_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_label_dsc_t *data = (lv_draw_label_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_text: dest[0] = convert_to_str((void*)data->text); break; // converting from char *;
            case MP_QSTR_font: dest[0] = mp_read_ptr_lv_font_t((void*)data->font); break; // converting from lv_font_t *;
            case MP_QSTR_sel_start: dest[0] = mp_obj_new_int_from_uint(data->sel_start); break; // converting from uint32_t;
            case MP_QSTR_sel_end: dest[0] = mp_obj_new_int_from_uint(data->sel_end); break; // converting from uint32_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_sel_color: dest[0] = mp_read_byref_lv_color_t(data->sel_color); break; // converting from lv_color_t;
            case MP_QSTR_sel_bg_color: dest[0] = mp_read_byref_lv_color_t(data->sel_bg_color); break; // converting from lv_color_t;
            case MP_QSTR_line_space: dest[0] = mp_obj_new_int(data->line_space); break; // converting from int32_t;
            case MP_QSTR_letter_space: dest[0] = mp_obj_new_int(data->letter_space); break; // converting from int32_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from int32_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from int32_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_bidi_dir: dest[0] = mp_obj_new_int_from_uint(data->bidi_dir); break; // converting from lv_base_dir_t;
            case MP_QSTR_align: dest[0] = mp_obj_new_int_from_uint(data->align); break; // converting from lv_text_align_t;
            case MP_QSTR_flag: dest[0] = mp_obj_new_int_from_uint(data->flag); break; // converting from lv_text_flag_t;
            case MP_QSTR_decor: dest[0] = mp_obj_new_int_from_uint(data->decor); break; // converting from lv_text_decor_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_text_local: dest[0] = mp_obj_new_int_from_uint(data->text_local); break; // converting from uint8_t;
            case MP_QSTR_hint: dest[0] = mp_read_ptr_lv_draw_label_hint_t((void*)data->hint); break; // converting from lv_draw_label_hint_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_text: data->text = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_font: data->font = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_sel_start: data->sel_start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_sel_end: data->sel_end = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_color: data->sel_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_bg_color: data->sel_bg_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_line_space: data->line_space = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_letter_space: data->letter_space = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bidi_dir: data->bidi_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_base_dir_t;
                case MP_QSTR_align: data->align = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_align_t;
                case MP_QSTR_flag: data->flag = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_flag_t;
                case MP_QSTR_decor: data->decor = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_decor_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_text_local: data->text_local = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_hint: data->hint = (void*)mp_write_ptr_lv_draw_label_hint_t(dest[1]); break; // converting to lv_draw_label_hint_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_label_dsc_t_type,
    MP_QSTR_lv_draw_label_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_label_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_label_dsc_t_attr,
    locals_dict, &mp_lv_draw_label_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type()
{
    return &mp_lv_draw_label_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_label_dsc(lv_obj_t *obj, uint32_t part, lv_draw_label_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_obj_init_draw_label_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_label_dsc_t *draw_dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_draw_label_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_label_dsc_mpobj, 3, mp_lv_obj_init_draw_label_dsc, lv_obj_init_draw_label_dsc);
    

/*
 * Struct lv_color32_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color32_t_type();

STATIC inline void* mp_write_ptr_lv_color32_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color32_t_type()));
    return (lv_color32_t*)self->data;
}

#define mp_write_lv_color32_t(struct_obj) *((lv_color32_t*)mp_write_ptr_lv_color32_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_color32_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_color32_t_type(), field);
}

#define mp_read_lv_color32_t(field) mp_read_ptr_lv_color32_t(copy_buffer(&field, sizeof(lv_color32_t)))
#define mp_read_byref_lv_color32_t(field) mp_read_ptr_lv_color32_t(&field)

STATIC void mp_lv_color32_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_color32_t *data = (lv_color32_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blue: dest[0] = mp_obj_new_int_from_uint(data->blue); break; // converting from uint8_t;
            case MP_QSTR_green: dest[0] = mp_obj_new_int_from_uint(data->green); break; // converting from uint8_t;
            case MP_QSTR_red: dest[0] = mp_obj_new_int_from_uint(data->red); break; // converting from uint8_t;
            case MP_QSTR_alpha: dest[0] = mp_obj_new_int_from_uint(data->alpha); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blue: data->blue = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_green: data->green = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_red: data->red = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_alpha: data->alpha = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color32_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color32_t");
}

STATIC const mp_obj_dict_t mp_lv_color32_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_color32_t_type,
    MP_QSTR_lv_color32_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_color32_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_color32_t_attr,
    locals_dict, &mp_lv_color32_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_color32_t_type()
{
    return &mp_lv_color32_t_type;
}
    

/*
 * Struct lv_draw_image_sup_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_image_sup_t_type();

STATIC inline void* mp_write_ptr_lv_draw_image_sup_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_image_sup_t_type()));
    return (lv_draw_image_sup_t*)self->data;
}

#define mp_write_lv_draw_image_sup_t(struct_obj) *((lv_draw_image_sup_t*)mp_write_ptr_lv_draw_image_sup_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_image_sup_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_image_sup_t_type(), field);
}

#define mp_read_lv_draw_image_sup_t(field) mp_read_ptr_lv_draw_image_sup_t(copy_buffer(&field, sizeof(lv_draw_image_sup_t)))
#define mp_read_byref_lv_draw_image_sup_t(field) mp_read_ptr_lv_draw_image_sup_t(&field)

STATIC void mp_lv_draw_image_sup_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_image_sup_t *data = (lv_draw_image_sup_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_alpha_color: dest[0] = mp_read_byref_lv_color_t(data->alpha_color); break; // converting from lv_color_t;
            case MP_QSTR_palette: dest[0] = mp_read_ptr_lv_color32_t((void*)data->palette); break; // converting from lv_color32_t *;
            case MP_QSTR_palette_size: dest[0] = mp_obj_new_int_from_uint(data->palette_size); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_alpha_color: data->alpha_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_palette: data->palette = (void*)mp_write_ptr_lv_color32_t(dest[1]); break; // converting to lv_color32_t *;
                case MP_QSTR_palette_size: data->palette_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_image_sup_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_image_sup_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_image_sup_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_image_sup_t_type,
    MP_QSTR_lv_draw_image_sup_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_image_sup_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_image_sup_t_attr,
    locals_dict, &mp_lv_draw_image_sup_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_image_sup_t_type()
{
    return &mp_lv_draw_image_sup_t_type;
}
    

/*
 * Struct lv_draw_image_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_image_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_image_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_image_dsc_t_type()));
    return (lv_draw_image_dsc_t*)self->data;
}

#define mp_write_lv_draw_image_dsc_t(struct_obj) *((lv_draw_image_dsc_t*)mp_write_ptr_lv_draw_image_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_image_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_image_dsc_t_type(), field);
}

#define mp_read_lv_draw_image_dsc_t(field) mp_read_ptr_lv_draw_image_dsc_t(copy_buffer(&field, sizeof(lv_draw_image_dsc_t)))
#define mp_read_byref_lv_draw_image_dsc_t(field) mp_read_ptr_lv_draw_image_dsc_t(&field)

STATIC void mp_lv_draw_image_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_image_dsc_t *data = (lv_draw_image_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_image_header_t(data->header); break; // converting from lv_image_header_t;
            case MP_QSTR_rotation: dest[0] = mp_obj_new_int(data->rotation); break; // converting from int32_t;
            case MP_QSTR_scale_x: dest[0] = mp_obj_new_int(data->scale_x); break; // converting from int32_t;
            case MP_QSTR_scale_y: dest[0] = mp_obj_new_int(data->scale_y); break; // converting from int32_t;
            case MP_QSTR_skew_x: dest[0] = mp_obj_new_int(data->skew_x); break; // converting from int32_t;
            case MP_QSTR_skew_y: dest[0] = mp_obj_new_int(data->skew_y); break; // converting from int32_t;
            case MP_QSTR_pivot: dest[0] = mp_read_byref_lv_point_t(data->pivot); break; // converting from lv_point_t;
            case MP_QSTR_recolor: dest[0] = mp_read_byref_lv_color_t(data->recolor); break; // converting from lv_color_t;
            case MP_QSTR_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_antialias: dest[0] = mp_obj_new_int_from_uint(data->antialias); break; // converting from uint16_t;
            case MP_QSTR_tile: dest[0] = mp_obj_new_int_from_uint(data->tile); break; // converting from uint16_t;
            case MP_QSTR_sup: dest[0] = mp_read_ptr_lv_draw_image_sup_t((void*)data->sup); break; // converting from lv_draw_image_sup_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_header: data->header = mp_write_lv_image_header_t(dest[1]); break; // converting to lv_image_header_t;
                case MP_QSTR_rotation: data->rotation = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_scale_x: data->scale_x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_scale_y: data->scale_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_skew_x: data->skew_x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_skew_y: data->skew_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_pivot: data->pivot = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_recolor: data->recolor = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_recolor_opa: data->recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_antialias: data->antialias = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tile: data->tile = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_sup: data->sup = (void*)mp_write_ptr_lv_draw_image_sup_t(dest[1]); break; // converting to lv_draw_image_sup_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_image_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_image_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_image_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_image_dsc_t_type,
    MP_QSTR_lv_draw_image_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_image_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_image_dsc_t_attr,
    locals_dict, &mp_lv_draw_image_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_image_dsc_t_type()
{
    return &mp_lv_draw_image_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_image_dsc(lv_obj_t *obj, uint32_t part, lv_draw_image_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_obj_init_draw_image_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_image_dsc_t *draw_dsc = mp_write_ptr_lv_draw_image_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_draw_image_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_image_dsc_mpobj, 3, mp_lv_obj_init_draw_image_dsc, lv_obj_init_draw_image_dsc);
    

/*
 * Struct lv_point_precise_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_point_precise_t_type();

STATIC inline void* mp_write_ptr_lv_point_precise_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_point_precise_t_type()));
    return (lv_point_precise_t*)self->data;
}

#define mp_write_lv_point_precise_t(struct_obj) *((lv_point_precise_t*)mp_write_ptr_lv_point_precise_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_point_precise_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_point_precise_t_type(), field);
}

#define mp_read_lv_point_precise_t(field) mp_read_ptr_lv_point_precise_t(copy_buffer(&field, sizeof(lv_point_precise_t)))
#define mp_read_byref_lv_point_precise_t(field) mp_read_ptr_lv_point_precise_t(&field)

STATIC void mp_lv_point_precise_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_point_precise_t *data = (lv_point_precise_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x: dest[0] = mp_obj_new_int(data->x); break; // converting from lv_value_precise_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from lv_value_precise_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x: data->x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to lv_value_precise_t;
                case MP_QSTR_y: data->y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to lv_value_precise_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_point_precise_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_point_precise_t");
}

STATIC const mp_obj_dict_t mp_lv_point_precise_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_point_precise_t_type,
    MP_QSTR_lv_point_precise_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_point_precise_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_point_precise_t_attr,
    locals_dict, &mp_lv_point_precise_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_point_precise_t_type()
{
    return &mp_lv_point_precise_t_type;
}
    

/*
 * Struct lv_draw_line_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_line_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_line_dsc_t_type()));
    return (lv_draw_line_dsc_t*)self->data;
}

#define mp_write_lv_draw_line_dsc_t(struct_obj) *((lv_draw_line_dsc_t*)mp_write_ptr_lv_draw_line_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_line_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_line_dsc_t_type(), field);
}

#define mp_read_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(copy_buffer(&field, sizeof(lv_draw_line_dsc_t)))
#define mp_read_byref_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(&field)

STATIC void mp_lv_draw_line_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_line_dsc_t *data = (lv_draw_line_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_p1: dest[0] = mp_read_byref_lv_point_precise_t(data->p1); break; // converting from lv_point_precise_t;
            case MP_QSTR_p2: dest[0] = mp_read_byref_lv_point_precise_t(data->p2); break; // converting from lv_point_precise_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from int32_t;
            case MP_QSTR_dash_width: dest[0] = mp_obj_new_int(data->dash_width); break; // converting from int32_t;
            case MP_QSTR_dash_gap: dest[0] = mp_obj_new_int(data->dash_gap); break; // converting from int32_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_round_start: dest[0] = mp_obj_new_int_from_uint(data->round_start); break; // converting from uint8_t;
            case MP_QSTR_round_end: dest[0] = mp_obj_new_int_from_uint(data->round_end); break; // converting from uint8_t;
            case MP_QSTR_raw_end: dest[0] = mp_obj_new_int_from_uint(data->raw_end); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_p1: data->p1 = mp_write_lv_point_precise_t(dest[1]); break; // converting to lv_point_precise_t;
                case MP_QSTR_p2: data->p2 = mp_write_lv_point_precise_t(dest[1]); break; // converting to lv_point_precise_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_dash_width: data->dash_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_dash_gap: data->dash_gap = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_round_start: data->round_start = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_round_end: data->round_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_raw_end: data->raw_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_line_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_line_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_line_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_line_dsc_t_type,
    MP_QSTR_lv_draw_line_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_line_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_line_dsc_t_attr,
    locals_dict, &mp_lv_draw_line_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type()
{
    return &mp_lv_draw_line_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_line_dsc(lv_obj_t *obj, uint32_t part, lv_draw_line_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_obj_init_draw_line_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_line_dsc_t *draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_draw_line_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_line_dsc_mpobj, 3, mp_lv_obj_init_draw_line_dsc, lv_obj_init_draw_line_dsc);
    

/*
 * Struct lv_draw_arc_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_arc_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_arc_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_arc_dsc_t_type()));
    return (lv_draw_arc_dsc_t*)self->data;
}

#define mp_write_lv_draw_arc_dsc_t(struct_obj) *((lv_draw_arc_dsc_t*)mp_write_ptr_lv_draw_arc_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_arc_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_arc_dsc_t_type(), field);
}

#define mp_read_lv_draw_arc_dsc_t(field) mp_read_ptr_lv_draw_arc_dsc_t(copy_buffer(&field, sizeof(lv_draw_arc_dsc_t)))
#define mp_read_byref_lv_draw_arc_dsc_t(field) mp_read_ptr_lv_draw_arc_dsc_t(&field)

STATIC void mp_lv_draw_arc_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_arc_dsc_t *data = (lv_draw_arc_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from int32_t;
            case MP_QSTR_start_angle: dest[0] = mp_obj_new_int(data->start_angle); break; // converting from lv_value_precise_t;
            case MP_QSTR_end_angle: dest[0] = mp_obj_new_int(data->end_angle); break; // converting from lv_value_precise_t;
            case MP_QSTR_center: dest[0] = mp_read_byref_lv_point_t(data->center); break; // converting from lv_point_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int_from_uint(data->radius); break; // converting from uint16_t;
            case MP_QSTR_img_src: dest[0] = ptr_to_mp((void*)data->img_src); break; // converting from void *;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_rounded: dest[0] = mp_obj_new_int_from_uint(data->rounded); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_start_angle: data->start_angle = (int32_t)mp_obj_get_int(dest[1]); break; // converting to lv_value_precise_t;
                case MP_QSTR_end_angle: data->end_angle = (int32_t)mp_obj_get_int(dest[1]); break; // converting to lv_value_precise_t;
                case MP_QSTR_center: data->center = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_radius: data->radius = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_img_src: data->img_src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_rounded: data->rounded = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_arc_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_arc_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_arc_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_arc_dsc_t_type,
    MP_QSTR_lv_draw_arc_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_arc_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_arc_dsc_t_attr,
    locals_dict, &mp_lv_draw_arc_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_arc_dsc_t_type()
{
    return &mp_lv_draw_arc_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_arc_dsc(lv_obj_t *obj, uint32_t part, lv_draw_arc_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_obj_init_draw_arc_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_arc_dsc_t *draw_dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_draw_arc_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_arc_dsc_mpobj, 3, mp_lv_obj_init_draw_arc_dsc, lv_obj_init_draw_arc_dsc);
    

/*
 * lvgl extension definition for:
 * int32_t lv_obj_calculate_ext_draw_size(lv_obj_t *obj, uint32_t part)
 */

STATIC mp_obj_t mp_lv_obj_calculate_ext_draw_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_calculate_ext_draw_size_mpobj, 2, mp_lv_obj_calculate_ext_draw_size, lv_obj_calculate_ext_draw_size);
    
/* Reusing lv_obj_center for lv_obj_refresh_ext_draw_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_ext_draw_size_mpobj, 1, mp_lv_obj_center, lv_obj_refresh_ext_draw_size);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_class_create_obj(const lv_obj_class_t *class_p, lv_obj_t *parent)
 */

STATIC mp_obj_t mp_lv_obj_class_create_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[0]);
    lv_obj_t *parent = mp_to_lv(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_class_t *, lv_obj_t *))lv_func_ptr)(class_p, parent);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_class_create_obj_mpobj, 2, mp_lv_obj_class_create_obj, lv_obj_class_create_obj);
    
/* Reusing lv_obj_center for lv_obj_class_init_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_class_init_obj_mpobj, 1, mp_lv_obj_center, lv_obj_class_init_obj);
    
/* Reusing lv_obj_refr_size for lv_obj_is_editable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_editable_mpobj, 1, mp_lv_obj_refr_size, lv_obj_is_editable);
    
/* Reusing lv_obj_refr_size for lv_obj_is_group_def */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_group_def_mpobj, 1, mp_lv_obj_refr_size, lv_obj_is_group_def);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_obj_send_event(lv_obj_t *obj, lv_event_code_t event_code, void *param)
 */

STATIC mp_obj_t mp_lv_obj_send_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_event_code_t event_code = (int)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_obj_t *, lv_event_code_t, void *))lv_func_ptr)(obj, event_code, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_send_event_mpobj, 3, mp_lv_obj_send_event, lv_obj_send_event);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_obj_event_base(const lv_obj_class_t *class_p, lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_obj_event_base(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[0]);
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(const lv_obj_class_t *, lv_event_t *))lv_func_ptr)(class_p, e);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_event_base_mpobj, 2, mp_lv_obj_event_base, lv_obj_event_base);
    

/*
 * Callback function lv_obj_add_event_cb_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_obj_add_event_cb_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_add_event_cb_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_obj_add_event_cb(lv_obj_t *obj, lv_event_cb_t event_cb, lv_event_code_t filter, void *user_data)
 */

STATIC mp_obj_t mp_lv_obj_add_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_add_event_cb_event_cb_callback, MP_QSTR_lv_obj_add_event_cb_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_event_code_t filter = (int)mp_obj_get_int(mp_args[2]);
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *, lv_event_cb_t, lv_event_code_t, void *))lv_func_ptr)(obj, event_cb, filter, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_event_cb_mpobj, 4, mp_lv_obj_add_event_cb, lv_obj_add_event_cb);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_obj_get_event_count(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_event_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_event_count_mpobj, 1, mp_lv_obj_get_event_count, lv_obj_get_event_count);
    
#define funcptr_lv_event_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_event_cb_t(lv_event_t *e)
 */

STATIC mp_obj_t mp_funcptr_lv_event_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    ((void (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_event_cb_t_mpobj, 1, mp_funcptr_lv_event_cb_t, funcptr_lv_event_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_event_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_event_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_event_dsc_t_cb_callback'
 * lv_event_cb_t cb
 */
    

/*
 * Struct lv_event_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_event_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_event_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_event_dsc_t_type()));
    return (lv_event_dsc_t*)self->data;
}

#define mp_write_lv_event_dsc_t(struct_obj) *((lv_event_dsc_t*)mp_write_ptr_lv_event_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_event_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_event_dsc_t_type(), field);
}

#define mp_read_lv_event_dsc_t(field) mp_read_ptr_lv_event_dsc_t(copy_buffer(&field, sizeof(lv_event_dsc_t)))
#define mp_read_byref_lv_event_dsc_t(field) mp_read_ptr_lv_event_dsc_t(&field)

STATIC void mp_lv_event_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_event_dsc_t *data = (lv_event_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_event_cb_t_mpobj, data->cb, NULL ,MP_QSTR_lv_event_dsc_t_cb, NULL); break; // converting from callback lv_event_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_filter: dest[0] = mp_obj_new_int_from_uint(data->filter); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_event_dsc_t_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_event_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_filter: data->filter = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_event_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_event_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_event_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_event_dsc_t_type,
    MP_QSTR_lv_event_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_event_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_event_dsc_t_attr,
    locals_dict, &mp_lv_event_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_event_dsc_t_type()
{
    return &mp_lv_event_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_event_dsc_t *lv_obj_get_event_dsc(lv_obj_t *obj, uint32_t index)
 */

STATIC mp_obj_t mp_lv_obj_get_event_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_event_dsc_t * _res = ((lv_event_dsc_t *(*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, index);
    return mp_read_ptr_lv_event_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_event_dsc_mpobj, 2, mp_lv_obj_get_event_dsc, lv_obj_get_event_dsc);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_event(lv_obj_t *obj, uint32_t index)
 */

STATIC mp_obj_t mp_lv_obj_remove_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, index);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_mpobj, 2, mp_lv_obj_remove_event, lv_obj_remove_event);
    

/*
 * Callback function lv_obj_t_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_obj_t_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * bool lv_obj_remove_event_cb(lv_obj_t *obj, lv_event_cb_t event_cb)
 */

STATIC mp_obj_t mp_lv_obj_remove_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_t_event_cb_callback, MP_QSTR_lv_obj_t_event_cb, &obj->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    bool _res = ((bool (*)(lv_obj_t *, lv_event_cb_t))lv_func_ptr)(obj, event_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_cb_mpobj, 2, mp_lv_obj_remove_event_cb, lv_obj_remove_event_cb);
    

/*
 * Callback function lv_obj_remove_event_cb_with_user_data_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_obj_remove_event_cb_with_user_data_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_remove_event_cb_with_user_data_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * uint32_t lv_obj_remove_event_cb_with_user_data(lv_obj_t *obj, lv_event_cb_t event_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_obj_remove_event_cb_with_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_remove_event_cb_with_user_data_event_cb_callback, MP_QSTR_lv_obj_remove_event_cb_with_user_data_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *, lv_event_cb_t, void *))lv_func_ptr)(obj, event_cb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_cb_with_user_data_mpobj, 3, mp_lv_obj_remove_event_cb_with_user_data, lv_obj_remove_event_cb_with_user_data);
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_flag(lv_obj_t *obj, lv_obj_flag_t f)
 */

STATIC mp_obj_t mp_lv_obj_add_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_flag_t f = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_flag_t))lv_func_ptr)(obj, f);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_flag_mpobj, 2, mp_lv_obj_add_flag, lv_obj_add_flag);
    
/* Reusing lv_obj_add_flag for lv_obj_remove_flag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_flag_mpobj, 2, mp_lv_obj_add_flag, lv_obj_remove_flag);
    

/*
 * lvgl extension definition for:
 * void lv_obj_update_flag(lv_obj_t *obj, lv_obj_flag_t f, bool v)
 */

STATIC mp_obj_t mp_lv_obj_update_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_flag_t f = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool v = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_flag_t, bool))lv_func_ptr)(obj, f, v);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_update_flag_mpobj, 3, mp_lv_obj_update_flag, lv_obj_update_flag);
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_state(lv_obj_t *obj, lv_state_t state)
 */

STATIC mp_obj_t mp_lv_obj_add_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_state_t))lv_func_ptr)(obj, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_state_mpobj, 2, mp_lv_obj_add_state, lv_obj_add_state);
    
/* Reusing lv_obj_add_state for lv_obj_remove_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_state_mpobj, 2, mp_lv_obj_add_state, lv_obj_remove_state);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_state(lv_obj_t *obj, lv_state_t state, bool v)
 */

STATIC mp_obj_t mp_lv_obj_set_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool v = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_state_t, bool))lv_func_ptr)(obj, state, v);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_state_mpobj, 3, mp_lv_obj_set_state, lv_obj_set_state);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_has_flag(const lv_obj_t *obj, lv_obj_flag_t f)
 */

STATIC mp_obj_t mp_lv_obj_has_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_obj_flag_t f = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_obj_flag_t))lv_func_ptr)(obj, f);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_flag_mpobj, 2, mp_lv_obj_has_flag, lv_obj_has_flag);
    
/* Reusing lv_obj_has_flag for lv_obj_has_flag_any */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_flag_any_mpobj, 2, mp_lv_obj_has_flag, lv_obj_has_flag_any);
    

/*
 * lvgl extension definition for:
 * lv_state_t lv_obj_get_state(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_state_t _res = ((lv_state_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_state_mpobj, 1, mp_lv_obj_get_state, lv_obj_get_state);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_has_state(const lv_obj_t *obj, lv_state_t state)
 */

STATIC mp_obj_t mp_lv_obj_has_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_state_t))lv_func_ptr)(obj, state);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_state_mpobj, 2, mp_lv_obj_has_state, lv_obj_has_state);
    

/*
 * Struct lv_ll_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type();

STATIC inline void* mp_write_ptr_lv_ll_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ll_t_type()));
    return (lv_ll_t*)self->data;
}

#define mp_write_lv_ll_t(struct_obj) *((lv_ll_t*)mp_write_ptr_lv_ll_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_ll_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_ll_t_type(), field);
}

#define mp_read_lv_ll_t(field) mp_read_ptr_lv_ll_t(copy_buffer(&field, sizeof(lv_ll_t)))
#define mp_read_byref_lv_ll_t(field) mp_read_ptr_lv_ll_t(&field)

STATIC void mp_lv_ll_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_ll_t *data = (lv_ll_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_n_size: dest[0] = mp_obj_new_int_from_uint(data->n_size); break; // converting from uint32_t;
            case MP_QSTR_head: dest[0] = ptr_to_mp((void*)data->head); break; // converting from lv_ll_node_t *;
            case MP_QSTR_tail: dest[0] = ptr_to_mp((void*)data->tail); break; // converting from lv_ll_node_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_n_size: data->n_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_head: data->head = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                case MP_QSTR_tail: data->tail = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ll_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ll_t");
}

STATIC const mp_obj_dict_t mp_lv_ll_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_ll_t_type,
    MP_QSTR_lv_ll_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_ll_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_ll_t_attr,
    locals_dict, &mp_lv_ll_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type()
{
    return &mp_lv_ll_t_type;
}
    
#define funcptr_lv_group_focus_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_group_focus_cb_t(lv_group_t *)
 */

STATIC mp_obj_t mp_funcptr_lv_group_focus_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_group_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_group_focus_cb_t_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, funcptr_lv_group_focus_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_group_focus_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_group_t_focus_cb_callback(lv_group_t *);
#define funcptr_lv_group_edge_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_group_edge_cb_t(lv_group_t *, bool)
 */

STATIC mp_obj_t mp_funcptr_lv_group_edge_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *arg0 = mp_to_ptr(mp_args[0]);
    bool arg1 = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_group_t *, bool))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_group_edge_cb_t_mpobj, 2, mp_funcptr_lv_group_edge_cb_t, funcptr_lv_group_edge_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_group_edge_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_group_edge_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_group_t_edge_cb_callback(lv_group_t *, bool);

/*
 * Struct lv_group_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type();

STATIC inline void* mp_write_ptr_lv_group_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_group_t_type()));
    return (lv_group_t*)self->data;
}

#define mp_write_lv_group_t(struct_obj) *((lv_group_t*)mp_write_ptr_lv_group_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_group_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_group_t_type(), field);
}

#define mp_read_lv_group_t(field) mp_read_ptr_lv_group_t(copy_buffer(&field, sizeof(lv_group_t)))
#define mp_read_byref_lv_group_t(field) mp_read_ptr_lv_group_t(&field)

STATIC void mp_lv_group_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_group_t *data = (lv_group_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_obj_ll: dest[0] = mp_read_byref_lv_ll_t(data->obj_ll); break; // converting from lv_ll_t;
            case MP_QSTR_obj_focus: dest[0] = ptr_to_mp((void*)data->obj_focus); break; // converting from lv_obj_t **;
            case MP_QSTR_focus_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_mpobj, data->focus_cb, lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, data->user_data); break; // converting from callback lv_group_focus_cb_t;
            case MP_QSTR_edge_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_group_edge_cb_t_mpobj, data->edge_cb, lv_group_t_edge_cb_callback ,MP_QSTR_lv_group_t_edge_cb, data->user_data); break; // converting from callback lv_group_edge_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_frozen: dest[0] = mp_obj_new_int_from_uint(data->frozen); break; // converting from uint8_t;
            case MP_QSTR_editing: dest[0] = mp_obj_new_int_from_uint(data->editing); break; // converting from uint8_t;
            case MP_QSTR_refocus_policy: dest[0] = mp_obj_new_int_from_uint(data->refocus_policy); break; // converting from uint8_t;
            case MP_QSTR_wrap: dest[0] = mp_obj_new_int_from_uint(data->wrap); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_obj_ll: data->obj_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_obj_focus: data->obj_focus = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_t **;
                case MP_QSTR_focus_cb: data->focus_cb = mp_lv_callback(dest[1], lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_group_focus_cb_t;
                case MP_QSTR_edge_cb: data->edge_cb = mp_lv_callback(dest[1], lv_group_t_edge_cb_callback ,MP_QSTR_lv_group_t_edge_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_group_edge_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_frozen: data->frozen = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_editing: data->editing = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_refocus_policy: data->refocus_policy = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_wrap: data->wrap = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_group_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_group_t");
}

STATIC const mp_obj_dict_t mp_lv_group_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_group_t_type,
    MP_QSTR_lv_group_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_group_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_group_t_attr,
    locals_dict, &mp_lv_group_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type()
{
    return &mp_lv_group_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_obj_get_group(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_group_t * _res = ((lv_group_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_group_mpobj, 1, mp_lv_obj_get_group, lv_obj_get_group);
    
/* Reusing lv_obj_center for lv_obj_allocate_spec_attr */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_allocate_spec_attr_mpobj, 1, mp_lv_obj_center, lv_obj_allocate_spec_attr);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_check_type(const lv_obj_t *obj, const lv_obj_class_t *class_p)
 */

STATIC mp_obj_t mp_lv_obj_check_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_obj_class_t *class_p = (const lv_obj_class_t *)mp_write_ptr_lv_obj_class_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, const lv_obj_class_t *))lv_func_ptr)(obj, class_p);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_check_type_mpobj, 2, mp_lv_obj_check_type, lv_obj_check_type);
    
/* Reusing lv_obj_check_type for lv_obj_has_class */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_class_mpobj, 2, mp_lv_obj_check_type, lv_obj_has_class);
    

/*
 * lvgl extension definition for:
 * const lv_obj_class_t *lv_obj_get_class(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_get_class(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_obj_class_t * _res = ((const lv_obj_class_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_obj_class_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_class_mpobj, 1, mp_lv_obj_get_class, lv_obj_get_class);
    
/* Reusing lv_obj_is_layout_positioned for lv_obj_is_valid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_valid_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_valid);
    

/*
 * lvgl extension definition for:
 * void lv_obj_redraw(lv_layer_t *layer, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_obj_redraw(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_layer_t *, lv_obj_t *))lv_func_ptr)(layer, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_redraw_mpobj, 2, mp_lv_obj_redraw, lv_obj_redraw);
    

/*
 * Struct lv_subject_value_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_subject_value_t_type();

STATIC inline void* mp_write_ptr_lv_subject_value_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_subject_value_t_type()));
    return (lv_subject_value_t*)self->data;
}

#define mp_write_lv_subject_value_t(struct_obj) *((lv_subject_value_t*)mp_write_ptr_lv_subject_value_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_subject_value_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_subject_value_t_type(), field);
}

#define mp_read_lv_subject_value_t(field) mp_read_ptr_lv_subject_value_t(copy_buffer(&field, sizeof(lv_subject_value_t)))
#define mp_read_byref_lv_subject_value_t(field) mp_read_ptr_lv_subject_value_t(&field)

STATIC void mp_lv_subject_value_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_subject_value_t *data = (lv_subject_value_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_num: dest[0] = mp_obj_new_int(data->num); break; // converting from int32_t;
            case MP_QSTR_pointer: dest[0] = ptr_to_mp((void*)data->pointer); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_num: data->num = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_pointer: data->pointer = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_subject_value_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_subject_value_t");
}

STATIC const mp_obj_dict_t mp_lv_subject_value_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_subject_value_t_type,
    MP_QSTR_lv_subject_value_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_subject_value_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_subject_value_t_attr,
    locals_dict, &mp_lv_subject_value_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_subject_value_t_type()
{
    return &mp_lv_subject_value_t_type;
}
    

/*
 * Struct lv_subject_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_subject_t_type();

STATIC inline void* mp_write_ptr_lv_subject_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_subject_t_type()));
    return (lv_subject_t*)self->data;
}

#define mp_write_lv_subject_t(struct_obj) *((lv_subject_t*)mp_write_ptr_lv_subject_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_subject_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_subject_t_type(), field);
}

#define mp_read_lv_subject_t(field) mp_read_ptr_lv_subject_t(copy_buffer(&field, sizeof(lv_subject_t)))
#define mp_read_byref_lv_subject_t(field) mp_read_ptr_lv_subject_t(&field)

STATIC void mp_lv_subject_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_subject_t *data = (lv_subject_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_subs_ll: dest[0] = mp_read_byref_lv_ll_t(data->subs_ll); break; // converting from lv_ll_t;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from uint32_t;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            case MP_QSTR_value: dest[0] = mp_read_byref_lv_subject_value_t(data->value); break; // converting from lv_subject_value_t;
            case MP_QSTR_prev_value: dest[0] = mp_read_byref_lv_subject_value_t(data->prev_value); break; // converting from lv_subject_value_t;
            case MP_QSTR_notify_restart_query: dest[0] = mp_obj_new_int_from_uint(data->notify_restart_query); break; // converting from uint32_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_subs_ll: data->subs_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_type: data->type = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_value: data->value = mp_write_lv_subject_value_t(dest[1]); break; // converting to lv_subject_value_t;
                case MP_QSTR_prev_value: data->prev_value = mp_write_lv_subject_value_t(dest[1]); break; // converting to lv_subject_value_t;
                case MP_QSTR_notify_restart_query: data->notify_restart_query = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_subject_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_subject_t");
}

STATIC const mp_obj_dict_t mp_lv_subject_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_subject_t_type,
    MP_QSTR_lv_subject_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_subject_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_subject_t_attr,
    locals_dict, &mp_lv_subject_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_subject_t_type()
{
    return &mp_lv_subject_t_type;
}
    
#define funcptr_lv_observer_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_observer_cb_t(lv_observer_t *observer, lv_subject_t *subject)
 */

STATIC mp_obj_t mp_funcptr_lv_observer_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_observer_t *observer = mp_to_ptr(mp_args[0]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[1]);
    ((void (*)(lv_observer_t *, lv_subject_t *))lv_func_ptr)(observer, subject);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_observer_cb_t_mpobj, 2, mp_funcptr_lv_observer_cb_t, funcptr_lv_observer_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_observer_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_observer_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_observer_t_cb_callback(lv_observer_t *observer, lv_subject_t *subject);

/*
 * Struct lv_observer_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_observer_t_type();

STATIC inline void* mp_write_ptr_lv_observer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_observer_t_type()));
    return (lv_observer_t*)self->data;
}

#define mp_write_lv_observer_t(struct_obj) *((lv_observer_t*)mp_write_ptr_lv_observer_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_observer_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_observer_t_type(), field);
}

#define mp_read_lv_observer_t(field) mp_read_ptr_lv_observer_t(copy_buffer(&field, sizeof(lv_observer_t)))
#define mp_read_byref_lv_observer_t(field) mp_read_ptr_lv_observer_t(&field)

STATIC void mp_lv_observer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_observer_t *data = (lv_observer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_subject: dest[0] = mp_read_ptr_lv_subject_t((void*)data->subject); break; // converting from lv_subject_t *;
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_observer_cb_t_mpobj, data->cb, lv_observer_t_cb_callback ,MP_QSTR_lv_observer_t_cb, data->user_data); break; // converting from callback lv_observer_cb_t;
            case MP_QSTR_target: dest[0] = ptr_to_mp((void*)data->target); break; // converting from void *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_auto_free_user_data: dest[0] = mp_obj_new_int_from_uint(data->auto_free_user_data); break; // converting from uint32_t;
            case MP_QSTR_notified: dest[0] = mp_obj_new_int_from_uint(data->notified); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_subject: data->subject = (void*)mp_write_ptr_lv_subject_t(dest[1]); break; // converting to lv_subject_t *;
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], lv_observer_t_cb_callback ,MP_QSTR_lv_observer_t_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_observer_cb_t;
                case MP_QSTR_target: data->target = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_auto_free_user_data: data->auto_free_user_data = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_notified: data->notified = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_observer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_observer_t");
}

STATIC const mp_obj_dict_t mp_lv_observer_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_observer_t_type,
    MP_QSTR_lv_observer_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_observer_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_observer_t_attr,
    locals_dict, &mp_lv_observer_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_observer_t_type()
{
    return &mp_lv_observer_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_observer_t *lv_obj_bind_flag_if_eq(lv_obj_t *obj, lv_subject_t *subject, lv_obj_flag_t flag, int32_t ref_value)
 */

STATIC mp_obj_t mp_lv_obj_bind_flag_if_eq(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[1]);
    lv_obj_flag_t flag = (uint32_t)mp_obj_get_int(mp_args[2]);
    int32_t ref_value = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_obj_t *, lv_subject_t *, lv_obj_flag_t, int32_t))lv_func_ptr)(obj, subject, flag, ref_value);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_bind_flag_if_eq_mpobj, 4, mp_lv_obj_bind_flag_if_eq, lv_obj_bind_flag_if_eq);
    
/* Reusing lv_obj_bind_flag_if_eq for lv_obj_bind_flag_if_not_eq */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_bind_flag_if_not_eq_mpobj, 4, mp_lv_obj_bind_flag_if_eq, lv_obj_bind_flag_if_not_eq);
    

/*
 * lvgl extension definition for:
 * lv_observer_t *lv_obj_bind_state_if_eq(lv_obj_t *obj, lv_subject_t *subject, lv_state_t state, int32_t ref_value)
 */

STATIC mp_obj_t mp_lv_obj_bind_state_if_eq(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[1]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[2]);
    int32_t ref_value = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_obj_t *, lv_subject_t *, lv_state_t, int32_t))lv_func_ptr)(obj, subject, state, ref_value);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_bind_state_if_eq_mpobj, 4, mp_lv_obj_bind_state_if_eq, lv_obj_bind_state_if_eq);
    
/* Reusing lv_obj_bind_state_if_eq for lv_obj_bind_state_if_not_eq */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_bind_state_if_not_eq_mpobj, 4, mp_lv_obj_bind_state_if_eq, lv_obj_bind_state_if_not_eq);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_create(lv_obj_t *parent)
 */

STATIC mp_obj_t mp_lv_obj_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *))lv_func_ptr)(parent);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_create_mpobj, 1, mp_lv_obj_create, lv_obj_create);
    

/*
 * lvgl obj object definitions
 */
    

STATIC const mp_rom_map_elem_t obj_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_center), MP_ROM_PTR(&mp_lv_obj_center_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_selector_state), MP_ROM_PTR(&mp_lv_obj_style_get_selector_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_selector_part), MP_ROM_PTR(&mp_lv_obj_style_get_selector_part_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_width), MP_ROM_PTR(&mp_lv_obj_get_style_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_min_width), MP_ROM_PTR(&mp_lv_obj_get_style_min_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_max_width), MP_ROM_PTR(&mp_lv_obj_get_style_max_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_height), MP_ROM_PTR(&mp_lv_obj_get_style_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_min_height), MP_ROM_PTR(&mp_lv_obj_get_style_min_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_max_height), MP_ROM_PTR(&mp_lv_obj_get_style_max_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_length), MP_ROM_PTR(&mp_lv_obj_get_style_length_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_x), MP_ROM_PTR(&mp_lv_obj_get_style_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_y), MP_ROM_PTR(&mp_lv_obj_get_style_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_align), MP_ROM_PTR(&mp_lv_obj_get_style_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_width), MP_ROM_PTR(&mp_lv_obj_get_style_transform_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_height), MP_ROM_PTR(&mp_lv_obj_get_style_transform_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_translate_x), MP_ROM_PTR(&mp_lv_obj_get_style_translate_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_translate_y), MP_ROM_PTR(&mp_lv_obj_get_style_translate_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_scale_x), MP_ROM_PTR(&mp_lv_obj_get_style_transform_scale_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_scale_y), MP_ROM_PTR(&mp_lv_obj_get_style_transform_scale_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_rotation), MP_ROM_PTR(&mp_lv_obj_get_style_transform_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_pivot_x), MP_ROM_PTR(&mp_lv_obj_get_style_transform_pivot_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_pivot_y), MP_ROM_PTR(&mp_lv_obj_get_style_transform_pivot_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_skew_x), MP_ROM_PTR(&mp_lv_obj_get_style_transform_skew_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_skew_y), MP_ROM_PTR(&mp_lv_obj_get_style_transform_skew_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_top), MP_ROM_PTR(&mp_lv_obj_get_style_pad_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_pad_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_left), MP_ROM_PTR(&mp_lv_obj_get_style_pad_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_right), MP_ROM_PTR(&mp_lv_obj_get_style_pad_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_row), MP_ROM_PTR(&mp_lv_obj_get_style_pad_row_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_column), MP_ROM_PTR(&mp_lv_obj_get_style_pad_column_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_top), MP_ROM_PTR(&mp_lv_obj_get_style_margin_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_margin_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_left), MP_ROM_PTR(&mp_lv_obj_get_style_margin_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_right), MP_ROM_PTR(&mp_lv_obj_get_style_margin_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_main_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_main_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_main_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_src), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_recolor_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_recolor_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_image_tiled), MP_ROM_PTR(&mp_lv_obj_get_style_bg_image_tiled_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_color), MP_ROM_PTR(&mp_lv_obj_get_style_border_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_border_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_opa), MP_ROM_PTR(&mp_lv_obj_get_style_border_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_width), MP_ROM_PTR(&mp_lv_obj_get_style_border_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_side), MP_ROM_PTR(&mp_lv_obj_get_style_border_side_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_post), MP_ROM_PTR(&mp_lv_obj_get_style_border_post_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_width), MP_ROM_PTR(&mp_lv_obj_get_style_outline_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_color), MP_ROM_PTR(&mp_lv_obj_get_style_outline_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_outline_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_opa), MP_ROM_PTR(&mp_lv_obj_get_style_outline_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_pad), MP_ROM_PTR(&mp_lv_obj_get_style_outline_pad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_width), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_offset_x), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_offset_y), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_spread), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_spread_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_color), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_opa), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_opa), MP_ROM_PTR(&mp_lv_obj_get_style_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_recolor_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_image_recolor_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_gap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_rounded), MP_ROM_PTR(&mp_lv_obj_get_style_line_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_color), MP_ROM_PTR(&mp_lv_obj_get_style_line_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_line_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_opa), MP_ROM_PTR(&mp_lv_obj_get_style_line_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_width), MP_ROM_PTR(&mp_lv_obj_get_style_arc_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_rounded), MP_ROM_PTR(&mp_lv_obj_get_style_arc_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_color), MP_ROM_PTR(&mp_lv_obj_get_style_arc_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_arc_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_opa), MP_ROM_PTR(&mp_lv_obj_get_style_arc_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_image_src), MP_ROM_PTR(&mp_lv_obj_get_style_arc_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_color), MP_ROM_PTR(&mp_lv_obj_get_style_text_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_text_color_filtered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_opa), MP_ROM_PTR(&mp_lv_obj_get_style_text_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_font), MP_ROM_PTR(&mp_lv_obj_get_style_text_font_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_letter_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_letter_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_line_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_line_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_decor), MP_ROM_PTR(&mp_lv_obj_get_style_text_decor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_align), MP_ROM_PTR(&mp_lv_obj_get_style_text_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_radius), MP_ROM_PTR(&mp_lv_obj_get_style_radius_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_clip_corner), MP_ROM_PTR(&mp_lv_obj_get_style_clip_corner_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_opa), MP_ROM_PTR(&mp_lv_obj_get_style_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_opa_layered), MP_ROM_PTR(&mp_lv_obj_get_style_opa_layered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_color_filter_dsc), MP_ROM_PTR(&mp_lv_obj_get_style_color_filter_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_color_filter_opa), MP_ROM_PTR(&mp_lv_obj_get_style_color_filter_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_anim), MP_ROM_PTR(&mp_lv_obj_get_style_anim_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_anim_duration), MP_ROM_PTR(&mp_lv_obj_get_style_anim_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition), MP_ROM_PTR(&mp_lv_obj_get_style_transition_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_blend_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_layout), MP_ROM_PTR(&mp_lv_obj_get_style_layout_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_base_dir), MP_ROM_PTR(&mp_lv_obj_get_style_base_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_flow), MP_ROM_PTR(&mp_lv_obj_get_style_flex_flow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_main_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_main_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_cross_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_cross_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_track_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_track_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_grow), MP_ROM_PTR(&mp_lv_obj_get_style_flex_grow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_obj_get_style_grid_column_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_column_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_column_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_obj_get_style_grid_row_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_row_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_row_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_column_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_x_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_x_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_column_span), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_column_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_row_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_y_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_y_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_row_span), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_row_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_all), MP_ROM_PTR(&mp_lv_obj_set_style_pad_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_hor), MP_ROM_PTR(&mp_lv_obj_set_style_pad_hor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_ver), MP_ROM_PTR(&mp_lv_obj_set_style_pad_ver_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_all), MP_ROM_PTR(&mp_lv_obj_set_style_margin_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_hor), MP_ROM_PTR(&mp_lv_obj_set_style_margin_hor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_ver), MP_ROM_PTR(&mp_lv_obj_set_style_margin_ver_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_gap), MP_ROM_PTR(&mp_lv_obj_set_style_pad_gap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_size), MP_ROM_PTR(&mp_lv_obj_set_style_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_scale), MP_ROM_PTR(&mp_lv_obj_set_style_transform_scale_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_space_left), MP_ROM_PTR(&mp_lv_obj_get_style_space_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_space_right), MP_ROM_PTR(&mp_lv_obj_get_style_space_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_space_top), MP_ROM_PTR(&mp_lv_obj_get_style_space_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_space_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_space_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_scale_x_safe), MP_ROM_PTR(&mp_lv_obj_get_style_transform_scale_x_safe_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_scale_y_safe), MP_ROM_PTR(&mp_lv_obj_get_style_transform_scale_y_safe_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_obj_set_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_obj_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move_foreground), MP_ROM_PTR(&mp_lv_obj_move_foreground_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move_background), MP_ROM_PTR(&mp_lv_obj_move_background_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_flow), MP_ROM_PTR(&mp_lv_obj_set_flex_flow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_align), MP_ROM_PTR(&mp_lv_obj_set_flex_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_grow), MP_ROM_PTR(&mp_lv_obj_set_flex_grow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_grid_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_align), MP_ROM_PTR(&mp_lv_obj_set_grid_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell), MP_ROM_PTR(&mp_lv_obj_set_grid_cell_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_obj_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_obj_clean_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_delayed), MP_ROM_PTR(&mp_lv_obj_delete_delayed_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_anim_completed_cb), MP_ROM_PTR(&mp_lv_obj_delete_anim_completed_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_async), MP_ROM_PTR(&mp_lv_obj_delete_async_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_parent), MP_ROM_PTR(&mp_lv_obj_set_parent_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_swap), MP_ROM_PTR(&mp_lv_obj_swap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move_to_index), MP_ROM_PTR(&mp_lv_obj_move_to_index_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_screen), MP_ROM_PTR(&mp_lv_obj_get_screen_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_display), MP_ROM_PTR(&mp_lv_obj_get_display_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_parent), MP_ROM_PTR(&mp_lv_obj_get_parent_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_child), MP_ROM_PTR(&mp_lv_obj_get_child_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_by_type), MP_ROM_PTR(&mp_lv_obj_get_child_by_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_sibling), MP_ROM_PTR(&mp_lv_obj_get_sibling_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_sibling_by_type), MP_ROM_PTR(&mp_lv_obj_get_sibling_by_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_count), MP_ROM_PTR(&mp_lv_obj_get_child_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_count_by_type), MP_ROM_PTR(&mp_lv_obj_get_child_count_by_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_index), MP_ROM_PTR(&mp_lv_obj_get_index_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_index_by_type), MP_ROM_PTR(&mp_lv_obj_get_index_by_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tree_walk), MP_ROM_PTR(&mp_lv_obj_tree_walk_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_dump_tree), MP_ROM_PTR(&mp_lv_obj_dump_tree_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pos), MP_ROM_PTR(&mp_lv_obj_set_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_x), MP_ROM_PTR(&mp_lv_obj_set_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_y), MP_ROM_PTR(&mp_lv_obj_set_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_obj_set_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refr_size), MP_ROM_PTR(&mp_lv_obj_refr_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_obj_set_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_obj_set_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_content_width), MP_ROM_PTR(&mp_lv_obj_set_content_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_content_height), MP_ROM_PTR(&mp_lv_obj_set_content_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_obj_set_layout_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_layout_positioned), MP_ROM_PTR(&mp_lv_obj_is_layout_positioned_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mark_layout_as_dirty), MP_ROM_PTR(&mp_lv_obj_mark_layout_as_dirty_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_update_layout), MP_ROM_PTR(&mp_lv_obj_update_layout_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_obj_set_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_align), MP_ROM_PTR(&mp_lv_obj_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_align_to), MP_ROM_PTR(&mp_lv_obj_align_to_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_coords), MP_ROM_PTR(&mp_lv_obj_get_coords_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_x), MP_ROM_PTR(&mp_lv_obj_get_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_x2), MP_ROM_PTR(&mp_lv_obj_get_x2_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_y), MP_ROM_PTR(&mp_lv_obj_get_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_y2), MP_ROM_PTR(&mp_lv_obj_get_y2_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_aligned), MP_ROM_PTR(&mp_lv_obj_get_x_aligned_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_aligned), MP_ROM_PTR(&mp_lv_obj_get_y_aligned_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_obj_get_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_obj_get_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_width), MP_ROM_PTR(&mp_lv_obj_get_content_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_height), MP_ROM_PTR(&mp_lv_obj_get_content_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_coords), MP_ROM_PTR(&mp_lv_obj_get_content_coords_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_width), MP_ROM_PTR(&mp_lv_obj_get_self_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_height), MP_ROM_PTR(&mp_lv_obj_get_self_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_self_size), MP_ROM_PTR(&mp_lv_obj_refresh_self_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refr_pos), MP_ROM_PTR(&mp_lv_obj_refr_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move_to), MP_ROM_PTR(&mp_lv_obj_move_to_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move_children_by), MP_ROM_PTR(&mp_lv_obj_move_children_by_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_transform_point), MP_ROM_PTR(&mp_lv_obj_transform_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_transformed_area), MP_ROM_PTR(&mp_lv_obj_get_transformed_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate_area), MP_ROM_PTR(&mp_lv_obj_invalidate_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate), MP_ROM_PTR(&mp_lv_obj_invalidate_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_area_is_visible), MP_ROM_PTR(&mp_lv_obj_area_is_visible_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_visible), MP_ROM_PTR(&mp_lv_obj_is_visible_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_click_area), MP_ROM_PTR(&mp_lv_obj_set_ext_click_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_click_area), MP_ROM_PTR(&mp_lv_obj_get_click_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_hit_test), MP_ROM_PTR(&mp_lv_obj_hit_test_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_obj_set_scrollbar_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_dir), MP_ROM_PTR(&mp_lv_obj_set_scroll_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_snap_x), MP_ROM_PTR(&mp_lv_obj_set_scroll_snap_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_snap_y), MP_ROM_PTR(&mp_lv_obj_set_scroll_snap_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_mode), MP_ROM_PTR(&mp_lv_obj_get_scrollbar_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_dir), MP_ROM_PTR(&mp_lv_obj_get_scroll_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_snap_x), MP_ROM_PTR(&mp_lv_obj_get_scroll_snap_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_snap_y), MP_ROM_PTR(&mp_lv_obj_get_scroll_snap_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_x), MP_ROM_PTR(&mp_lv_obj_get_scroll_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_y), MP_ROM_PTR(&mp_lv_obj_get_scroll_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_top), MP_ROM_PTR(&mp_lv_obj_get_scroll_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_bottom), MP_ROM_PTR(&mp_lv_obj_get_scroll_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_left), MP_ROM_PTR(&mp_lv_obj_get_scroll_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_right), MP_ROM_PTR(&mp_lv_obj_get_scroll_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_end), MP_ROM_PTR(&mp_lv_obj_get_scroll_end_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_by), MP_ROM_PTR(&mp_lv_obj_scroll_by_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_by_bounded), MP_ROM_PTR(&mp_lv_obj_scroll_by_bounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to), MP_ROM_PTR(&mp_lv_obj_scroll_to_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_x), MP_ROM_PTR(&mp_lv_obj_scroll_to_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_y), MP_ROM_PTR(&mp_lv_obj_scroll_to_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_view), MP_ROM_PTR(&mp_lv_obj_scroll_to_view_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_view_recursive), MP_ROM_PTR(&mp_lv_obj_scroll_to_view_recursive_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_scrolling), MP_ROM_PTR(&mp_lv_obj_is_scrolling_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_update_snap), MP_ROM_PTR(&mp_lv_obj_update_snap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_area), MP_ROM_PTR(&mp_lv_obj_get_scrollbar_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_scrollbar_invalidate), MP_ROM_PTR(&mp_lv_obj_scrollbar_invalidate_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_readjust_scroll), MP_ROM_PTR(&mp_lv_obj_readjust_scroll_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_style), MP_ROM_PTR(&mp_lv_obj_add_style_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_replace_style), MP_ROM_PTR(&mp_lv_obj_replace_style_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style), MP_ROM_PTR(&mp_lv_obj_remove_style_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style_all), MP_ROM_PTR(&mp_lv_obj_remove_style_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_report_style_change), MP_ROM_PTR(&mp_lv_obj_report_style_change_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_style), MP_ROM_PTR(&mp_lv_obj_refresh_style_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_enable_style_refresh), MP_ROM_PTR(&mp_lv_obj_enable_style_refresh_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_prop), MP_ROM_PTR(&mp_lv_obj_get_style_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_style_prop), MP_ROM_PTR(&mp_lv_obj_has_style_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_local_style_prop), MP_ROM_PTR(&mp_lv_obj_set_local_style_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_local_style_prop), MP_ROM_PTR(&mp_lv_obj_get_local_style_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_local_style_prop), MP_ROM_PTR(&mp_lv_obj_remove_local_style_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fade_in), MP_ROM_PTR(&mp_lv_obj_fade_in_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fade_out), MP_ROM_PTR(&mp_lv_obj_fade_out_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_width), MP_ROM_PTR(&mp_lv_obj_set_style_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_min_width), MP_ROM_PTR(&mp_lv_obj_set_style_min_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_max_width), MP_ROM_PTR(&mp_lv_obj_set_style_max_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_height), MP_ROM_PTR(&mp_lv_obj_set_style_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_min_height), MP_ROM_PTR(&mp_lv_obj_set_style_min_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_max_height), MP_ROM_PTR(&mp_lv_obj_set_style_max_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_length), MP_ROM_PTR(&mp_lv_obj_set_style_length_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_x), MP_ROM_PTR(&mp_lv_obj_set_style_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_y), MP_ROM_PTR(&mp_lv_obj_set_style_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_align), MP_ROM_PTR(&mp_lv_obj_set_style_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_width), MP_ROM_PTR(&mp_lv_obj_set_style_transform_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_height), MP_ROM_PTR(&mp_lv_obj_set_style_transform_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_translate_x), MP_ROM_PTR(&mp_lv_obj_set_style_translate_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_translate_y), MP_ROM_PTR(&mp_lv_obj_set_style_translate_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_scale_x), MP_ROM_PTR(&mp_lv_obj_set_style_transform_scale_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_scale_y), MP_ROM_PTR(&mp_lv_obj_set_style_transform_scale_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_rotation), MP_ROM_PTR(&mp_lv_obj_set_style_transform_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_pivot_x), MP_ROM_PTR(&mp_lv_obj_set_style_transform_pivot_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_pivot_y), MP_ROM_PTR(&mp_lv_obj_set_style_transform_pivot_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_skew_x), MP_ROM_PTR(&mp_lv_obj_set_style_transform_skew_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_skew_y), MP_ROM_PTR(&mp_lv_obj_set_style_transform_skew_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_top), MP_ROM_PTR(&mp_lv_obj_set_style_pad_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_bottom), MP_ROM_PTR(&mp_lv_obj_set_style_pad_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_left), MP_ROM_PTR(&mp_lv_obj_set_style_pad_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_right), MP_ROM_PTR(&mp_lv_obj_set_style_pad_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_row), MP_ROM_PTR(&mp_lv_obj_set_style_pad_row_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_column), MP_ROM_PTR(&mp_lv_obj_set_style_pad_column_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_top), MP_ROM_PTR(&mp_lv_obj_set_style_margin_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_bottom), MP_ROM_PTR(&mp_lv_obj_set_style_margin_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_left), MP_ROM_PTR(&mp_lv_obj_set_style_margin_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_margin_right), MP_ROM_PTR(&mp_lv_obj_set_style_margin_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_color), MP_ROM_PTR(&mp_lv_obj_set_style_bg_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_set_style_bg_main_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_main_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_main_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_image_src), MP_ROM_PTR(&mp_lv_obj_set_style_bg_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_image_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_image_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_bg_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_image_tiled), MP_ROM_PTR(&mp_lv_obj_set_style_bg_image_tiled_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_color), MP_ROM_PTR(&mp_lv_obj_set_style_border_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_opa), MP_ROM_PTR(&mp_lv_obj_set_style_border_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_width), MP_ROM_PTR(&mp_lv_obj_set_style_border_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_side), MP_ROM_PTR(&mp_lv_obj_set_style_border_side_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_post), MP_ROM_PTR(&mp_lv_obj_set_style_border_post_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_width), MP_ROM_PTR(&mp_lv_obj_set_style_outline_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_color), MP_ROM_PTR(&mp_lv_obj_set_style_outline_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_opa), MP_ROM_PTR(&mp_lv_obj_set_style_outline_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_pad), MP_ROM_PTR(&mp_lv_obj_set_style_outline_pad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_width), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_offset_x), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_offset_y), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_spread), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_spread_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_color), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_opa), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_image_opa), MP_ROM_PTR(&mp_lv_obj_set_style_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_image_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_width), MP_ROM_PTR(&mp_lv_obj_set_style_line_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_dash_width), MP_ROM_PTR(&mp_lv_obj_set_style_line_dash_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_set_style_line_dash_gap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_rounded), MP_ROM_PTR(&mp_lv_obj_set_style_line_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_color), MP_ROM_PTR(&mp_lv_obj_set_style_line_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_opa), MP_ROM_PTR(&mp_lv_obj_set_style_line_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_width), MP_ROM_PTR(&mp_lv_obj_set_style_arc_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_rounded), MP_ROM_PTR(&mp_lv_obj_set_style_arc_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_color), MP_ROM_PTR(&mp_lv_obj_set_style_arc_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_opa), MP_ROM_PTR(&mp_lv_obj_set_style_arc_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_image_src), MP_ROM_PTR(&mp_lv_obj_set_style_arc_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_color), MP_ROM_PTR(&mp_lv_obj_set_style_text_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_opa), MP_ROM_PTR(&mp_lv_obj_set_style_text_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_font), MP_ROM_PTR(&mp_lv_obj_set_style_text_font_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_letter_space), MP_ROM_PTR(&mp_lv_obj_set_style_text_letter_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_line_space), MP_ROM_PTR(&mp_lv_obj_set_style_text_line_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_decor), MP_ROM_PTR(&mp_lv_obj_set_style_text_decor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_align), MP_ROM_PTR(&mp_lv_obj_set_style_text_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_radius), MP_ROM_PTR(&mp_lv_obj_set_style_radius_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_clip_corner), MP_ROM_PTR(&mp_lv_obj_set_style_clip_corner_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_opa), MP_ROM_PTR(&mp_lv_obj_set_style_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_opa_layered), MP_ROM_PTR(&mp_lv_obj_set_style_opa_layered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_color_filter_dsc), MP_ROM_PTR(&mp_lv_obj_set_style_color_filter_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_color_filter_opa), MP_ROM_PTR(&mp_lv_obj_set_style_color_filter_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_anim), MP_ROM_PTR(&mp_lv_obj_set_style_anim_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_anim_duration), MP_ROM_PTR(&mp_lv_obj_set_style_anim_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transition), MP_ROM_PTR(&mp_lv_obj_set_style_transition_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_blend_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_layout), MP_ROM_PTR(&mp_lv_obj_set_style_layout_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_base_dir), MP_ROM_PTR(&mp_lv_obj_set_style_base_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_flow), MP_ROM_PTR(&mp_lv_obj_set_style_flex_flow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_main_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_main_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_cross_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_cross_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_track_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_track_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_grow), MP_ROM_PTR(&mp_lv_obj_set_style_flex_grow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_style_grid_column_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_column_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_column_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_style_grid_row_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_row_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_row_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_column_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_x_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_x_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_column_span), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_column_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_row_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_y_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_y_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_row_span), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_row_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_calculate_style_text_align), MP_ROM_PTR(&mp_lv_obj_calculate_style_text_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_opa_recursive), MP_ROM_PTR(&mp_lv_obj_get_style_opa_recursive_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_rect_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_rect_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_label_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_label_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_image_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_image_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_line_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_line_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_arc_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_arc_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_calculate_ext_draw_size), MP_ROM_PTR(&mp_lv_obj_calculate_ext_draw_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_ext_draw_size), MP_ROM_PTR(&mp_lv_obj_refresh_ext_draw_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_class_create_obj), MP_ROM_PTR(&mp_lv_obj_class_create_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_class_init_obj), MP_ROM_PTR(&mp_lv_obj_class_init_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_editable), MP_ROM_PTR(&mp_lv_obj_is_editable_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_group_def), MP_ROM_PTR(&mp_lv_obj_is_group_def_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_send_event), MP_ROM_PTR(&mp_lv_obj_send_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_base), MP_ROM_PTR(&mp_lv_obj_event_base_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_event_cb), MP_ROM_PTR(&mp_lv_obj_add_event_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_count), MP_ROM_PTR(&mp_lv_obj_get_event_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_dsc), MP_ROM_PTR(&mp_lv_obj_get_event_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event), MP_ROM_PTR(&mp_lv_obj_remove_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb), MP_ROM_PTR(&mp_lv_obj_remove_event_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb_with_user_data), MP_ROM_PTR(&mp_lv_obj_remove_event_cb_with_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_flag), MP_ROM_PTR(&mp_lv_obj_add_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_flag), MP_ROM_PTR(&mp_lv_obj_remove_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_update_flag), MP_ROM_PTR(&mp_lv_obj_update_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_state), MP_ROM_PTR(&mp_lv_obj_add_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_state), MP_ROM_PTR(&mp_lv_obj_remove_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_obj_set_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_flag), MP_ROM_PTR(&mp_lv_obj_has_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_flag_any), MP_ROM_PTR(&mp_lv_obj_has_flag_any_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_obj_get_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_state), MP_ROM_PTR(&mp_lv_obj_has_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_group), MP_ROM_PTR(&mp_lv_obj_get_group_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_allocate_spec_attr), MP_ROM_PTR(&mp_lv_obj_allocate_spec_attr_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_check_type), MP_ROM_PTR(&mp_lv_obj_check_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_class), MP_ROM_PTR(&mp_lv_obj_has_class_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_class), MP_ROM_PTR(&mp_lv_obj_get_class_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_valid), MP_ROM_PTR(&mp_lv_obj_is_valid_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_redraw), MP_ROM_PTR(&mp_lv_obj_redraw_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_flag_if_eq), MP_ROM_PTR(&mp_lv_obj_bind_flag_if_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_flag_if_not_eq), MP_ROM_PTR(&mp_lv_obj_bind_flag_if_not_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_state_if_eq), MP_ROM_PTR(&mp_lv_obj_bind_state_if_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_state_if_not_eq), MP_ROM_PTR(&mp_lv_obj_bind_state_if_not_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_TREE_WALK), MP_ROM_PTR(&mp_lv_LV_OBJ_TREE_WALK_type_base) },
    { MP_ROM_QSTR(MP_QSTR_CLASS_EDITABLE), MP_ROM_PTR(&mp_lv_LV_OBJ_CLASS_EDITABLE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_CLASS_GROUP_DEF), MP_ROM_PTR(&mp_lv_LV_OBJ_CLASS_GROUP_DEF_type_base) },
    { MP_ROM_QSTR(MP_QSTR_CLASS_THEME_INHERITABLE), MP_ROM_PTR(&mp_lv_LV_OBJ_CLASS_THEME_INHERITABLE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FLAG), MP_ROM_PTR(&mp_lv_LV_OBJ_FLAG_type_base) },
    { MP_ROM_QSTR(MP_QSTR___cast__), MP_ROM_PTR(&cast_obj_class_method) }
};

STATIC MP_DEFINE_CONST_DICT(obj_locals_dict, obj_locals_dict_table);

STATIC void obj_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl obj");
}


STATIC mp_obj_t obj_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_obj_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_obj_type_base,
    MP_QSTR_obj,
    MP_TYPE_FLAG_NONE,
    print, obj_print,
    make_new, obj_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    
    locals_dict, &obj_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_obj_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_obj_class,
#endif
    .mp_obj_type = &mp_lv_obj_type_base,
};
    

/*
 * lvgl extension definition for:
 * inline static void lv_image_header_init(lv_image_header_t *header, uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride, lv_image_flags_t flags)
 */

STATIC mp_obj_t mp_lv_image_header_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_header_t *header = mp_write_ptr_lv_image_header_t(mp_args[0]);
    uint32_t w = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t h = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[3]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_image_flags_t flags = (int)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_image_header_t *, uint32_t, uint32_t, lv_color_format_t, uint32_t, lv_image_flags_t))lv_func_ptr)(header, w, h, cf, stride, flags);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_header_init_mpobj, 6, mp_lv_image_header_init, lv_image_header_init);
    

/*
 * Struct lv_image_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_image_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_image_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_image_dsc_t_type()));
    return (lv_image_dsc_t*)self->data;
}

#define mp_write_lv_image_dsc_t(struct_obj) *((lv_image_dsc_t*)mp_write_ptr_lv_image_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_image_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_image_dsc_t_type(), field);
}

#define mp_read_lv_image_dsc_t(field) mp_read_ptr_lv_image_dsc_t(copy_buffer(&field, sizeof(lv_image_dsc_t)))
#define mp_read_byref_lv_image_dsc_t(field) mp_read_ptr_lv_image_dsc_t(&field)

STATIC void mp_lv_image_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_image_dsc_t *data = (lv_image_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_image_header_t(data->header); break; // converting from lv_image_header_t;
            case MP_QSTR_data_size: dest[0] = mp_obj_new_int_from_uint(data->data_size); break; // converting from uint32_t;
            case MP_QSTR_data: dest[0] = mp_array_from_u8ptr((void*)data->data); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_header: data->header = mp_write_lv_image_header_t(dest[1]); break; // converting to lv_image_header_t;
                case MP_QSTR_data_size: data->data_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_data: data->data = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_image_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_image_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_image_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_dsc_t_type,
    MP_QSTR_lv_image_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_image_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_image_dsc_t_attr,
    locals_dict, &mp_lv_image_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_image_dsc_t_type()
{
    return &mp_lv_image_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_image_buf_set_palette(lv_image_dsc_t *dsc, uint8_t id, lv_color32_t c)
 */

STATIC mp_obj_t mp_lv_image_buf_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_dsc_t *dsc = mp_write_ptr_lv_image_dsc_t(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color32_t c = mp_write_lv_color32_t(mp_args[2]);
    ((void (*)(lv_image_dsc_t *, uint8_t, lv_color32_t))lv_func_ptr)(dsc, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_buf_set_palette_mpobj, 3, mp_lv_image_buf_set_palette, lv_image_buf_set_palette);
    

/*
 * lvgl extension definition for:
 * void lv_image_buf_free(lv_image_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_image_buf_free(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_dsc_t *dsc = mp_write_ptr_lv_image_dsc_t(mp_args[0]);
    ((void (*)(lv_image_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_buf_free_mpobj, 1, mp_lv_image_buf_free, lv_image_buf_free);
    

/*
 * lvgl extension definition for:
 * void lv_image_cache_drop(const void *src)
 */

STATIC mp_obj_t mp_lv_image_cache_drop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = (const void *)mp_to_ptr(mp_args[0]);
    ((void (*)(const void *))lv_func_ptr)(src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_image_cache_drop_mpobj, 1, mp_lv_image_cache_drop, lv_image_cache_drop);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_get_info(const void *src, lv_image_header_t *header)
 */

STATIC mp_obj_t mp_lv_image_decoder_get_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = (const void *)mp_to_ptr(mp_args[0]);
    lv_image_header_t *header = mp_write_ptr_lv_image_header_t(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(const void *, lv_image_header_t *))lv_func_ptr)(src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_image_decoder_get_info_mpobj, 2, mp_lv_image_decoder_get_info, lv_image_decoder_get_info);
    
#define funcptr_lv_image_decoder_info_f_t NULL


/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_info_f_t(lv_image_decoder_t *decoder, const void *src, lv_image_header_t *header)
 */

STATIC mp_obj_t mp_funcptr_lv_image_decoder_info_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    const void *src = (const void *)mp_to_ptr(mp_args[1]);
    lv_image_header_t *header = mp_write_ptr_lv_image_header_t(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_image_decoder_t *, const void *, lv_image_header_t *))lv_func_ptr)(decoder, src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_image_decoder_info_f_t_mpobj, 3, mp_funcptr_lv_image_decoder_info_f_t, funcptr_lv_image_decoder_info_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_image_decoder_info_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_image_decoder_info_f_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_result_t lv_image_decoder_t_info_cb_callback(lv_image_decoder_t *decoder, const void *src, lv_image_header_t *header);
#define funcptr_lv_image_decoder_open_f_t NULL


/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_open_f_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc)
 */

STATIC mp_obj_t mp_funcptr_lv_image_decoder_open_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    lv_image_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_image_decoder_t *, lv_image_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_image_decoder_open_f_t_mpobj, 2, mp_funcptr_lv_image_decoder_open_f_t, funcptr_lv_image_decoder_open_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_image_decoder_open_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_image_decoder_open_f_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_result_t lv_image_decoder_t_open_cb_callback(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc);
#define funcptr_lv_image_decoder_get_area_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_get_area_cb_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc, const lv_area_t *full_area, lv_area_t *decoded_area)
 */

STATIC mp_obj_t mp_funcptr_lv_image_decoder_get_area_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    lv_image_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    const lv_area_t *full_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    lv_area_t *decoded_area = mp_write_ptr_lv_area_t(mp_args[3]);
    lv_result_t _res = ((lv_result_t (*)(lv_image_decoder_t *, lv_image_decoder_dsc_t *, const lv_area_t *, lv_area_t *))lv_func_ptr)(decoder, dsc, full_area, decoded_area);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_image_decoder_get_area_cb_t_mpobj, 4, mp_funcptr_lv_image_decoder_get_area_cb_t, funcptr_lv_image_decoder_get_area_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_image_decoder_get_area_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_image_decoder_get_area_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_result_t lv_image_decoder_t_get_area_cb_callback(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc, const lv_area_t *full_area, lv_area_t *decoded_area);
#define funcptr_lv_image_decoder_close_f_t NULL


/*
 * lvgl extension definition for:
 * void lv_image_decoder_close_f_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc)
 */

STATIC mp_obj_t mp_funcptr_lv_image_decoder_close_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    lv_image_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_image_decoder_t *, lv_image_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_image_decoder_close_f_t_mpobj, 2, mp_funcptr_lv_image_decoder_close_f_t, funcptr_lv_image_decoder_close_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_image_decoder_close_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_image_decoder_close_f_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_image_decoder_t_close_cb_callback(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc);
#define funcptr_lv_cache_free_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_cache_free_cb_t(void *node, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_free_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *node = mp_to_ptr(mp_args[0]);
    ((void (*)(void *, void *))lv_func_ptr)(node, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_free_cb_t_mpobj, 2, mp_funcptr_lv_cache_free_cb_t, funcptr_lv_cache_free_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_free_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_free_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_image_decoder_t_cache_free_cb_callback'
 * lv_cache_free_cb_t cache_free_cb
 */
    

/*
 * Struct lv_image_decoder_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_t_type();

STATIC inline void* mp_write_ptr_lv_image_decoder_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_image_decoder_t_type()));
    return (lv_image_decoder_t*)self->data;
}

#define mp_write_lv_image_decoder_t(struct_obj) *((lv_image_decoder_t*)mp_write_ptr_lv_image_decoder_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_image_decoder_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_image_decoder_t_type(), field);
}

#define mp_read_lv_image_decoder_t(field) mp_read_ptr_lv_image_decoder_t(copy_buffer(&field, sizeof(lv_image_decoder_t)))
#define mp_read_byref_lv_image_decoder_t(field) mp_read_ptr_lv_image_decoder_t(&field)

STATIC void mp_lv_image_decoder_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_image_decoder_t *data = (lv_image_decoder_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_info_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_image_decoder_info_f_t_mpobj, data->info_cb, lv_image_decoder_t_info_cb_callback ,MP_QSTR_lv_image_decoder_t_info_cb, data->user_data); break; // converting from callback lv_image_decoder_info_f_t;
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_image_decoder_open_f_t_mpobj, data->open_cb, lv_image_decoder_t_open_cb_callback ,MP_QSTR_lv_image_decoder_t_open_cb, data->user_data); break; // converting from callback lv_image_decoder_open_f_t;
            case MP_QSTR_get_area_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_image_decoder_get_area_cb_t_mpobj, data->get_area_cb, lv_image_decoder_t_get_area_cb_callback ,MP_QSTR_lv_image_decoder_t_get_area_cb, data->user_data); break; // converting from callback lv_image_decoder_get_area_cb_t;
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_image_decoder_close_f_t_mpobj, data->close_cb, lv_image_decoder_t_close_cb_callback ,MP_QSTR_lv_image_decoder_t_close_cb, data->user_data); break; // converting from callback lv_image_decoder_close_f_t;
            case MP_QSTR_cache_free_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_free_cb_t_mpobj, data->cache_free_cb, NULL ,MP_QSTR_lv_image_decoder_t_cache_free_cb, NULL); break; // converting from callback lv_cache_free_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_info_cb: data->info_cb = mp_lv_callback(dest[1], lv_image_decoder_t_info_cb_callback ,MP_QSTR_lv_image_decoder_t_info_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_image_decoder_info_f_t;
                case MP_QSTR_open_cb: data->open_cb = mp_lv_callback(dest[1], lv_image_decoder_t_open_cb_callback ,MP_QSTR_lv_image_decoder_t_open_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_image_decoder_open_f_t;
                case MP_QSTR_get_area_cb: data->get_area_cb = mp_lv_callback(dest[1], lv_image_decoder_t_get_area_cb_callback ,MP_QSTR_lv_image_decoder_t_get_area_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_image_decoder_get_area_cb_t;
                case MP_QSTR_close_cb: data->close_cb = mp_lv_callback(dest[1], lv_image_decoder_t_close_cb_callback ,MP_QSTR_lv_image_decoder_t_close_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_image_decoder_close_f_t;
                case MP_QSTR_cache_free_cb: data->cache_free_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_image_decoder_t_cache_free_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_free_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_image_decoder_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_image_decoder_t");
}

STATIC const mp_obj_dict_t mp_lv_image_decoder_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_decoder_t_type,
    MP_QSTR_lv_image_decoder_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_image_decoder_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_image_decoder_t_attr,
    locals_dict, &mp_lv_image_decoder_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_t_type()
{
    return &mp_lv_image_decoder_t_type;
}
    

/*
 * Struct lv_image_decoder_args_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_args_t_type();

STATIC inline void* mp_write_ptr_lv_image_decoder_args_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_image_decoder_args_t_type()));
    return (lv_image_decoder_args_t*)self->data;
}

#define mp_write_lv_image_decoder_args_t(struct_obj) *((lv_image_decoder_args_t*)mp_write_ptr_lv_image_decoder_args_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_image_decoder_args_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_image_decoder_args_t_type(), field);
}

#define mp_read_lv_image_decoder_args_t(field) mp_read_ptr_lv_image_decoder_args_t(copy_buffer(&field, sizeof(lv_image_decoder_args_t)))
#define mp_read_byref_lv_image_decoder_args_t(field) mp_read_ptr_lv_image_decoder_args_t(&field)

STATIC void mp_lv_image_decoder_args_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_image_decoder_args_t *data = (lv_image_decoder_args_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_stride_align: dest[0] = convert_to_bool(data->stride_align); break; // converting from bool;
            case MP_QSTR_premultiply: dest[0] = convert_to_bool(data->premultiply); break; // converting from bool;
            case MP_QSTR_no_cache: dest[0] = convert_to_bool(data->no_cache); break; // converting from bool;
            case MP_QSTR_use_indexed: dest[0] = convert_to_bool(data->use_indexed); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_stride_align: data->stride_align = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_premultiply: data->premultiply = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_no_cache: data->no_cache = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_use_indexed: data->use_indexed = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_image_decoder_args_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_image_decoder_args_t");
}

STATIC const mp_obj_dict_t mp_lv_image_decoder_args_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_decoder_args_t_type,
    MP_QSTR_lv_image_decoder_args_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_image_decoder_args_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_image_decoder_args_t_attr,
    locals_dict, &mp_lv_image_decoder_args_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_args_t_type()
{
    return &mp_lv_image_decoder_args_t_type;
}
    
#define funcptr_lv_cache_alloc_cb_t NULL


/*
 * lvgl extension definition for:
 * void *lv_cache_alloc_cb_t(void)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_alloc_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    void * _res = ((void *(*)(void))lv_func_ptr)();
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_alloc_cb_t_mpobj, 0, mp_funcptr_lv_cache_alloc_cb_t, funcptr_lv_cache_alloc_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_alloc_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_alloc_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_alloc_cb_callback'
 * lv_cache_alloc_cb_t alloc_cb
 */
    
#define funcptr_lv_cache_init_cb_t NULL


/*
 * lvgl extension definition for:
 * bool lv_cache_init_cb_t(lv_cache_t *cache)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_init_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_t *cache = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(lv_cache_t *))lv_func_ptr)(cache);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_init_cb_t_mpobj, 1, mp_funcptr_lv_cache_init_cb_t, funcptr_lv_cache_init_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_init_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_init_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_init_cb_callback'
 * lv_cache_init_cb_t init_cb
 */
    
#define funcptr_lv_cache_destroy_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_cache_destroy_cb_t(lv_cache_t *cache, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_destroy_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_cache_t *cache = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_cache_t *, void *))lv_func_ptr)(cache, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_destroy_cb_t_mpobj, 2, mp_funcptr_lv_cache_destroy_cb_t, funcptr_lv_cache_destroy_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_destroy_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_destroy_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_destroy_cb_callback'
 * lv_cache_destroy_cb_t destroy_cb
 */
    
#define funcptr_lv_cache_get_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_cache_entry_t *lv_cache_get_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_get_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    const void *key = (const void *)mp_to_ptr(mp_args[1]);
    lv_cache_t *cache = mp_to_ptr(mp_args[0]);
    lv_cache_entry_t * _res = ((lv_cache_entry_t *(*)(lv_cache_t *, const void *, void *))lv_func_ptr)(cache, key, user_data);
    return mp_read_ptr_lv_cache_entry_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_get_cb_t_mpobj, 3, mp_funcptr_lv_cache_get_cb_t, funcptr_lv_cache_get_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_get_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_get_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_get_cb_callback'
 * lv_cache_get_cb_t get_cb
 */
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_add_cb_callback'
 * lv_cache_add_cb_t add_cb
 */
    
#define funcptr_lv_cache_remove_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_cache_remove_cb_t(lv_cache_t *cache, lv_cache_entry_t *entry, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_remove_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[1]);
    lv_cache_t *cache = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_cache_t *, lv_cache_entry_t *, void *))lv_func_ptr)(cache, entry, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_remove_cb_t_mpobj, 3, mp_funcptr_lv_cache_remove_cb_t, funcptr_lv_cache_remove_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_remove_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_remove_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_remove_cb_callback'
 * lv_cache_remove_cb_t remove_cb
 */
    
#define funcptr_lv_cache_drop_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_cache_drop_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_drop_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    const void *key = (const void *)mp_to_ptr(mp_args[1]);
    lv_cache_t *cache = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_cache_t *, const void *, void *))lv_func_ptr)(cache, key, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_drop_cb_t_mpobj, 3, mp_funcptr_lv_cache_drop_cb_t, funcptr_lv_cache_drop_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_drop_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_drop_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_drop_cb_callback'
 * lv_cache_drop_cb_t drop_cb
 */
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_class_t_drop_all_cb_callback'
 * lv_cache_clear_cb_t drop_all_cb
 */
    

/*
 * Struct lv_cache_class_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_cache_class_t_type();

STATIC inline void* mp_write_ptr_lv_cache_class_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_cache_class_t_type()));
    return (lv_cache_class_t*)self->data;
}

#define mp_write_lv_cache_class_t(struct_obj) *((lv_cache_class_t*)mp_write_ptr_lv_cache_class_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_cache_class_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_cache_class_t_type(), field);
}

#define mp_read_lv_cache_class_t(field) mp_read_ptr_lv_cache_class_t(copy_buffer(&field, sizeof(lv_cache_class_t)))
#define mp_read_byref_lv_cache_class_t(field) mp_read_ptr_lv_cache_class_t(&field)

STATIC void mp_lv_cache_class_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_cache_class_t *data = (lv_cache_class_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_alloc_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_alloc_cb_t_mpobj, data->alloc_cb, NULL ,MP_QSTR_lv_cache_class_t_alloc_cb, NULL); break; // converting from callback lv_cache_alloc_cb_t;
            case MP_QSTR_init_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_init_cb_t_mpobj, data->init_cb, NULL ,MP_QSTR_lv_cache_class_t_init_cb, NULL); break; // converting from callback lv_cache_init_cb_t;
            case MP_QSTR_destroy_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_destroy_cb_t_mpobj, data->destroy_cb, NULL ,MP_QSTR_lv_cache_class_t_destroy_cb, NULL); break; // converting from callback lv_cache_destroy_cb_t;
            case MP_QSTR_get_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_get_cb_t_mpobj, data->get_cb, NULL ,MP_QSTR_lv_cache_class_t_get_cb, NULL); break; // converting from callback lv_cache_get_cb_t;
            case MP_QSTR_add_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_get_cb_t_mpobj, data->add_cb, NULL ,MP_QSTR_lv_cache_class_t_add_cb, NULL); break; // converting from callback lv_cache_add_cb_t;
            case MP_QSTR_remove_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_remove_cb_t_mpobj, data->remove_cb, NULL ,MP_QSTR_lv_cache_class_t_remove_cb, NULL); break; // converting from callback lv_cache_remove_cb_t;
            case MP_QSTR_drop_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_drop_cb_t_mpobj, data->drop_cb, NULL ,MP_QSTR_lv_cache_class_t_drop_cb, NULL); break; // converting from callback lv_cache_drop_cb_t;
            case MP_QSTR_drop_all_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_destroy_cb_t_mpobj, data->drop_all_cb, NULL ,MP_QSTR_lv_cache_class_t_drop_all_cb, NULL); break; // converting from callback lv_cache_clear_cb_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_alloc_cb: data->alloc_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_alloc_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_alloc_cb_t;
                case MP_QSTR_init_cb: data->init_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_init_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_init_cb_t;
                case MP_QSTR_destroy_cb: data->destroy_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_destroy_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_destroy_cb_t;
                case MP_QSTR_get_cb: data->get_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_get_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_get_cb_t;
                case MP_QSTR_add_cb: data->add_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_add_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_add_cb_t;
                case MP_QSTR_remove_cb: data->remove_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_remove_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_remove_cb_t;
                case MP_QSTR_drop_cb: data->drop_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_drop_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_drop_cb_t;
                case MP_QSTR_drop_all_cb: data->drop_all_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_class_t_drop_all_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_clear_cb_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_cache_class_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_cache_class_t");
}

STATIC const mp_obj_dict_t mp_lv_cache_class_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_cache_class_t_type,
    MP_QSTR_lv_cache_class_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_cache_class_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_cache_class_t_attr,
    locals_dict, &mp_lv_cache_class_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_cache_class_t_type()
{
    return &mp_lv_cache_class_t_type;
}
    
#define funcptr_lv_cache_compare_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_cache_compare_res_t lv_cache_compare_cb_t(const void *a, const void *b)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_compare_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *a = (const void *)mp_to_ptr(mp_args[0]);
    const void *b = (const void *)mp_to_ptr(mp_args[1]);
    lv_cache_compare_res_t _res = ((lv_cache_compare_res_t (*)(const void *, const void *))lv_func_ptr)(a, b);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_compare_cb_t_mpobj, 2, mp_funcptr_lv_cache_compare_cb_t, funcptr_lv_cache_compare_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_compare_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_compare_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_ops_t_compare_cb_callback'
 * lv_cache_compare_cb_t compare_cb
 */
    
#define funcptr_lv_cache_create_cb_t NULL


/*
 * lvgl extension definition for:
 * bool lv_cache_create_cb_t(void *node, void *user_data)
 */

STATIC mp_obj_t mp_funcptr_lv_cache_create_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *node = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(void *, void *))lv_func_ptr)(node, user_data);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_cache_create_cb_t_mpobj, 2, mp_funcptr_lv_cache_create_cb_t, funcptr_lv_cache_create_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_cache_create_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_cache_create_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_ops_t_create_cb_callback'
 * lv_cache_create_cb_t create_cb
 */
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_cache_ops_t_free_cb_callback'
 * lv_cache_free_cb_t free_cb
 */
    

/*
 * Struct lv_cache_ops_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_cache_ops_t_type();

STATIC inline void* mp_write_ptr_lv_cache_ops_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_cache_ops_t_type()));
    return (lv_cache_ops_t*)self->data;
}

#define mp_write_lv_cache_ops_t(struct_obj) *((lv_cache_ops_t*)mp_write_ptr_lv_cache_ops_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_cache_ops_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_cache_ops_t_type(), field);
}

#define mp_read_lv_cache_ops_t(field) mp_read_ptr_lv_cache_ops_t(copy_buffer(&field, sizeof(lv_cache_ops_t)))
#define mp_read_byref_lv_cache_ops_t(field) mp_read_ptr_lv_cache_ops_t(&field)

STATIC void mp_lv_cache_ops_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_cache_ops_t *data = (lv_cache_ops_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_compare_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_compare_cb_t_mpobj, data->compare_cb, NULL ,MP_QSTR_lv_cache_ops_t_compare_cb, NULL); break; // converting from callback lv_cache_compare_cb_t;
            case MP_QSTR_create_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_create_cb_t_mpobj, data->create_cb, NULL ,MP_QSTR_lv_cache_ops_t_create_cb, NULL); break; // converting from callback lv_cache_create_cb_t;
            case MP_QSTR_free_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_cache_free_cb_t_mpobj, data->free_cb, NULL ,MP_QSTR_lv_cache_ops_t_free_cb, NULL); break; // converting from callback lv_cache_free_cb_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_compare_cb: data->compare_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_ops_t_compare_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_compare_cb_t;
                case MP_QSTR_create_cb: data->create_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_ops_t_create_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_create_cb_t;
                case MP_QSTR_free_cb: data->free_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_cache_ops_t_free_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_cache_free_cb_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_cache_ops_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_cache_ops_t");
}

STATIC const mp_obj_dict_t mp_lv_cache_ops_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_cache_ops_t_type,
    MP_QSTR_lv_cache_ops_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_cache_ops_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_cache_ops_t_attr,
    locals_dict, &mp_lv_cache_ops_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_cache_ops_t_type()
{
    return &mp_lv_cache_ops_t_type;
}
    

/*
 * Struct lv_cache_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_cache_t_type();

STATIC inline void* mp_write_ptr_lv_cache_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_cache_t_type()));
    return (lv_cache_t*)self->data;
}

#define mp_write_lv_cache_t(struct_obj) *((lv_cache_t*)mp_write_ptr_lv_cache_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_cache_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_cache_t_type(), field);
}

#define mp_read_lv_cache_t(field) mp_read_ptr_lv_cache_t(copy_buffer(&field, sizeof(lv_cache_t)))
#define mp_read_byref_lv_cache_t(field) mp_read_ptr_lv_cache_t(&field)

STATIC void mp_lv_cache_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_cache_t *data = (lv_cache_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_clz: dest[0] = mp_read_ptr_lv_cache_class_t((void*)data->clz); break; // converting from lv_cache_class_t *;
            case MP_QSTR_node_size: dest[0] = mp_obj_new_int_from_uint(data->node_size); break; // converting from size_t;
            case MP_QSTR_max_size: dest[0] = mp_obj_new_int_from_uint(data->max_size); break; // converting from size_t;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from size_t;
            case MP_QSTR_ops: dest[0] = mp_read_byref_lv_cache_ops_t(data->ops); break; // converting from lv_cache_ops_t;
            case MP_QSTR_lock: dest[0] = mp_obj_new_int(data->lock); break; // converting from lv_mutex_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_clz: data->clz = (void*)mp_write_ptr_lv_cache_class_t(dest[1]); break; // converting to lv_cache_class_t *;
                case MP_QSTR_node_size: data->node_size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_max_size: data->max_size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_size: data->size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_ops: data->ops = mp_write_lv_cache_ops_t(dest[1]); break; // converting to lv_cache_ops_t;
                case MP_QSTR_lock: data->lock = (int)mp_obj_get_int(dest[1]); break; // converting to lv_mutex_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_cache_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_cache_t");
}

STATIC const mp_obj_dict_t mp_lv_cache_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_cache_t_type,
    MP_QSTR_lv_cache_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_cache_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_cache_t_attr,
    locals_dict, &mp_lv_cache_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_cache_t_type()
{
    return &mp_lv_cache_t_type;
}
    

/*
 * Struct lv_image_decoder_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_image_decoder_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_image_decoder_dsc_t_type()));
    return (lv_image_decoder_dsc_t*)self->data;
}

#define mp_write_lv_image_decoder_dsc_t(struct_obj) *((lv_image_decoder_dsc_t*)mp_write_ptr_lv_image_decoder_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_image_decoder_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_image_decoder_dsc_t_type(), field);
}

#define mp_read_lv_image_decoder_dsc_t(field) mp_read_ptr_lv_image_decoder_dsc_t(copy_buffer(&field, sizeof(lv_image_decoder_dsc_t)))
#define mp_read_byref_lv_image_decoder_dsc_t(field) mp_read_ptr_lv_image_decoder_dsc_t(&field)

STATIC void mp_lv_image_decoder_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_image_decoder_dsc_t *data = (lv_image_decoder_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_decoder: dest[0] = mp_read_ptr_lv_image_decoder_t((void*)data->decoder); break; // converting from lv_image_decoder_t *;
            case MP_QSTR_args: dest[0] = mp_read_byref_lv_image_decoder_args_t(data->args); break; // converting from lv_image_decoder_args_t;
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_src_type: dest[0] = mp_obj_new_int_from_uint(data->src_type); break; // converting from lv_image_src_t;
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_image_header_t(data->header); break; // converting from lv_image_header_t;
            case MP_QSTR_decoded: dest[0] = mp_read_ptr_lv_draw_buf_t((void*)data->decoded); break; // converting from lv_draw_buf_t *;
            case MP_QSTR_palette: dest[0] = mp_read_ptr_lv_color32_t((void*)data->palette); break; // converting from lv_color32_t *;
            case MP_QSTR_palette_size: dest[0] = mp_obj_new_int_from_uint(data->palette_size); break; // converting from uint32_t;
            case MP_QSTR_time_to_open: dest[0] = mp_obj_new_int_from_uint(data->time_to_open); break; // converting from uint32_t;
            case MP_QSTR_error_msg: dest[0] = convert_to_str((void*)data->error_msg); break; // converting from char *;
            case MP_QSTR_cache: dest[0] = mp_read_ptr_lv_cache_t((void*)data->cache); break; // converting from lv_cache_t *;
            case MP_QSTR_cache_entry: dest[0] = mp_read_ptr_lv_cache_entry_t((void*)data->cache_entry); break; // converting from lv_cache_entry_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_decoder: data->decoder = (void*)mp_write_ptr_lv_image_decoder_t(dest[1]); break; // converting to lv_image_decoder_t *;
                case MP_QSTR_args: data->args = mp_write_lv_image_decoder_args_t(dest[1]); break; // converting to lv_image_decoder_args_t;
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_src_type: data->src_type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_image_src_t;
                case MP_QSTR_header: data->header = mp_write_lv_image_header_t(dest[1]); break; // converting to lv_image_header_t;
                case MP_QSTR_decoded: data->decoded = (void*)mp_write_ptr_lv_draw_buf_t(dest[1]); break; // converting to lv_draw_buf_t *;
                case MP_QSTR_palette: data->palette = (void*)mp_write_ptr_lv_color32_t(dest[1]); break; // converting to lv_color32_t *;
                case MP_QSTR_palette_size: data->palette_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_time_to_open: data->time_to_open = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_error_msg: data->error_msg = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_cache: data->cache = (void*)mp_write_ptr_lv_cache_t(dest[1]); break; // converting to lv_cache_t *;
                case MP_QSTR_cache_entry: data->cache_entry = (void*)mp_write_ptr_lv_cache_entry_t(dest[1]); break; // converting to lv_cache_entry_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_image_decoder_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_image_decoder_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_image_decoder_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_decoder_dsc_t_type,
    MP_QSTR_lv_image_decoder_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_image_decoder_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_image_decoder_dsc_t_attr,
    locals_dict, &mp_lv_image_decoder_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_image_decoder_dsc_t_type()
{
    return &mp_lv_image_decoder_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_open(lv_image_decoder_dsc_t *dsc, const void *src, const lv_image_decoder_args_t *args)
 */

STATIC mp_obj_t mp_lv_image_decoder_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_dsc_t *dsc = mp_write_ptr_lv_image_decoder_dsc_t(mp_args[0]);
    const void *src = (const void *)mp_to_ptr(mp_args[1]);
    const lv_image_decoder_args_t *args = (const lv_image_decoder_args_t *)mp_write_ptr_lv_image_decoder_args_t(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_image_decoder_dsc_t *, const void *, const lv_image_decoder_args_t *))lv_func_ptr)(dsc, src, args);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_open_mpobj, 3, mp_lv_image_decoder_open, lv_image_decoder_open);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_image_decoder_get_area(lv_image_decoder_dsc_t *dsc, const lv_area_t *full_area, lv_area_t *decoded_area)
 */

STATIC mp_obj_t mp_lv_image_decoder_get_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_dsc_t *dsc = mp_write_ptr_lv_image_decoder_dsc_t(mp_args[0]);
    const lv_area_t *full_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    lv_area_t *decoded_area = mp_write_ptr_lv_area_t(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_image_decoder_dsc_t *, const lv_area_t *, lv_area_t *))lv_func_ptr)(dsc, full_area, decoded_area);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_get_area_mpobj, 3, mp_lv_image_decoder_get_area, lv_image_decoder_get_area);
    

/*
 * lvgl extension definition for:
 * void lv_image_decoder_close(lv_image_decoder_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_image_decoder_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_dsc_t *dsc = mp_write_ptr_lv_image_decoder_dsc_t(mp_args[0]);
    ((void (*)(lv_image_decoder_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_close_mpobj, 1, mp_lv_image_decoder_close, lv_image_decoder_close);
    

/*
 * lvgl extension definition for:
 * lv_image_decoder_t *lv_image_decoder_create(void)
 */

STATIC mp_obj_t mp_lv_image_decoder_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_image_decoder_t * _res = ((lv_image_decoder_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_image_decoder_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_image_decoder_create_mpobj, 0, mp_lv_image_decoder_create, lv_image_decoder_create);
    

/*
 * lvgl extension definition for:
 * void lv_image_decoder_delete(lv_image_decoder_t *decoder)
 */

STATIC mp_obj_t mp_lv_image_decoder_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    ((void (*)(lv_image_decoder_t *))lv_func_ptr)(decoder);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_delete_mpobj, 1, mp_lv_image_decoder_delete, lv_image_decoder_delete);
    

/*
 * lvgl extension definition for:
 * lv_image_decoder_t *lv_image_decoder_get_next(lv_image_decoder_t *decoder)
 */

STATIC mp_obj_t mp_lv_image_decoder_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    lv_image_decoder_t * _res = ((lv_image_decoder_t *(*)(lv_image_decoder_t *))lv_func_ptr)(decoder);
    return mp_read_ptr_lv_image_decoder_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_get_next_mpobj, 1, mp_lv_image_decoder_get_next, lv_image_decoder_get_next);
    

/*
 * Callback function lv_image_decoder_t_info_cb
 * lv_result_t lv_image_decoder_info_f_t(lv_image_decoder_t *decoder, const void *src, lv_image_header_t *header)
 */

GENMPY_UNUSED STATIC lv_result_t lv_image_decoder_t_info_cb_callback(lv_image_decoder_t *arg0, const void *arg1, lv_image_header_t *arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_image_decoder_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_image_header_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_image_decoder_t_info_cb)) , 3, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_image_decoder_set_info_cb(lv_image_decoder_t *decoder, lv_image_decoder_info_f_t info_cb)
 */

STATIC mp_obj_t mp_lv_image_decoder_set_info_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    void *info_cb = mp_lv_callback(mp_args[1], &lv_image_decoder_t_info_cb_callback, MP_QSTR_lv_image_decoder_t_info_cb, &decoder->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_image_decoder_t *, lv_image_decoder_info_f_t))lv_func_ptr)(decoder, info_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_set_info_cb_mpobj, 2, mp_lv_image_decoder_set_info_cb, lv_image_decoder_set_info_cb);
    

/*
 * Callback function lv_image_decoder_t_open_cb
 * lv_result_t lv_image_decoder_open_f_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc)
 */

GENMPY_UNUSED STATIC lv_result_t lv_image_decoder_t_open_cb_callback(lv_image_decoder_t *arg0, lv_image_decoder_dsc_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_image_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_image_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_image_decoder_t_open_cb)) , 2, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_image_decoder_set_open_cb(lv_image_decoder_t *decoder, lv_image_decoder_open_f_t open_cb)
 */

STATIC mp_obj_t mp_lv_image_decoder_set_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    void *open_cb = mp_lv_callback(mp_args[1], &lv_image_decoder_t_open_cb_callback, MP_QSTR_lv_image_decoder_t_open_cb, &decoder->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_image_decoder_t *, lv_image_decoder_open_f_t))lv_func_ptr)(decoder, open_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_set_open_cb_mpobj, 2, mp_lv_image_decoder_set_open_cb, lv_image_decoder_set_open_cb);
    

/*
 * Callback function lv_image_decoder_t_read_line_cb
 * lv_result_t lv_image_decoder_get_area_cb_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc, const lv_area_t *full_area, lv_area_t *decoded_area)
 */

GENMPY_UNUSED STATIC lv_result_t lv_image_decoder_t_read_line_cb_callback(lv_image_decoder_t *arg0, lv_image_decoder_dsc_t *arg1, const lv_area_t *arg2, lv_area_t *arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_image_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_image_decoder_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_args[3] = mp_read_ptr_lv_area_t((void*)arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_image_decoder_t_read_line_cb)) , 4, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_image_decoder_set_get_area_cb(lv_image_decoder_t *decoder, lv_image_decoder_get_area_cb_t read_line_cb)
 */

STATIC mp_obj_t mp_lv_image_decoder_set_get_area_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    void *read_line_cb = mp_lv_callback(mp_args[1], &lv_image_decoder_t_read_line_cb_callback, MP_QSTR_lv_image_decoder_t_read_line_cb, &decoder->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_image_decoder_t *, lv_image_decoder_get_area_cb_t))lv_func_ptr)(decoder, read_line_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_set_get_area_cb_mpobj, 2, mp_lv_image_decoder_set_get_area_cb, lv_image_decoder_set_get_area_cb);
    

/*
 * Callback function lv_image_decoder_t_close_cb
 * void lv_image_decoder_close_f_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc)
 */

GENMPY_UNUSED STATIC void lv_image_decoder_t_close_cb_callback(lv_image_decoder_t *arg0, lv_image_decoder_dsc_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_image_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_image_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_image_decoder_t_close_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_image_decoder_set_close_cb(lv_image_decoder_t *decoder, lv_image_decoder_close_f_t close_cb)
 */

STATIC mp_obj_t mp_lv_image_decoder_set_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    void *close_cb = mp_lv_callback(mp_args[1], &lv_image_decoder_t_close_cb_callback, MP_QSTR_lv_image_decoder_t_close_cb, &decoder->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_image_decoder_t *, lv_image_decoder_close_f_t))lv_func_ptr)(decoder, close_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_set_close_cb_mpobj, 2, mp_lv_image_decoder_set_close_cb, lv_image_decoder_set_close_cb);
    

/*
 * Function NOT generated:
 * Callback function 'lv_cache_free_cb_t cache_free_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_cache_free_cb_t cache_free_cb
 */
    

/*
 * lvgl extension definition for:
 * void lv_image_decoder_set_cache_free_cb(lv_image_decoder_t *decoder, lv_cache_free_cb_t cache_free_cb)
 */

STATIC mp_obj_t mp_lv_image_decoder_set_cache_free_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_t *decoder = mp_write_ptr_lv_image_decoder_t(mp_args[0]);
    lv_cache_free_cb_t cache_free_cb = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_image_decoder_t *, lv_cache_free_cb_t))lv_func_ptr)(decoder, cache_free_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_set_cache_free_cb_mpobj, 2, mp_lv_image_decoder_set_cache_free_cb, lv_image_decoder_set_cache_free_cb);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_image_decoder_post_process(lv_image_decoder_dsc_t *dsc, lv_draw_buf_t *decoded)
 */

STATIC mp_obj_t mp_lv_image_decoder_post_process(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_image_decoder_dsc_t *dsc = mp_write_ptr_lv_image_decoder_dsc_t(mp_args[0]);
    lv_draw_buf_t *decoded = mp_write_ptr_lv_draw_buf_t(mp_args[1]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(lv_image_decoder_dsc_t *, lv_draw_buf_t *))lv_func_ptr)(dsc, decoded);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_decoder_post_process_mpobj, 2, mp_lv_image_decoder_post_process, lv_image_decoder_post_process);
    

/*
 * lvgl extension definition for:
 * lv_image_src_t lv_image_src_get_type(const void *src)
 */

STATIC mp_obj_t mp_lv_image_src_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = (const void *)mp_to_ptr(mp_args[0]);
    lv_image_src_t _res = ((lv_image_src_t (*)(const void *))lv_func_ptr)(src);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_image_src_get_type_mpobj, 1, mp_lv_image_src_get_type, lv_image_src_get_type);
    

/*
 * lvgl extension definition for:
 * void lv_image_set_src(lv_obj_t *obj, const void *src)
 */

STATIC mp_obj_t mp_lv_image_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *src = (const void *)mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, const void *))lv_func_ptr)(obj, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_src_mpobj, 2, mp_lv_image_set_src, lv_image_set_src);
    
/* Reusing lv_obj_move_to_index for lv_image_set_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_offset_x_mpobj, 2, mp_lv_obj_move_to_index, lv_image_set_offset_x);
    
/* Reusing lv_obj_move_to_index for lv_image_set_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_offset_y_mpobj, 2, mp_lv_obj_move_to_index, lv_image_set_offset_y);
    
/* Reusing lv_obj_move_to_index for lv_image_set_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_rotation_mpobj, 2, mp_lv_obj_move_to_index, lv_image_set_rotation);
    
/* Reusing lv_obj_set_pos for lv_image_set_pivot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_pivot_mpobj, 3, mp_lv_obj_set_pos, lv_image_set_pivot);
    
/* Reusing lv_obj_delete_delayed for lv_image_set_scale */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_scale_mpobj, 2, mp_lv_obj_delete_delayed, lv_image_set_scale);
    
/* Reusing lv_obj_delete_delayed for lv_image_set_scale_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_scale_x_mpobj, 2, mp_lv_obj_delete_delayed, lv_image_set_scale_x);
    
/* Reusing lv_obj_delete_delayed for lv_image_set_scale_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_scale_y_mpobj, 2, mp_lv_obj_delete_delayed, lv_image_set_scale_y);
    

/*
 * lvgl extension definition for:
 * void lv_image_set_blend_mode(lv_obj_t *obj, lv_blend_mode_t blend_mode)
 */

STATIC mp_obj_t mp_lv_image_set_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_blend_mode_t blend_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_blend_mode_t))lv_func_ptr)(obj, blend_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_blend_mode_mpobj, 2, mp_lv_image_set_blend_mode, lv_image_set_blend_mode);
    

/*
 * lvgl extension definition for:
 * void lv_image_set_antialias(lv_obj_t *obj, bool antialias)
 */

STATIC mp_obj_t mp_lv_image_set_antialias(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool antialias = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_obj_t *, bool))lv_func_ptr)(obj, antialias);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_antialias_mpobj, 2, mp_lv_image_set_antialias, lv_image_set_antialias);
    

/*
 * lvgl extension definition for:
 * void lv_image_set_align(lv_obj_t *obj, lv_image_align_t align)
 */

STATIC mp_obj_t mp_lv_image_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_image_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_image_align_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_set_align_mpobj, 2, mp_lv_image_set_align, lv_image_set_align);
    

/*
 * lvgl extension definition for:
 * const void *lv_image_get_src(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_image_get_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void * _res = ((const void *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_src_mpobj, 1, mp_lv_image_get_src, lv_image_get_src);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_offset_x_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_offset_x);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_offset_y_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_offset_y);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_rotation_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_rotation);
    
/* Reusing lv_obj_get_scroll_end for lv_image_get_pivot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_pivot_mpobj, 2, mp_lv_obj_get_scroll_end, lv_image_get_pivot);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_scale */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_scale_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_scale);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_scale_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_scale_x_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_scale_x);
    
/* Reusing lv_obj_get_scroll_top for lv_image_get_scale_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_scale_y_mpobj, 1, mp_lv_obj_get_scroll_top, lv_image_get_scale_y);
    

/*
 * lvgl extension definition for:
 * lv_blend_mode_t lv_image_get_blend_mode(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_image_get_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_blend_mode_t _res = ((lv_blend_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_blend_mode_mpobj, 1, mp_lv_image_get_blend_mode, lv_image_get_blend_mode);
    
/* Reusing lv_obj_refr_size for lv_image_get_antialias */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_antialias_mpobj, 1, mp_lv_obj_refr_size, lv_image_get_antialias);
    

/*
 * lvgl extension definition for:
 * lv_image_align_t lv_image_get_align(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_image_get_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_image_align_t _res = ((lv_image_align_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_get_align_mpobj, 1, mp_lv_image_get_align, lv_image_get_align);
    
/* Reusing lv_obj_create for lv_image_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_image_create_mpobj, 1, mp_lv_obj_create, lv_image_create);
    

/*
 * lvgl image object definitions
 */
    

STATIC const mp_rom_map_elem_t image_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_header_init), MP_ROM_PTR(&mp_lv_image_header_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_image_buf_set_palette_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_image_buf_free_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cache_drop), MP_ROM_PTR(&mp_lv_image_cache_drop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_get_info), MP_ROM_PTR(&mp_lv_image_decoder_get_info_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_open), MP_ROM_PTR(&mp_lv_image_decoder_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_get_area), MP_ROM_PTR(&mp_lv_image_decoder_get_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_close), MP_ROM_PTR(&mp_lv_image_decoder_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_create), MP_ROM_PTR(&mp_lv_image_decoder_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_delete), MP_ROM_PTR(&mp_lv_image_decoder_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_get_next), MP_ROM_PTR(&mp_lv_image_decoder_get_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_info_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_info_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_open_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_open_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_get_area_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_get_area_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_close_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_close_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_cache_free_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_cache_free_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_post_process), MP_ROM_PTR(&mp_lv_image_decoder_post_process_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_src_get_type), MP_ROM_PTR(&mp_lv_image_src_get_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_image_set_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_x), MP_ROM_PTR(&mp_lv_image_set_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_y), MP_ROM_PTR(&mp_lv_image_set_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_image_set_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pivot), MP_ROM_PTR(&mp_lv_image_set_pivot_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale), MP_ROM_PTR(&mp_lv_image_set_scale_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_x), MP_ROM_PTR(&mp_lv_image_set_scale_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_y), MP_ROM_PTR(&mp_lv_image_set_scale_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_blend_mode), MP_ROM_PTR(&mp_lv_image_set_blend_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_antialias), MP_ROM_PTR(&mp_lv_image_set_antialias_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_image_set_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_src), MP_ROM_PTR(&mp_lv_image_get_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_x), MP_ROM_PTR(&mp_lv_image_get_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_y), MP_ROM_PTR(&mp_lv_image_get_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_rotation), MP_ROM_PTR(&mp_lv_image_get_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_pivot), MP_ROM_PTR(&mp_lv_image_get_pivot_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale), MP_ROM_PTR(&mp_lv_image_get_scale_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale_x), MP_ROM_PTR(&mp_lv_image_get_scale_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale_y), MP_ROM_PTR(&mp_lv_image_get_scale_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_blend_mode), MP_ROM_PTR(&mp_lv_image_get_blend_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialias), MP_ROM_PTR(&mp_lv_image_get_antialias_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_image_get_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_SRC), MP_ROM_PTR(&mp_lv_LV_IMAGE_SRC_type_base) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(&mp_lv_LV_IMAGE_ALIGN_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FLAGS), MP_ROM_PTR(&mp_lv_LV_IMAGE_FLAGS_type_base) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESS), MP_ROM_PTR(&mp_lv_LV_IMAGE_COMPRESS_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(image_locals_dict, image_locals_dict_table);

STATIC void image_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl image");
}


STATIC mp_obj_t image_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_image_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_image_type_base,
    MP_QSTR_image,
    MP_TYPE_FLAG_NONE,
    print, image_print,
    make_new, image_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &image_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_image_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_image_class,
#endif
    .mp_obj_type = &mp_lv_image_type_base,
};
    

/*
 * Array convertors for void *[]
 */

GENMPY_UNUSED STATIC void * *mp_arr_to_void_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    void * *lv_arr = (void **)m_malloc(len * sizeof(void *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_to_ptr(item);
    }
    return (void * *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_void_ptr____(const void * *arr)
{
    return ptr_to_mp((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_animimg_set_src(lv_obj_t *img, const void *dsc[], size_t num)
 */

STATIC mp_obj_t mp_lv_animimg_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    const void **dsc = (const void **)mp_arr_to_void_ptr____(mp_args[1]);
    size_t num = (size_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const void *[], size_t))lv_func_ptr)(img, dsc, num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_src_mpobj, 3, mp_lv_animimg_set_src, lv_animimg_set_src);
    
/* Reusing lv_obj_center for lv_animimg_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_start_mpobj, 1, mp_lv_obj_center, lv_animimg_start);
    
/* Reusing lv_obj_delete_delayed for lv_animimg_set_duration */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_duration_mpobj, 2, mp_lv_obj_delete_delayed, lv_animimg_set_duration);
    
/* Reusing lv_obj_delete_delayed for lv_animimg_set_repeat_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_repeat_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_animimg_set_repeat_count);
    

/*
 * Function NOT generated:
 * Missing conversion from const void **
 * const void **lv_animimg_get_src(lv_obj_t *img)
 */
    

/*
 * lvgl extension definition for:
 * uint8_t lv_animimg_get_src_count(lv_obj_t *img)
 */

STATIC mp_obj_t mp_lv_animimg_get_src_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_obj_t *))lv_func_ptr)(img);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_get_src_count_mpobj, 1, mp_lv_animimg_get_src_count, lv_animimg_get_src_count);
    
/* Reusing lv_obj_get_event_count for lv_animimg_get_duration */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_get_duration_mpobj, 1, mp_lv_obj_get_event_count, lv_animimg_get_duration);
    
/* Reusing lv_obj_get_event_count for lv_animimg_get_repeat_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_get_repeat_count_mpobj, 1, mp_lv_obj_get_event_count, lv_animimg_get_repeat_count);
    
/* Reusing lv_obj_create for lv_animimg_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_create_mpobj, 1, mp_lv_obj_create, lv_animimg_create);
    

/*
 * lvgl animimg object definitions
 */
    

STATIC const mp_rom_map_elem_t animimg_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_animimg_set_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_animimg_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_duration), MP_ROM_PTR(&mp_lv_animimg_set_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_animimg_set_repeat_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_count), MP_ROM_PTR(&mp_lv_animimg_get_src_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_duration), MP_ROM_PTR(&mp_lv_animimg_get_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_repeat_count), MP_ROM_PTR(&mp_lv_animimg_get_repeat_count_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(animimg_locals_dict, animimg_locals_dict_table);

STATIC void animimg_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl animimg");
}


STATIC mp_obj_t animimg_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_animimg_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_animimg_type_base,
    MP_QSTR_animimg,
    MP_TYPE_FLAG_NONE,
    print, animimg_print,
    make_new, animimg_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &animimg_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_animimg_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_animimg_class,
#endif
    .mp_obj_type = &mp_lv_animimg_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_start_angle(lv_obj_t *obj, lv_value_precise_t start)
 */

STATIC mp_obj_t mp_lv_arc_set_start_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_value_precise_t start = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_value_precise_t))lv_func_ptr)(obj, start);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_start_angle_mpobj, 2, mp_lv_arc_set_start_angle, lv_arc_set_start_angle);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_end_angle_mpobj, 2, mp_lv_arc_set_start_angle, lv_arc_set_end_angle);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_angles(lv_obj_t *obj, lv_value_precise_t start, lv_value_precise_t end)
 */

STATIC mp_obj_t mp_lv_arc_set_angles(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_value_precise_t start = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_value_precise_t end = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_value_precise_t, lv_value_precise_t))lv_func_ptr)(obj, start, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_angles_mpobj, 3, mp_lv_arc_set_angles, lv_arc_set_angles);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_bg_start_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_start_angle_mpobj, 2, mp_lv_arc_set_start_angle, lv_arc_set_bg_start_angle);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_bg_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_end_angle_mpobj, 2, mp_lv_arc_set_start_angle, lv_arc_set_bg_end_angle);
    
/* Reusing lv_arc_set_angles for lv_arc_set_bg_angles */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_angles_mpobj, 3, mp_lv_arc_set_angles, lv_arc_set_bg_angles);
    
/* Reusing lv_obj_move_to_index for lv_arc_set_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_rotation_mpobj, 2, mp_lv_obj_move_to_index, lv_arc_set_rotation);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_mode(lv_obj_t *obj, lv_arc_mode_t type)
 */

STATIC mp_obj_t mp_lv_arc_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_arc_mode_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_arc_mode_t))lv_func_ptr)(obj, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_mode_mpobj, 2, mp_lv_arc_set_mode, lv_arc_set_mode);
    
/* Reusing lv_obj_move_to_index for lv_arc_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_value_mpobj, 2, mp_lv_obj_move_to_index, lv_arc_set_value);
    
/* Reusing lv_obj_set_pos for lv_arc_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_range_mpobj, 3, mp_lv_obj_set_pos, lv_arc_set_range);
    
/* Reusing lv_obj_delete_delayed for lv_arc_set_change_rate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_change_rate_mpobj, 2, mp_lv_obj_delete_delayed, lv_arc_set_change_rate);
    
/* Reusing lv_obj_move_to_index for lv_arc_set_knob_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_knob_offset_mpobj, 2, mp_lv_obj_move_to_index, lv_arc_set_knob_offset);
    

/*
 * lvgl extension definition for:
 * lv_value_precise_t lv_arc_get_angle_start(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_arc_get_angle_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_value_precise_t _res = ((lv_value_precise_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_start_mpobj, 1, mp_lv_arc_get_angle_start, lv_arc_get_angle_start);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_end_mpobj, 1, mp_lv_arc_get_angle_start, lv_arc_get_angle_end);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_bg_angle_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_start_mpobj, 1, mp_lv_arc_get_angle_start, lv_arc_get_bg_angle_start);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_bg_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_end_mpobj, 1, mp_lv_arc_get_angle_start, lv_arc_get_bg_angle_end);
    
/* Reusing lv_obj_get_index for lv_arc_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_value_mpobj, 1, mp_lv_obj_get_index, lv_arc_get_value);
    
/* Reusing lv_obj_get_index for lv_arc_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_min_value_mpobj, 1, mp_lv_obj_get_index, lv_arc_get_min_value);
    
/* Reusing lv_obj_get_index for lv_arc_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_max_value_mpobj, 1, mp_lv_obj_get_index, lv_arc_get_max_value);
    

/*
 * lvgl extension definition for:
 * lv_arc_mode_t lv_arc_get_mode(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_arc_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_arc_mode_t _res = ((lv_arc_mode_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_mode_mpobj, 1, mp_lv_arc_get_mode, lv_arc_get_mode);
    
/* Reusing lv_obj_get_index for lv_arc_get_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_rotation_mpobj, 1, mp_lv_obj_get_index, lv_arc_get_rotation);
    
/* Reusing lv_obj_get_index for lv_arc_get_knob_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_knob_offset_mpobj, 1, mp_lv_obj_get_index, lv_arc_get_knob_offset);
    

/*
 * lvgl extension definition for:
 * void lv_arc_align_obj_to_angle(const lv_obj_t *obj, lv_obj_t *obj_to_align, int32_t r_offset)
 */

STATIC mp_obj_t mp_lv_arc_align_obj_to_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_obj_t *obj_to_align = mp_to_lv(mp_args[1]);
    int32_t r_offset = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, lv_obj_t *, int32_t))lv_func_ptr)(obj, obj_to_align, r_offset);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_align_obj_to_angle_mpobj, 3, mp_lv_arc_align_obj_to_angle, lv_arc_align_obj_to_angle);
    
/* Reusing lv_arc_align_obj_to_angle for lv_arc_rotate_obj_to_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_rotate_obj_to_angle_mpobj, 3, mp_lv_arc_align_obj_to_angle, lv_arc_rotate_obj_to_angle);
    

/*
 * lvgl extension definition for:
 * lv_observer_t *lv_arc_bind_value(lv_obj_t *obj, lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_arc_bind_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[1]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_obj_t *, lv_subject_t *))lv_func_ptr)(obj, subject);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_bind_value_mpobj, 2, mp_lv_arc_bind_value, lv_arc_bind_value);
    
/* Reusing lv_obj_create for lv_arc_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_create_mpobj, 1, mp_lv_obj_create, lv_arc_create);
    

/*
 * lvgl arc object definitions
 */
    

STATIC const mp_rom_map_elem_t arc_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_start_angle), MP_ROM_PTR(&mp_lv_arc_set_start_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_end_angle), MP_ROM_PTR(&mp_lv_arc_set_end_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_angles), MP_ROM_PTR(&mp_lv_arc_set_angles_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_start_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_start_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_end_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_end_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_angles), MP_ROM_PTR(&mp_lv_arc_set_bg_angles_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_arc_set_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_arc_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_arc_set_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_arc_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_change_rate), MP_ROM_PTR(&mp_lv_arc_set_change_rate_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_knob_offset), MP_ROM_PTR(&mp_lv_arc_set_knob_offset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_start), MP_ROM_PTR(&mp_lv_arc_get_angle_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_end), MP_ROM_PTR(&mp_lv_arc_get_angle_end_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_start), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_end), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_end_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_arc_get_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_arc_get_min_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_arc_get_max_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_arc_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_rotation), MP_ROM_PTR(&mp_lv_arc_get_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_knob_offset), MP_ROM_PTR(&mp_lv_arc_get_knob_offset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_align_obj_to_angle), MP_ROM_PTR(&mp_lv_arc_align_obj_to_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_rotate_obj_to_angle), MP_ROM_PTR(&mp_lv_arc_rotate_obj_to_angle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_value), MP_ROM_PTR(&mp_lv_arc_bind_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_ARC_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(arc_locals_dict, arc_locals_dict_table);

STATIC void arc_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl arc");
}


STATIC mp_obj_t arc_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_arc_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_arc_type_base,
    MP_QSTR_arc,
    MP_TYPE_FLAG_NONE,
    print, arc_print,
    make_new, arc_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &arc_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_arc_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_arc_class,
#endif
    .mp_obj_type = &mp_lv_arc_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_label_set_text(lv_obj_t *obj, const char *text)
 */

STATIC mp_obj_t mp_lv_label_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *text = (const char *)(char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *))lv_func_ptr)(obj, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_mpobj, 2, mp_lv_label_set_text, lv_label_set_text);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_label_set_text_fmt(lv_obj_t *obj, const char *fmt, ...)
 */
    
/* Reusing lv_label_set_text for lv_label_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_static_mpobj, 2, mp_lv_label_set_text, lv_label_set_text_static);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_long_mode(lv_obj_t *obj, lv_label_long_mode_t long_mode)
 */

STATIC mp_obj_t mp_lv_label_set_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_label_long_mode_t long_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_label_long_mode_t))lv_func_ptr)(obj, long_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_long_mode_mpobj, 2, mp_lv_label_set_long_mode, lv_label_set_long_mode);
    
/* Reusing lv_obj_delete_delayed for lv_label_set_text_selection_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_selection_start_mpobj, 2, mp_lv_obj_delete_delayed, lv_label_set_text_selection_start);
    
/* Reusing lv_obj_delete_delayed for lv_label_set_text_selection_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_selection_end_mpobj, 2, mp_lv_obj_delete_delayed, lv_label_set_text_selection_end);
    

/*
 * lvgl extension definition for:
 * char *lv_label_get_text(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_label_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    char * _res = ((char *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_mpobj, 1, mp_lv_label_get_text, lv_label_get_text);
    

/*
 * lvgl extension definition for:
 * lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_label_get_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_label_long_mode_t _res = ((lv_label_long_mode_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_long_mode_mpobj, 1, mp_lv_label_get_long_mode, lv_label_get_long_mode);
    

/*
 * lvgl extension definition for:
 * void lv_label_get_letter_pos(const lv_obj_t *obj, uint32_t char_id, lv_point_t *pos)
 */

STATIC mp_obj_t mp_lv_label_get_letter_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t char_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(const lv_obj_t *, uint32_t, lv_point_t *))lv_func_ptr)(obj, char_id, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_pos_mpobj, 3, mp_lv_label_get_letter_pos, lv_label_get_letter_pos);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_label_get_letter_on(const lv_obj_t *obj, lv_point_t *pos_in, bool bidi)
 */

STATIC mp_obj_t mp_lv_label_get_letter_on(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_point_t *pos_in = mp_write_ptr_lv_point_t(mp_args[1]);
    bool bidi = mp_obj_is_true(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, lv_point_t *, bool))lv_func_ptr)(obj, pos_in, bidi);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_on_mpobj, 3, mp_lv_label_get_letter_on, lv_label_get_letter_on);
    

/*
 * lvgl extension definition for:
 * bool lv_label_is_char_under_pos(const lv_obj_t *obj, lv_point_t *pos)
 */

STATIC mp_obj_t mp_lv_label_is_char_under_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, pos);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_is_char_under_pos_mpobj, 2, mp_lv_label_is_char_under_pos, lv_label_is_char_under_pos);
    
/* Reusing lv_obj_get_child_count for lv_label_get_text_selection_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_selection_start_mpobj, 1, mp_lv_obj_get_child_count, lv_label_get_text_selection_start);
    
/* Reusing lv_obj_get_child_count for lv_label_get_text_selection_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_selection_end_mpobj, 1, mp_lv_obj_get_child_count, lv_label_get_text_selection_end);
    

/*
 * lvgl extension definition for:
 * void lv_label_ins_text(lv_obj_t *obj, uint32_t pos, const char *txt)
 */

STATIC mp_obj_t mp_lv_label_ins_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, const char *))lv_func_ptr)(obj, pos, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_ins_text_mpobj, 3, mp_lv_label_ins_text, lv_label_ins_text);
    
/* Reusing lv_obj_fade_in for lv_label_cut_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_cut_text_mpobj, 3, mp_lv_obj_fade_in, lv_label_cut_text);
    

/*
 * lvgl extension definition for:
 * lv_observer_t *lv_label_bind_text(lv_obj_t *obj, lv_subject_t *subject, const char *fmt)
 */

STATIC mp_obj_t mp_lv_label_bind_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[1]);
    const char *fmt = (const char *)(char*)convert_from_str(mp_args[2]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_obj_t *, lv_subject_t *, const char *))lv_func_ptr)(obj, subject, fmt);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_bind_text_mpobj, 3, mp_lv_label_bind_text, lv_label_bind_text);
    
/* Reusing lv_obj_create for lv_label_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_create_mpobj, 1, mp_lv_obj_create, lv_label_create);
    

/*
 * lvgl label object definitions
 */
    

STATIC const mp_rom_map_elem_t label_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_label_set_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_label_set_text_static_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_long_mode), MP_ROM_PTR(&mp_lv_label_set_long_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_selection_start), MP_ROM_PTR(&mp_lv_label_set_text_selection_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_selection_end), MP_ROM_PTR(&mp_lv_label_set_text_selection_end_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_label_get_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_long_mode), MP_ROM_PTR(&mp_lv_label_get_long_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_pos), MP_ROM_PTR(&mp_lv_label_get_letter_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_on), MP_ROM_PTR(&mp_lv_label_get_letter_on_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_char_under_pos), MP_ROM_PTR(&mp_lv_label_is_char_under_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection_start), MP_ROM_PTR(&mp_lv_label_get_text_selection_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection_end), MP_ROM_PTR(&mp_lv_label_get_text_selection_end_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_ins_text), MP_ROM_PTR(&mp_lv_label_ins_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cut_text), MP_ROM_PTR(&mp_lv_label_cut_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_text), MP_ROM_PTR(&mp_lv_label_bind_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_LONG), MP_ROM_PTR(&mp_lv_LV_LABEL_LONG_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(label_locals_dict, label_locals_dict_table);

STATIC void label_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl label");
}


STATIC mp_obj_t label_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_label_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_label_type_base,
    MP_QSTR_label,
    MP_TYPE_FLAG_NONE,
    print, label_print,
    make_new, label_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &label_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_label_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_label_class,
#endif
    .mp_obj_type = &mp_lv_label_type_base,
};
    
/* Reusing lv_obj_scroll_to_x for lv_bar_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_value_mpobj, 3, mp_lv_obj_scroll_to_x, lv_bar_set_value);
    
/* Reusing lv_obj_scroll_to_x for lv_bar_set_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_start_value_mpobj, 3, mp_lv_obj_scroll_to_x, lv_bar_set_start_value);
    
/* Reusing lv_obj_set_pos for lv_bar_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_range_mpobj, 3, mp_lv_obj_set_pos, lv_bar_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_mode(lv_obj_t *obj, lv_bar_mode_t mode)
 */

STATIC mp_obj_t mp_lv_bar_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bar_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_bar_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_mode_mpobj, 2, mp_lv_bar_set_mode, lv_bar_set_mode);
    
/* Reusing lv_obj_get_index for lv_bar_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_value_mpobj, 1, mp_lv_obj_get_index, lv_bar_get_value);
    
/* Reusing lv_obj_get_index for lv_bar_get_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_start_value_mpobj, 1, mp_lv_obj_get_index, lv_bar_get_start_value);
    
/* Reusing lv_obj_get_index for lv_bar_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_min_value_mpobj, 1, mp_lv_obj_get_index, lv_bar_get_min_value);
    
/* Reusing lv_obj_get_index for lv_bar_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_max_value_mpobj, 1, mp_lv_obj_get_index, lv_bar_get_max_value);
    

/*
 * lvgl extension definition for:
 * lv_bar_mode_t lv_bar_get_mode(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_bar_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bar_mode_t _res = ((lv_bar_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_mode_mpobj, 1, mp_lv_bar_get_mode, lv_bar_get_mode);
    
/* Reusing lv_obj_refr_size for lv_bar_is_symmetrical */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_is_symmetrical_mpobj, 1, mp_lv_obj_refr_size, lv_bar_is_symmetrical);
    
/* Reusing lv_obj_create for lv_bar_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_create_mpobj, 1, mp_lv_obj_create, lv_bar_create);
    

/*
 * lvgl bar object definitions
 */
    

STATIC const mp_rom_map_elem_t bar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_bar_set_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_value), MP_ROM_PTR(&mp_lv_bar_set_start_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_bar_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_bar_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_bar_get_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_start_value), MP_ROM_PTR(&mp_lv_bar_get_start_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_bar_get_min_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_bar_get_max_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_bar_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_symmetrical), MP_ROM_PTR(&mp_lv_bar_is_symmetrical_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_BAR_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(bar_locals_dict, bar_locals_dict_table);

STATIC void bar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl bar");
}


STATIC mp_obj_t bar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_bar_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_bar_type_base,
    MP_QSTR_bar,
    MP_TYPE_FLAG_NONE,
    print, bar_print,
    make_new, bar_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &bar_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_bar_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_bar_class,
#endif
    .mp_obj_type = &mp_lv_bar_type_base,
};
    
/* Reusing lv_arc_bind_value for lv_button_bind_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_button_bind_checked_mpobj, 2, mp_lv_arc_bind_value, lv_button_bind_checked);
    
/* Reusing lv_obj_create for lv_button_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_button_create_mpobj, 1, mp_lv_obj_create, lv_button_create);
    

/*
 * lvgl button object definitions
 */
    

STATIC const mp_rom_map_elem_t button_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_bind_checked), MP_ROM_PTR(&mp_lv_button_bind_checked_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(button_locals_dict, button_locals_dict_table);

STATIC void button_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl button");
}


STATIC mp_obj_t button_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_button_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_button_type_base,
    MP_QSTR_button,
    MP_TYPE_FLAG_NONE,
    print, button_print,
    make_new, button_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &button_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_button_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_button_class,
#endif
    .mp_obj_type = &mp_lv_button_type_base,
};
    

/*
 * Array convertors for char *[]
 */

GENMPY_UNUSED STATIC char * *mp_arr_to_char_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    char * *lv_arr = (char **)m_malloc(len * sizeof(char *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char*)convert_from_str(item);
    }
    return (char * *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_char_ptr____(const char * *arr)
{
    return mp_read_ptr_C_Pointer((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_buttonmatrix_set_map(lv_obj_t *obj, const char *map[])
 */

STATIC mp_obj_t mp_lv_buttonmatrix_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char **map = (const char **)mp_arr_to_char_ptr____(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *[]))lv_func_ptr)(obj, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_map_mpobj, 2, mp_lv_buttonmatrix_set_map, lv_buttonmatrix_set_map);
    

/*
 * Array convertors for lv_buttonmatrix_ctrl_t []
 */

GENMPY_UNUSED STATIC lv_buttonmatrix_ctrl_t *mp_arr_to_lv_buttonmatrix_ctrl_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_buttonmatrix_ctrl_t *lv_arr = (lv_buttonmatrix_ctrl_t*)m_malloc(len * sizeof(lv_buttonmatrix_ctrl_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint32_t)mp_obj_get_int(item);
    }
    return (lv_buttonmatrix_ctrl_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_buttonmatrix_ctrl_t_____(const lv_buttonmatrix_ctrl_t *arr)
{
    return mp_array_from_u32ptr((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_buttonmatrix_set_ctrl_map(lv_obj_t *obj, const lv_buttonmatrix_ctrl_t ctrl_map[])
 */

STATIC mp_obj_t mp_lv_buttonmatrix_set_ctrl_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_buttonmatrix_ctrl_t *ctrl_map = (const lv_buttonmatrix_ctrl_t *)mp_arr_to_lv_buttonmatrix_ctrl_t_____(mp_args[1]);
    ((void (*)(lv_obj_t *, const lv_buttonmatrix_ctrl_t []))lv_func_ptr)(obj, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_ctrl_map_mpobj, 2, mp_lv_buttonmatrix_set_ctrl_map, lv_buttonmatrix_set_ctrl_map);
    
/* Reusing lv_obj_delete_delayed for lv_buttonmatrix_set_selected_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_selected_button_mpobj, 2, mp_lv_obj_delete_delayed, lv_buttonmatrix_set_selected_button);
    

/*
 * lvgl extension definition for:
 * void lv_buttonmatrix_set_button_ctrl(lv_obj_t *obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl)
 */

STATIC mp_obj_t mp_lv_buttonmatrix_set_button_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t btn_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_buttonmatrix_ctrl_t ctrl = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_buttonmatrix_ctrl_t))lv_func_ptr)(obj, btn_id, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_button_ctrl_mpobj, 3, mp_lv_buttonmatrix_set_button_ctrl, lv_buttonmatrix_set_button_ctrl);
    
/* Reusing lv_buttonmatrix_set_button_ctrl for lv_buttonmatrix_clear_button_ctrl */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_clear_button_ctrl_mpobj, 3, mp_lv_buttonmatrix_set_button_ctrl, lv_buttonmatrix_clear_button_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_buttonmatrix_set_button_ctrl_all(lv_obj_t *obj, lv_buttonmatrix_ctrl_t ctrl)
 */

STATIC mp_obj_t mp_lv_buttonmatrix_set_button_ctrl_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_buttonmatrix_ctrl_t ctrl = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_buttonmatrix_ctrl_t))lv_func_ptr)(obj, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_button_ctrl_all_mpobj, 2, mp_lv_buttonmatrix_set_button_ctrl_all, lv_buttonmatrix_set_button_ctrl_all);
    
/* Reusing lv_buttonmatrix_set_button_ctrl_all for lv_buttonmatrix_clear_button_ctrl_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_clear_button_ctrl_all_mpobj, 2, mp_lv_buttonmatrix_set_button_ctrl_all, lv_buttonmatrix_clear_button_ctrl_all);
    
/* Reusing lv_obj_fade_in for lv_buttonmatrix_set_button_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_button_width_mpobj, 3, mp_lv_obj_fade_in, lv_buttonmatrix_set_button_width);
    
/* Reusing lv_image_set_antialias for lv_buttonmatrix_set_one_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_set_one_checked_mpobj, 2, mp_lv_image_set_antialias, lv_buttonmatrix_set_one_checked);
    

/*
 * lvgl extension definition for:
 * const char **lv_buttonmatrix_get_map(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_buttonmatrix_get_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const char ** _res = ((const char **(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_C_Pointer((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_get_map_mpobj, 1, mp_lv_buttonmatrix_get_map, lv_buttonmatrix_get_map);
    
/* Reusing lv_obj_get_child_count for lv_buttonmatrix_get_selected_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_get_selected_button_mpobj, 1, mp_lv_obj_get_child_count, lv_buttonmatrix_get_selected_button);
    

/*
 * lvgl extension definition for:
 * const char *lv_buttonmatrix_get_button_text(const lv_obj_t *obj, uint32_t btn_id)
 */

STATIC mp_obj_t mp_lv_buttonmatrix_get_button_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint32_t btn_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char * _res = ((const char *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, btn_id);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_get_button_text_mpobj, 2, mp_lv_buttonmatrix_get_button_text, lv_buttonmatrix_get_button_text);
    

/*
 * lvgl extension definition for:
 * bool lv_buttonmatrix_has_button_ctrl(lv_obj_t *obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl)
 */

STATIC mp_obj_t mp_lv_buttonmatrix_has_button_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t btn_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_buttonmatrix_ctrl_t ctrl = (uint32_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, uint32_t, lv_buttonmatrix_ctrl_t))lv_func_ptr)(obj, btn_id, ctrl);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_has_button_ctrl_mpobj, 3, mp_lv_buttonmatrix_has_button_ctrl, lv_buttonmatrix_has_button_ctrl);
    
/* Reusing lv_obj_is_layout_positioned for lv_buttonmatrix_get_one_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_get_one_checked_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_buttonmatrix_get_one_checked);
    
/* Reusing lv_obj_is_layout_positioned for lv_buttonmatrix_get_popovers */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_get_popovers_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_buttonmatrix_get_popovers);
    
/* Reusing lv_obj_create for lv_buttonmatrix_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_buttonmatrix_create_mpobj, 1, mp_lv_obj_create, lv_buttonmatrix_create);
    

/*
 * lvgl buttonmatrix object definitions
 */
    

STATIC const mp_rom_map_elem_t buttonmatrix_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_buttonmatrix_set_map_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_ctrl_map), MP_ROM_PTR(&mp_lv_buttonmatrix_set_ctrl_map_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected_button), MP_ROM_PTR(&mp_lv_buttonmatrix_set_selected_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_ctrl), MP_ROM_PTR(&mp_lv_buttonmatrix_set_button_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_button_ctrl), MP_ROM_PTR(&mp_lv_buttonmatrix_clear_button_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_ctrl_all), MP_ROM_PTR(&mp_lv_buttonmatrix_set_button_ctrl_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_button_ctrl_all), MP_ROM_PTR(&mp_lv_buttonmatrix_clear_button_ctrl_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_width), MP_ROM_PTR(&mp_lv_buttonmatrix_set_button_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_checked), MP_ROM_PTR(&mp_lv_buttonmatrix_set_one_checked_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_map), MP_ROM_PTR(&mp_lv_buttonmatrix_get_map_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_button), MP_ROM_PTR(&mp_lv_buttonmatrix_get_selected_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_button_text), MP_ROM_PTR(&mp_lv_buttonmatrix_get_button_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_button_ctrl), MP_ROM_PTR(&mp_lv_buttonmatrix_has_button_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_checked), MP_ROM_PTR(&mp_lv_buttonmatrix_get_one_checked_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_popovers), MP_ROM_PTR(&mp_lv_buttonmatrix_get_popovers_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_CTRL), MP_ROM_PTR(&mp_lv_LV_BUTTONMATRIX_CTRL_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(buttonmatrix_locals_dict, buttonmatrix_locals_dict_table);

STATIC void buttonmatrix_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl buttonmatrix");
}


STATIC mp_obj_t buttonmatrix_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_buttonmatrix_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_buttonmatrix_type_base,
    MP_QSTR_buttonmatrix,
    MP_TYPE_FLAG_NONE,
    print, buttonmatrix_print,
    make_new, buttonmatrix_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &buttonmatrix_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_buttonmatrix_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_buttonmatrix_class,
#endif
    .mp_obj_type = &mp_lv_buttonmatrix_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_today_date(lv_obj_t *obj, uint32_t year, uint32_t month, uint32_t day)
 */

STATIC mp_obj_t mp_lv_calendar_set_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t year = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t month = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t day = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, uint32_t))lv_func_ptr)(obj, year, month, day);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_today_date_mpobj, 4, mp_lv_calendar_set_today_date, lv_calendar_set_today_date);
    
/* Reusing lv_obj_fade_in for lv_calendar_set_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_showed_date_mpobj, 3, mp_lv_obj_fade_in, lv_calendar_set_showed_date);
    

/*
 * Struct lv_calendar_date_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type();

STATIC inline void* mp_write_ptr_lv_calendar_date_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_calendar_date_t_type()));
    return (lv_calendar_date_t*)self->data;
}

#define mp_write_lv_calendar_date_t(struct_obj) *((lv_calendar_date_t*)mp_write_ptr_lv_calendar_date_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_calendar_date_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_calendar_date_t_type(), field);
}

#define mp_read_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(copy_buffer(&field, sizeof(lv_calendar_date_t)))
#define mp_read_byref_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(&field)

STATIC void mp_lv_calendar_date_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_calendar_date_t *data = (lv_calendar_date_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_year: dest[0] = mp_obj_new_int_from_uint(data->year); break; // converting from uint16_t;
            case MP_QSTR_month: dest[0] = mp_obj_new_int(data->month); break; // converting from int8_t;
            case MP_QSTR_day: dest[0] = mp_obj_new_int(data->day); break; // converting from int8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_year: data->year = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_month: data->month = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_day: data->day = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_calendar_date_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_calendar_date_t");
}

STATIC const mp_obj_dict_t mp_lv_calendar_date_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_calendar_date_t_type,
    MP_QSTR_lv_calendar_date_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_calendar_date_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_calendar_date_t_attr,
    locals_dict, &mp_lv_calendar_date_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type()
{
    return &mp_lv_calendar_date_t_type;
}
    

/*
 * Array convertors for lv_calendar_date_t []
 */

GENMPY_UNUSED STATIC lv_calendar_date_t *mp_arr_to_lv_calendar_date_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_calendar_date_t *lv_arr = (lv_calendar_date_t*)m_malloc(len * sizeof(lv_calendar_date_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_calendar_date_t(item);
    }
    return (lv_calendar_date_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_calendar_date_t_____(lv_calendar_date_t *arr)
{
    return mp_read_ptr_lv_calendar_date_t((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_calendar_set_highlighted_dates(lv_obj_t *obj, lv_calendar_date_t highlighted[], size_t date_num)
 */

STATIC mp_obj_t mp_lv_calendar_set_highlighted_dates(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_calendar_date_t *highlighted = mp_arr_to_lv_calendar_date_t_____(mp_args[1]);
    size_t date_num = (size_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_calendar_date_t [], size_t))lv_func_ptr)(obj, highlighted, date_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_highlighted_dates_mpobj, 3, mp_lv_calendar_set_highlighted_dates, lv_calendar_set_highlighted_dates);
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_day_names(lv_obj_t *obj, const char **day_names)
 */

STATIC mp_obj_t mp_lv_calendar_set_day_names(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char **day_names = (const char **)mp_write_ptr_C_Pointer(mp_args[1]);
    ((void (*)(lv_obj_t *, const char **))lv_func_ptr)(obj, day_names);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_day_names_mpobj, 2, mp_lv_calendar_set_day_names, lv_calendar_set_day_names);
    
/* Reusing lv_obj_get_screen for lv_calendar_get_btnmatrix */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_btnmatrix_mpobj, 1, mp_lv_obj_get_screen, lv_calendar_get_btnmatrix);
    

/*
 * lvgl extension definition for:
 * const lv_calendar_date_t *lv_calendar_get_today_date(const lv_obj_t *calendar)
 */

STATIC mp_obj_t mp_lv_calendar_get_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_calendar_date_t * _res = ((const lv_calendar_date_t *(*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_read_ptr_lv_calendar_date_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_today_date_mpobj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_today_date);
    
/* Reusing lv_calendar_get_today_date for lv_calendar_get_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_showed_date_mpobj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_showed_date);
    

/*
 * lvgl extension definition for:
 * lv_calendar_date_t *lv_calendar_get_highlighted_dates(const lv_obj_t *calendar)
 */

STATIC mp_obj_t mp_lv_calendar_get_highlighted_dates(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_calendar_date_t * _res = ((lv_calendar_date_t *(*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_read_ptr_lv_calendar_date_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_mpobj, 1, mp_lv_calendar_get_highlighted_dates, lv_calendar_get_highlighted_dates);
    

/*
 * lvgl extension definition for:
 * size_t lv_calendar_get_highlighted_dates_num(const lv_obj_t *calendar)
 */

STATIC mp_obj_t mp_lv_calendar_get_highlighted_dates_num(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    size_t _res = ((size_t (*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_num_mpobj, 1, mp_lv_calendar_get_highlighted_dates_num, lv_calendar_get_highlighted_dates_num);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_calendar_get_pressed_date(const lv_obj_t *calendar, lv_calendar_date_t *date)
 */

STATIC mp_obj_t mp_lv_calendar_get_pressed_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_calendar_date_t *date = mp_write_ptr_lv_calendar_date_t(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(const lv_obj_t *, lv_calendar_date_t *))lv_func_ptr)(calendar, date);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_pressed_date_mpobj, 2, mp_lv_calendar_get_pressed_date, lv_calendar_get_pressed_date);
    
/* Reusing lv_label_set_text for lv_calendar_header_dropdown_set_year_list */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_header_dropdown_set_year_list_mpobj, 2, mp_lv_label_set_text, lv_calendar_header_dropdown_set_year_list);
    
/* Reusing lv_obj_create for lv_calendar_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_create_mpobj, 1, mp_lv_obj_create, lv_calendar_create);
    

/*
 * lvgl calendar object definitions
 */
    

STATIC const mp_rom_map_elem_t calendar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_today_date), MP_ROM_PTR(&mp_lv_calendar_set_today_date_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_showed_date), MP_ROM_PTR(&mp_lv_calendar_set_showed_date_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_set_highlighted_dates_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_day_names), MP_ROM_PTR(&mp_lv_calendar_set_day_names_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_btnmatrix), MP_ROM_PTR(&mp_lv_calendar_get_btnmatrix_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_today_date), MP_ROM_PTR(&mp_lv_calendar_get_today_date_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_showed_date), MP_ROM_PTR(&mp_lv_calendar_get_showed_date_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates_num), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_num_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_date), MP_ROM_PTR(&mp_lv_calendar_get_pressed_date_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_header_dropdown_set_year_list), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_set_year_list_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(calendar_locals_dict, calendar_locals_dict_table);

STATIC void calendar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl calendar");
}


STATIC mp_obj_t calendar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_calendar_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_calendar_type_base,
    MP_QSTR_calendar,
    MP_TYPE_FLAG_NONE,
    print, calendar_print,
    make_new, calendar_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &calendar_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_calendar_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_calendar_class,
#endif
    .mp_obj_type = &mp_lv_calendar_type_base,
};
    
/* Reusing lv_obj_create for lv_calendar_header_arrow_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_header_arrow_create_mpobj, 1, mp_lv_obj_create, lv_calendar_header_arrow_create);
    

/*
 * lvgl calendar_header_arrow object definitions
 */
    

STATIC const mp_rom_map_elem_t calendar_header_arrow_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(calendar_header_arrow_locals_dict, calendar_header_arrow_locals_dict_table);

STATIC void calendar_header_arrow_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl calendar_header_arrow");
}


STATIC mp_obj_t calendar_header_arrow_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_calendar_header_arrow_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_calendar_header_arrow_type_base,
    MP_QSTR_calendar_header_arrow,
    MP_TYPE_FLAG_NONE,
    print, calendar_header_arrow_print,
    make_new, calendar_header_arrow_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &calendar_header_arrow_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_calendar_header_arrow_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_calendar_header_arrow_class,
#endif
    .mp_obj_type = &mp_lv_calendar_header_arrow_type_base,
};
    

/*
 * WARNING: lv_calendar_header_dropdown_set_year_list was declared more than once!
 */
        
/* Reusing lv_obj_create for lv_calendar_header_dropdown_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_header_dropdown_create_mpobj, 1, mp_lv_obj_create, lv_calendar_header_dropdown_create);
    

/*
 * lvgl calendar_header_dropdown object definitions
 */
    

STATIC const mp_rom_map_elem_t calendar_header_dropdown_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_header_dropdown_set_year_list), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_set_year_list_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(calendar_header_dropdown_locals_dict, calendar_header_dropdown_locals_dict_table);

STATIC void calendar_header_dropdown_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl calendar_header_dropdown");
}


STATIC mp_obj_t calendar_header_dropdown_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_calendar_header_dropdown_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_calendar_header_dropdown_type_base,
    MP_QSTR_calendar_header_dropdown,
    MP_TYPE_FLAG_NONE,
    print, calendar_header_dropdown_print,
    make_new, calendar_header_dropdown_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &calendar_header_dropdown_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_calendar_header_dropdown_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_calendar_header_dropdown_class,
#endif
    .mp_obj_type = &mp_lv_calendar_header_dropdown_type_base,
};
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_canvas_buf_size(int32_t w, int32_t h, uint8_t bpp, uint8_t stride)
 */

STATIC mp_obj_t mp_lv_canvas_buf_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t w = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t h = (int32_t)mp_obj_get_int(mp_args[1]);
    uint8_t bpp = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint8_t stride = (uint8_t)mp_obj_get_int(mp_args[3]);
    uint32_t _res = ((uint32_t (*)(int32_t, int32_t, uint8_t, uint8_t))lv_func_ptr)(w, h, bpp, stride);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_canvas_buf_size_mpobj, 4, mp_lv_canvas_buf_size, lv_canvas_buf_size);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_buffer(lv_obj_t *obj, void *buf, int32_t w, int32_t h, lv_color_format_t cf)
 */

STATIC mp_obj_t mp_lv_canvas_set_buffer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    int32_t w = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t h = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, void *, int32_t, int32_t, lv_color_format_t))lv_func_ptr)(obj, buf, w, h, cf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_buffer_mpobj, 5, mp_lv_canvas_set_buffer, lv_canvas_set_buffer);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_draw_buf(lv_obj_t *obj, lv_draw_buf_t *draw_buf)
 */

STATIC mp_obj_t mp_lv_canvas_set_draw_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_draw_buf_t *))lv_func_ptr)(obj, draw_buf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_draw_buf_mpobj, 2, mp_lv_canvas_set_draw_buf, lv_canvas_set_draw_buf);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_px(lv_obj_t *obj, int32_t x, int32_t y, lv_color_t color, lv_opa_t opa)
 */

STATIC mp_obj_t mp_lv_canvas_set_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color_t(mp_args[3]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, int32_t, int32_t, lv_color_t, lv_opa_t))lv_func_ptr)(obj, x, y, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_px_mpobj, 5, mp_lv_canvas_set_px, lv_canvas_set_px);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_palette(lv_obj_t *canvas, uint8_t id, lv_color32_t c)
 */

STATIC mp_obj_t mp_lv_canvas_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color32_t c = mp_write_lv_color32_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_color32_t))lv_func_ptr)(canvas, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_palette_mpobj, 3, mp_lv_canvas_set_palette, lv_canvas_set_palette);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_canvas_get_draw_buf(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_canvas_get_draw_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_draw_buf_mpobj, 1, mp_lv_canvas_get_draw_buf, lv_canvas_get_draw_buf);
    

/*
 * lvgl extension definition for:
 * lv_color32_t lv_canvas_get_px(lv_obj_t *obj, int32_t x, int32_t y)
 */

STATIC mp_obj_t mp_lv_canvas_get_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_color32_t _res = ((lv_color32_t (*)(lv_obj_t *, int32_t, int32_t))lv_func_ptr)(obj, x, y);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_px_mpobj, 3, mp_lv_canvas_get_px, lv_canvas_get_px);
    

/*
 * lvgl extension definition for:
 * lv_image_dsc_t *lv_canvas_get_image(lv_obj_t *canvas)
 */

STATIC mp_obj_t mp_lv_canvas_get_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_image_dsc_t * _res = ((lv_image_dsc_t *(*)(lv_obj_t *))lv_func_ptr)(canvas);
    return mp_read_ptr_lv_image_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_image_mpobj, 1, mp_lv_canvas_get_image, lv_canvas_get_image);
    
/* Reusing lv_image_get_src for lv_canvas_get_buf */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_buf_mpobj, 1, mp_lv_image_get_src, lv_canvas_get_buf);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_copy_buf(lv_obj_t *obj, const lv_area_t *canvas_area, lv_draw_buf_t *dest_buf, const lv_area_t *dest_area)
 */

STATIC mp_obj_t mp_lv_canvas_copy_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_area_t *canvas_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    lv_draw_buf_t *dest_buf = mp_write_ptr_lv_draw_buf_t(mp_args[2]);
    const lv_area_t *dest_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_area_t *, lv_draw_buf_t *, const lv_area_t *))lv_func_ptr)(obj, canvas_area, dest_buf, dest_area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_copy_buf_mpobj, 4, mp_lv_canvas_copy_buf, lv_canvas_copy_buf);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_fill_bg(lv_obj_t *obj, lv_color_t color, lv_opa_t opa)
 */

STATIC mp_obj_t mp_lv_canvas_fill_bg(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color_t(mp_args[1]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_color_t, lv_opa_t))lv_func_ptr)(obj, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_fill_bg_mpobj, 3, mp_lv_canvas_fill_bg, lv_canvas_fill_bg);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_init_layer(lv_obj_t *canvas, lv_layer_t *layer)
 */

STATIC mp_obj_t mp_lv_canvas_init_layer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_layer_t *))lv_func_ptr)(canvas, layer);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_init_layer_mpobj, 2, mp_lv_canvas_init_layer, lv_canvas_init_layer);
    
/* Reusing lv_canvas_init_layer for lv_canvas_finish_layer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_finish_layer_mpobj, 2, mp_lv_canvas_init_layer, lv_canvas_finish_layer);
    
/* Reusing lv_obj_create for lv_canvas_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_create_mpobj, 1, mp_lv_obj_create, lv_canvas_create);
    

/*
 * lvgl canvas object definitions
 */
    

STATIC const mp_rom_map_elem_t canvas_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_buf_size), MP_ROM_PTR(&mp_lv_canvas_buf_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_buffer), MP_ROM_PTR(&mp_lv_canvas_set_buffer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_draw_buf), MP_ROM_PTR(&mp_lv_canvas_set_draw_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_px), MP_ROM_PTR(&mp_lv_canvas_set_px_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_palette), MP_ROM_PTR(&mp_lv_canvas_set_palette_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_buf), MP_ROM_PTR(&mp_lv_canvas_get_draw_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_px), MP_ROM_PTR(&mp_lv_canvas_get_px_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_image), MP_ROM_PTR(&mp_lv_canvas_get_image_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_buf), MP_ROM_PTR(&mp_lv_canvas_get_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_copy_buf), MP_ROM_PTR(&mp_lv_canvas_copy_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fill_bg), MP_ROM_PTR(&mp_lv_canvas_fill_bg_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_layer), MP_ROM_PTR(&mp_lv_canvas_init_layer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_finish_layer), MP_ROM_PTR(&mp_lv_canvas_finish_layer_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(canvas_locals_dict, canvas_locals_dict_table);

STATIC void canvas_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl canvas");
}


STATIC mp_obj_t canvas_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_canvas_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_canvas_type_base,
    MP_QSTR_canvas,
    MP_TYPE_FLAG_NONE,
    print, canvas_print,
    make_new, canvas_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &canvas_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_canvas_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_canvas_class,
#endif
    .mp_obj_type = &mp_lv_canvas_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_type(lv_obj_t *obj, lv_chart_type_t type)
 */

STATIC mp_obj_t mp_lv_chart_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_type_t))lv_func_ptr)(obj, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_type_mpobj, 2, mp_lv_chart_set_type, lv_chart_set_type);
    
/* Reusing lv_obj_delete_delayed for lv_chart_set_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_point_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_chart_set_point_count);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_range(lv_obj_t *obj, lv_chart_axis_t axis, int32_t min, int32_t max)
 */

STATIC mp_obj_t mp_lv_chart_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[1]);
    int32_t min = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t max = (int32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_axis_t, int32_t, int32_t))lv_func_ptr)(obj, axis, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_range_mpobj, 4, mp_lv_chart_set_range, lv_chart_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_update_mode(lv_obj_t *obj, lv_chart_update_mode_t update_mode)
 */

STATIC mp_obj_t mp_lv_chart_set_update_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_update_mode_t update_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_update_mode_t))lv_func_ptr)(obj, update_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_update_mode_mpobj, 2, mp_lv_chart_set_update_mode, lv_chart_set_update_mode);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_div_line_count(lv_obj_t *obj, uint8_t hdiv, uint8_t vdiv)
 */

STATIC mp_obj_t mp_lv_chart_set_div_line_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t hdiv = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t vdiv = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, uint8_t))lv_func_ptr)(obj, hdiv, vdiv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_div_line_count_mpobj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_div_line_count);
    

/*
 * lvgl extension definition for:
 * lv_chart_type_t lv_chart_get_type(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_chart_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_chart_type_t _res = ((lv_chart_type_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_type_mpobj, 1, mp_lv_chart_get_type, lv_chart_get_type);
    
/* Reusing lv_obj_get_child_count for lv_chart_get_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_count_mpobj, 1, mp_lv_obj_get_child_count, lv_chart_get_point_count);
    

/*
 * Struct lv_chart_series_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type();

STATIC inline void* mp_write_ptr_lv_chart_series_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_series_t_type()));
    return (lv_chart_series_t*)self->data;
}

#define mp_write_lv_chart_series_t(struct_obj) *((lv_chart_series_t*)mp_write_ptr_lv_chart_series_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_chart_series_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_series_t_type(), field);
}

#define mp_read_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(copy_buffer(&field, sizeof(lv_chart_series_t)))
#define mp_read_byref_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(&field)

STATIC void mp_lv_chart_series_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_chart_series_t *data = (lv_chart_series_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x_points: dest[0] = mp_array_from_i32ptr((void*)data->x_points); break; // converting from int32_t *;
            case MP_QSTR_y_points: dest[0] = mp_array_from_i32ptr((void*)data->y_points); break; // converting from int32_t *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_start_point: dest[0] = mp_obj_new_int_from_uint(data->start_point); break; // converting from uint32_t;
            case MP_QSTR_hidden: dest[0] = mp_obj_new_int_from_uint(data->hidden); break; // converting from uint32_t;
            case MP_QSTR_x_ext_buf_assigned: dest[0] = mp_obj_new_int_from_uint(data->x_ext_buf_assigned); break; // converting from uint32_t;
            case MP_QSTR_y_ext_buf_assigned: dest[0] = mp_obj_new_int_from_uint(data->y_ext_buf_assigned); break; // converting from uint32_t;
            case MP_QSTR_x_axis_sec: dest[0] = mp_obj_new_int_from_uint(data->x_axis_sec); break; // converting from uint32_t;
            case MP_QSTR_y_axis_sec: dest[0] = mp_obj_new_int_from_uint(data->y_axis_sec); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x_points: data->x_points = (void*)mp_array_to_i32ptr(dest[1]); break; // converting to int32_t *;
                case MP_QSTR_y_points: data->y_points = (void*)mp_array_to_i32ptr(dest[1]); break; // converting to int32_t *;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_start_point: data->start_point = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_hidden: data->hidden = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_x_ext_buf_assigned: data->x_ext_buf_assigned = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_y_ext_buf_assigned: data->y_ext_buf_assigned = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_x_axis_sec: data->x_axis_sec = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_y_axis_sec: data->y_axis_sec = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_series_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_series_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_series_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_chart_series_t_type,
    MP_QSTR_lv_chart_series_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_chart_series_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_chart_series_t_attr,
    locals_dict, &mp_lv_chart_series_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type()
{
    return &mp_lv_chart_series_t_type;
}
    

/*
 * lvgl extension definition for:
 * uint32_t lv_chart_get_x_start_point(const lv_obj_t *obj, lv_chart_series_t *ser)
 */

STATIC mp_obj_t mp_lv_chart_get_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, ser);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_start_point_mpobj, 2, mp_lv_chart_get_x_start_point, lv_chart_get_x_start_point);
    

/*
 * lvgl extension definition for:
 * void lv_chart_get_point_pos_by_id(lv_obj_t *obj, lv_chart_series_t *ser, uint32_t id, lv_point_t *p_out)
 */

STATIC mp_obj_t mp_lv_chart_get_point_pos_by_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint32_t id = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_point_t *p_out = mp_write_ptr_lv_point_t(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint32_t, lv_point_t *))lv_func_ptr)(obj, ser, id, p_out);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_pos_by_id_mpobj, 4, mp_lv_chart_get_point_pos_by_id, lv_chart_get_point_pos_by_id);
    
/* Reusing lv_obj_center for lv_chart_refresh */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_refresh_mpobj, 1, mp_lv_obj_center, lv_chart_refresh);
    

/*
 * lvgl extension definition for:
 * lv_chart_series_t *lv_chart_add_series(lv_obj_t *obj, lv_color_t color, lv_chart_axis_t axis)
 */

STATIC mp_obj_t mp_lv_chart_add_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color_t(mp_args[1]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_series_t * _res = ((lv_chart_series_t *(*)(lv_obj_t *, lv_color_t, lv_chart_axis_t))lv_func_ptr)(obj, color, axis);
    return mp_read_ptr_lv_chart_series_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_series_mpobj, 3, mp_lv_chart_add_series, lv_chart_add_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_remove_series(lv_obj_t *obj, lv_chart_series_t *series)
 */

STATIC mp_obj_t mp_lv_chart_remove_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, series);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_remove_series_mpobj, 2, mp_lv_chart_remove_series, lv_chart_remove_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_hide_series(lv_obj_t *chart, lv_chart_series_t *series, bool hide)
 */

STATIC mp_obj_t mp_lv_chart_hide_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    bool hide = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, bool))lv_func_ptr)(chart, series, hide);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_hide_series_mpobj, 3, mp_lv_chart_hide_series, lv_chart_hide_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_series_color(lv_obj_t *chart, lv_chart_series_t *series, lv_color_t color)
 */

STATIC mp_obj_t mp_lv_chart_set_series_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_color_t color = mp_write_lv_color_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_color_t))lv_func_ptr)(chart, series, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_series_color_mpobj, 3, mp_lv_chart_set_series_color, lv_chart_set_series_color);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_x_start_point(lv_obj_t *obj, lv_chart_series_t *ser, uint32_t id)
 */

STATIC mp_obj_t mp_lv_chart_set_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint32_t id = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint32_t))lv_func_ptr)(obj, ser, id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_x_start_point_mpobj, 3, mp_lv_chart_set_x_start_point, lv_chart_set_x_start_point);
    

/*
 * lvgl extension definition for:
 * lv_chart_series_t *lv_chart_get_series_next(const lv_obj_t *chart, const lv_chart_series_t *ser)
 */

STATIC mp_obj_t mp_lv_chart_get_series_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *chart = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const lv_chart_series_t *ser = (const lv_chart_series_t *)mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_chart_series_t * _res = ((lv_chart_series_t *(*)(const lv_obj_t *, const lv_chart_series_t *))lv_func_ptr)(chart, ser);
    return mp_read_ptr_lv_chart_series_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_series_next_mpobj, 2, mp_lv_chart_get_series_next, lv_chart_get_series_next);
    

/*
 * Struct lv_chart_cursor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type();

STATIC inline void* mp_write_ptr_lv_chart_cursor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_cursor_t_type()));
    return (lv_chart_cursor_t*)self->data;
}

#define mp_write_lv_chart_cursor_t(struct_obj) *((lv_chart_cursor_t*)mp_write_ptr_lv_chart_cursor_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_chart_cursor_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_cursor_t_type(), field);
}

#define mp_read_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(copy_buffer(&field, sizeof(lv_chart_cursor_t)))
#define mp_read_byref_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(&field)

STATIC void mp_lv_chart_cursor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_chart_cursor_t *data = (lv_chart_cursor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_pos: dest[0] = mp_read_byref_lv_point_t(data->pos); break; // converting from lv_point_t;
            case MP_QSTR_point_id: dest[0] = mp_obj_new_int(data->point_id); break; // converting from int32_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_ser: dest[0] = mp_read_ptr_lv_chart_series_t((void*)data->ser); break; // converting from lv_chart_series_t *;
            case MP_QSTR_dir: dest[0] = mp_obj_new_int_from_uint(data->dir); break; // converting from lv_dir_t;
            case MP_QSTR_pos_set: dest[0] = mp_obj_new_int_from_uint(data->pos_set); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_pos: data->pos = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_point_id: data->point_id = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_ser: data->ser = (void*)mp_write_ptr_lv_chart_series_t(dest[1]); break; // converting to lv_chart_series_t *;
                case MP_QSTR_dir: data->dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_dir_t;
                case MP_QSTR_pos_set: data->pos_set = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_cursor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_cursor_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_cursor_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_chart_cursor_t_type,
    MP_QSTR_lv_chart_cursor_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_chart_cursor_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_chart_cursor_t_attr,
    locals_dict, &mp_lv_chart_cursor_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type()
{
    return &mp_lv_chart_cursor_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_chart_cursor_t *lv_chart_add_cursor(lv_obj_t *obj, lv_color_t color, lv_dir_t dir)
 */

STATIC mp_obj_t mp_lv_chart_add_cursor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color_t(mp_args[1]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_cursor_t * _res = ((lv_chart_cursor_t *(*)(lv_obj_t *, lv_color_t, lv_dir_t))lv_func_ptr)(obj, color, dir);
    return mp_read_ptr_lv_chart_cursor_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_cursor_mpobj, 3, mp_lv_chart_add_cursor, lv_chart_add_cursor);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_cursor_pos(lv_obj_t *chart, lv_chart_cursor_t *cursor, lv_point_t *pos)
 */

STATIC mp_obj_t mp_lv_chart_set_cursor_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_cursor_t *, lv_point_t *))lv_func_ptr)(chart, cursor, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_cursor_pos_mpobj, 3, mp_lv_chart_set_cursor_pos, lv_chart_set_cursor_pos);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor, lv_chart_series_t *ser, uint32_t point_id)
 */

STATIC mp_obj_t mp_lv_chart_set_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[2]);
    uint32_t point_id = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_cursor_t *, lv_chart_series_t *, uint32_t))lv_func_ptr)(chart, cursor, ser, point_id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_cursor_point_mpobj, 4, mp_lv_chart_set_cursor_point, lv_chart_set_cursor_point);
    

/*
 * lvgl extension definition for:
 * lv_point_t lv_chart_get_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor)
 */

STATIC mp_obj_t mp_lv_chart_get_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t _res = ((lv_point_t (*)(lv_obj_t *, lv_chart_cursor_t *))lv_func_ptr)(chart, cursor);
    return mp_read_lv_point_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_cursor_point_mpobj, 2, mp_lv_chart_get_cursor_point, lv_chart_get_cursor_point);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_all_value(lv_obj_t *obj, lv_chart_series_t *ser, int32_t value)
 */

STATIC mp_obj_t mp_lv_chart_set_all_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, int32_t))lv_func_ptr)(obj, ser, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_all_value_mpobj, 3, mp_lv_chart_set_all_value, lv_chart_set_all_value);
    
/* Reusing lv_chart_set_all_value for lv_chart_set_next_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_next_value_mpobj, 3, mp_lv_chart_set_all_value, lv_chart_set_next_value);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_next_value2(lv_obj_t *obj, lv_chart_series_t *ser, int32_t x_value, int32_t y_value)
 */

STATIC mp_obj_t mp_lv_chart_set_next_value2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    int32_t x_value = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t y_value = (int32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, int32_t, int32_t))lv_func_ptr)(obj, ser, x_value, y_value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_next_value2_mpobj, 4, mp_lv_chart_set_next_value2, lv_chart_set_next_value2);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_value_by_id(lv_obj_t *obj, lv_chart_series_t *ser, uint32_t id, int32_t value)
 */

STATIC mp_obj_t mp_lv_chart_set_value_by_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint32_t id = (uint32_t)mp_obj_get_int(mp_args[2]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint32_t, int32_t))lv_func_ptr)(obj, ser, id, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_value_by_id_mpobj, 4, mp_lv_chart_set_value_by_id, lv_chart_set_value_by_id);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_value_by_id2(lv_obj_t *obj, lv_chart_series_t *ser, uint32_t id, int32_t x_value, int32_t y_value)
 */

STATIC mp_obj_t mp_lv_chart_set_value_by_id2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint32_t id = (uint32_t)mp_obj_get_int(mp_args[2]);
    int32_t x_value = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t y_value = (int32_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint32_t, int32_t, int32_t))lv_func_ptr)(obj, ser, id, x_value, y_value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_value_by_id2_mpobj, 5, mp_lv_chart_set_value_by_id2, lv_chart_set_value_by_id2);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_ext_y_array(lv_obj_t *obj, lv_chart_series_t *ser, int32_t array[])
 */

STATIC mp_obj_t mp_lv_chart_set_ext_y_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    int32_t *array = mp_arr_to_int32_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, int32_t []))lv_func_ptr)(obj, ser, array);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_ext_y_array_mpobj, 3, mp_lv_chart_set_ext_y_array, lv_chart_set_ext_y_array);
    
/* Reusing lv_chart_set_ext_y_array for lv_chart_set_ext_x_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_ext_x_array_mpobj, 3, mp_lv_chart_set_ext_y_array, lv_chart_set_ext_x_array);
    

/*
 * lvgl extension definition for:
 * int32_t *lv_chart_get_y_array(const lv_obj_t *obj, lv_chart_series_t *ser)
 */

STATIC mp_obj_t mp_lv_chart_get_y_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    int32_t * _res = ((int32_t *(*)(const lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, ser);
    return mp_array_from_i32ptr((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_y_array_mpobj, 2, mp_lv_chart_get_y_array, lv_chart_get_y_array);
    
/* Reusing lv_chart_get_y_array for lv_chart_get_x_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_array_mpobj, 2, mp_lv_chart_get_y_array, lv_chart_get_x_array);
    
/* Reusing lv_obj_get_child_count for lv_chart_get_pressed_point */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_pressed_point_mpobj, 1, mp_lv_obj_get_child_count, lv_chart_get_pressed_point);
    
/* Reusing lv_obj_get_scroll_top for lv_chart_get_first_point_center_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_first_point_center_offset_mpobj, 1, mp_lv_obj_get_scroll_top, lv_chart_get_first_point_center_offset);
    
/* Reusing lv_obj_create for lv_chart_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_create_mpobj, 1, mp_lv_obj_create, lv_chart_create);
    

/*
 * lvgl chart object definitions
 */
    

STATIC const mp_rom_map_elem_t chart_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_chart_set_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_point_count), MP_ROM_PTR(&mp_lv_chart_set_point_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_chart_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_update_mode), MP_ROM_PTR(&mp_lv_chart_set_update_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_div_line_count), MP_ROM_PTR(&mp_lv_chart_set_div_line_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_chart_get_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_count), MP_ROM_PTR(&mp_lv_chart_get_point_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_start_point), MP_ROM_PTR(&mp_lv_chart_get_x_start_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_pos_by_id), MP_ROM_PTR(&mp_lv_chart_get_point_pos_by_id_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refresh), MP_ROM_PTR(&mp_lv_chart_refresh_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_series), MP_ROM_PTR(&mp_lv_chart_add_series_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_series), MP_ROM_PTR(&mp_lv_chart_remove_series_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_hide_series), MP_ROM_PTR(&mp_lv_chart_hide_series_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_series_color), MP_ROM_PTR(&mp_lv_chart_set_series_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_x_start_point), MP_ROM_PTR(&mp_lv_chart_set_x_start_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_series_next), MP_ROM_PTR(&mp_lv_chart_get_series_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_cursor), MP_ROM_PTR(&mp_lv_chart_add_cursor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_chart_set_cursor_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_point), MP_ROM_PTR(&mp_lv_chart_set_cursor_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_point), MP_ROM_PTR(&mp_lv_chart_get_cursor_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_all_value), MP_ROM_PTR(&mp_lv_chart_set_all_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_next_value), MP_ROM_PTR(&mp_lv_chart_set_next_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_next_value2), MP_ROM_PTR(&mp_lv_chart_set_next_value2_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_by_id), MP_ROM_PTR(&mp_lv_chart_set_value_by_id_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_by_id2), MP_ROM_PTR(&mp_lv_chart_set_value_by_id2_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_y_array), MP_ROM_PTR(&mp_lv_chart_set_ext_y_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_x_array), MP_ROM_PTR(&mp_lv_chart_set_ext_x_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_array), MP_ROM_PTR(&mp_lv_chart_get_y_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_array), MP_ROM_PTR(&mp_lv_chart_get_x_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_point), MP_ROM_PTR(&mp_lv_chart_get_pressed_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_first_point_center_offset), MP_ROM_PTR(&mp_lv_chart_get_first_point_center_offset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_lv_LV_CHART_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_UPDATE_MODE), MP_ROM_PTR(&mp_lv_LV_CHART_UPDATE_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_AXIS), MP_ROM_PTR(&mp_lv_LV_CHART_AXIS_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(chart_locals_dict, chart_locals_dict_table);

STATIC void chart_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl chart");
}


STATIC mp_obj_t chart_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_chart_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_chart_type_base,
    MP_QSTR_chart,
    MP_TYPE_FLAG_NONE,
    print, chart_print,
    make_new, chart_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &chart_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_chart_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_chart_class,
#endif
    .mp_obj_type = &mp_lv_chart_type_base,
};
    
/* Reusing lv_label_set_text for lv_checkbox_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_mpobj, 2, mp_lv_label_set_text, lv_checkbox_set_text);
    
/* Reusing lv_label_set_text for lv_checkbox_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_static_mpobj, 2, mp_lv_label_set_text, lv_checkbox_set_text_static);
    

/*
 * lvgl extension definition for:
 * const char *lv_checkbox_get_text(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_checkbox_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_get_text_mpobj, 1, mp_lv_checkbox_get_text, lv_checkbox_get_text);
    
/* Reusing lv_obj_create for lv_checkbox_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_create_mpobj, 1, mp_lv_obj_create, lv_checkbox_create);
    

/*
 * lvgl checkbox object definitions
 */
    

STATIC const mp_rom_map_elem_t checkbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_checkbox_set_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_checkbox_set_text_static_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_checkbox_get_text_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(checkbox_locals_dict, checkbox_locals_dict_table);

STATIC void checkbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl checkbox");
}


STATIC mp_obj_t checkbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_checkbox_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_checkbox_type_base,
    MP_QSTR_checkbox,
    MP_TYPE_FLAG_NONE,
    print, checkbox_print,
    make_new, checkbox_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &checkbox_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_checkbox_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_checkbox_class,
#endif
    .mp_obj_type = &mp_lv_checkbox_type_base,
};
    
/* Reusing lv_label_set_text for lv_dropdown_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_text_mpobj, 2, mp_lv_label_set_text, lv_dropdown_set_text);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_mpobj, 2, mp_lv_label_set_text, lv_dropdown_set_options);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_static_mpobj, 2, mp_lv_label_set_text, lv_dropdown_set_options_static);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_add_option(lv_obj_t *obj, const char *option, uint32_t pos)
 */

STATIC mp_obj_t mp_lv_dropdown_add_option(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *option = (const char *)(char*)convert_from_str(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, uint32_t))lv_func_ptr)(obj, option, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_add_option_mpobj, 3, mp_lv_dropdown_add_option, lv_dropdown_add_option);
    
/* Reusing lv_obj_center for lv_dropdown_clear_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_clear_options_mpobj, 1, mp_lv_obj_center, lv_dropdown_clear_options);
    
/* Reusing lv_obj_delete_delayed for lv_dropdown_set_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_selected_mpobj, 2, mp_lv_obj_delete_delayed, lv_dropdown_set_selected);
    
/* Reusing lv_obj_set_scroll_dir for lv_dropdown_set_dir */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_dir_mpobj, 2, mp_lv_obj_set_scroll_dir, lv_dropdown_set_dir);
    
/* Reusing lv_image_set_src for lv_dropdown_set_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_symbol_mpobj, 2, mp_lv_image_set_src, lv_dropdown_set_symbol);
    
/* Reusing lv_image_set_antialias for lv_dropdown_set_selected_highlight */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_selected_highlight_mpobj, 2, mp_lv_image_set_antialias, lv_dropdown_set_selected_highlight);
    
/* Reusing lv_obj_create for lv_dropdown_get_list */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_list_mpobj, 1, mp_lv_obj_create, lv_dropdown_get_list);
    

/*
 * lvgl extension definition for:
 * const char *lv_dropdown_get_text(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_dropdown_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_text_mpobj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_text);
    
/* Reusing lv_checkbox_get_text for lv_dropdown_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_options_mpobj, 1, mp_lv_checkbox_get_text, lv_dropdown_get_options);
    
/* Reusing lv_obj_get_child_count for lv_dropdown_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_mpobj, 1, mp_lv_obj_get_child_count, lv_dropdown_get_selected);
    
/* Reusing lv_obj_get_child_count for lv_dropdown_get_option_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_option_count_mpobj, 1, mp_lv_obj_get_child_count, lv_dropdown_get_option_count);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_get_selected_str(const lv_obj_t *obj, char *buf, uint32_t buf_size)
 */

STATIC mp_obj_t mp_lv_dropdown_get_selected_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    char *buf = (char*)convert_from_str(mp_args[1]);
    uint32_t buf_size = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, char *, uint32_t))lv_func_ptr)(obj, buf, buf_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_str_mpobj, 3, mp_lv_dropdown_get_selected_str, lv_dropdown_get_selected_str);
    

/*
 * lvgl extension definition for:
 * int32_t lv_dropdown_get_option_index(lv_obj_t *obj, const char *option)
 */

STATIC mp_obj_t mp_lv_dropdown_get_option_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *option = (const char *)(char*)convert_from_str(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_obj_t *, const char *))lv_func_ptr)(obj, option);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_option_index_mpobj, 2, mp_lv_dropdown_get_option_index, lv_dropdown_get_option_index);
    
/* Reusing lv_dropdown_get_text for lv_dropdown_get_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_symbol_mpobj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_symbol);
    
/* Reusing lv_obj_refr_size for lv_dropdown_get_selected_highlight */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_highlight_mpobj, 1, mp_lv_obj_refr_size, lv_dropdown_get_selected_highlight);
    
/* Reusing lv_obj_get_scroll_dir for lv_dropdown_get_dir */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_dir_mpobj, 1, mp_lv_obj_get_scroll_dir, lv_dropdown_get_dir);
    
/* Reusing lv_obj_center for lv_dropdown_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_open_mpobj, 1, mp_lv_obj_center, lv_dropdown_open);
    
/* Reusing lv_obj_center for lv_dropdown_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_close_mpobj, 1, mp_lv_obj_center, lv_dropdown_close);
    
/* Reusing lv_obj_refr_size for lv_dropdown_is_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_is_open_mpobj, 1, mp_lv_obj_refr_size, lv_dropdown_is_open);
    
/* Reusing lv_arc_bind_value for lv_dropdown_bind_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_bind_value_mpobj, 2, mp_lv_arc_bind_value, lv_dropdown_bind_value);
    
/* Reusing lv_obj_create for lv_dropdown_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_create_mpobj, 1, mp_lv_obj_create, lv_dropdown_create);
    

/*
 * lvgl dropdown object definitions
 */
    

STATIC const mp_rom_map_elem_t dropdown_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_dropdown_set_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_dropdown_set_options_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_options_static), MP_ROM_PTR(&mp_lv_dropdown_set_options_static_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_option), MP_ROM_PTR(&mp_lv_dropdown_add_option_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_options), MP_ROM_PTR(&mp_lv_dropdown_clear_options_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_dropdown_set_selected_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_dir), MP_ROM_PTR(&mp_lv_dropdown_set_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_symbol), MP_ROM_PTR(&mp_lv_dropdown_set_symbol_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected_highlight), MP_ROM_PTR(&mp_lv_dropdown_set_selected_highlight_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_list), MP_ROM_PTR(&mp_lv_dropdown_get_list_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_dropdown_get_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_dropdown_get_options_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_dropdown_get_selected_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_count), MP_ROM_PTR(&mp_lv_dropdown_get_option_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_dropdown_get_selected_str_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_index), MP_ROM_PTR(&mp_lv_dropdown_get_option_index_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_symbol), MP_ROM_PTR(&mp_lv_dropdown_get_symbol_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_highlight), MP_ROM_PTR(&mp_lv_dropdown_get_selected_highlight_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_dir), MP_ROM_PTR(&mp_lv_dropdown_get_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_dropdown_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_dropdown_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_open), MP_ROM_PTR(&mp_lv_dropdown_is_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_value), MP_ROM_PTR(&mp_lv_dropdown_bind_value_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(dropdown_locals_dict, dropdown_locals_dict_table);

STATIC void dropdown_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl dropdown");
}


STATIC mp_obj_t dropdown_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_dropdown_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_dropdown_type_base,
    MP_QSTR_dropdown,
    MP_TYPE_FLAG_NONE,
    print, dropdown_print,
    make_new, dropdown_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &dropdown_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_dropdown_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_dropdown_class,
#endif
    .mp_obj_type = &mp_lv_dropdown_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_imagebutton_set_src(lv_obj_t *imagebutton, lv_imagebutton_state_t state, const void *src_left, const void *src_mid, const void *src_right)
 */

STATIC mp_obj_t mp_lv_imagebutton_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imagebutton = mp_to_lv(mp_args[0]);
    lv_imagebutton_state_t state = (int)mp_obj_get_int(mp_args[1]);
    const void *src_left = (const void *)mp_to_ptr(mp_args[2]);
    const void *src_mid = (const void *)mp_to_ptr(mp_args[3]);
    const void *src_right = (const void *)mp_to_ptr(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_imagebutton_state_t, const void *, const void *, const void *))lv_func_ptr)(imagebutton, state, src_left, src_mid, src_right);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_set_src_mpobj, 5, mp_lv_imagebutton_set_src, lv_imagebutton_set_src);
    

/*
 * lvgl extension definition for:
 * void lv_imagebutton_set_state(lv_obj_t *imagebutton, lv_imagebutton_state_t state)
 */

STATIC mp_obj_t mp_lv_imagebutton_set_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imagebutton = mp_to_lv(mp_args[0]);
    lv_imagebutton_state_t state = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_imagebutton_state_t))lv_func_ptr)(imagebutton, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_set_state_mpobj, 2, mp_lv_imagebutton_set_state, lv_imagebutton_set_state);
    

/*
 * lvgl extension definition for:
 * const void *lv_imagebutton_get_src_left(lv_obj_t *imagebutton, lv_imagebutton_state_t state)
 */

STATIC mp_obj_t mp_lv_imagebutton_get_src_left(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imagebutton = mp_to_lv(mp_args[0]);
    lv_imagebutton_state_t state = (int)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(lv_obj_t *, lv_imagebutton_state_t))lv_func_ptr)(imagebutton, state);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_get_src_left_mpobj, 2, mp_lv_imagebutton_get_src_left, lv_imagebutton_get_src_left);
    
/* Reusing lv_imagebutton_get_src_left for lv_imagebutton_get_src_middle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_get_src_middle_mpobj, 2, mp_lv_imagebutton_get_src_left, lv_imagebutton_get_src_middle);
    
/* Reusing lv_imagebutton_get_src_left for lv_imagebutton_get_src_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_get_src_right_mpobj, 2, mp_lv_imagebutton_get_src_left, lv_imagebutton_get_src_right);
    
/* Reusing lv_obj_create for lv_imagebutton_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imagebutton_create_mpobj, 1, mp_lv_obj_create, lv_imagebutton_create);
    

/*
 * lvgl imagebutton object definitions
 */
    

STATIC const mp_rom_map_elem_t imagebutton_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_imagebutton_set_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_imagebutton_set_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_left), MP_ROM_PTR(&mp_lv_imagebutton_get_src_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_middle), MP_ROM_PTR(&mp_lv_imagebutton_get_src_middle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_right), MP_ROM_PTR(&mp_lv_imagebutton_get_src_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_lv_LV_IMAGEBUTTON_STATE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(imagebutton_locals_dict, imagebutton_locals_dict_table);

STATIC void imagebutton_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl imagebutton");
}


STATIC mp_obj_t imagebutton_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_imagebutton_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_imagebutton_type_base,
    MP_QSTR_imagebutton,
    MP_TYPE_FLAG_NONE,
    print, imagebutton_print,
    make_new, imagebutton_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &imagebutton_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_imagebutton_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_imagebutton_class,
#endif
    .mp_obj_type = &mp_lv_imagebutton_type_base,
};
    
/* Reusing lv_buttonmatrix_get_map for lv_keyboard_get_map_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_map_array_mpobj, 1, mp_lv_buttonmatrix_get_map, lv_keyboard_get_map_array);
    
/* Reusing lv_obj_get_child_count for lv_keyboard_get_selected_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_selected_button_mpobj, 1, mp_lv_obj_get_child_count, lv_keyboard_get_selected_button);
    
/* Reusing lv_buttonmatrix_get_button_text for lv_keyboard_get_button_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_button_text_mpobj, 2, mp_lv_buttonmatrix_get_button_text, lv_keyboard_get_button_text);
    
/* Reusing lv_obj_set_parent for lv_keyboard_set_textarea */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_textarea_mpobj, 2, mp_lv_obj_set_parent, lv_keyboard_set_textarea);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_mode(lv_obj_t *kb, lv_keyboard_mode_t mode)
 */

STATIC mp_obj_t mp_lv_keyboard_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t))lv_func_ptr)(kb, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_mode_mpobj, 2, mp_lv_keyboard_set_mode, lv_keyboard_set_mode);
    
/* Reusing lv_image_set_antialias for lv_keyboard_set_popovers */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_popovers_mpobj, 2, mp_lv_image_set_antialias, lv_keyboard_set_popovers);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_map(lv_obj_t *kb, lv_keyboard_mode_t mode, const char *map[], const lv_buttonmatrix_ctrl_t ctrl_map[])
 */

STATIC mp_obj_t mp_lv_keyboard_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    const char **map = (const char **)mp_arr_to_char_ptr____(mp_args[2]);
    const lv_buttonmatrix_ctrl_t *ctrl_map = (const lv_buttonmatrix_ctrl_t *)mp_arr_to_lv_buttonmatrix_ctrl_t_____(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t, const char *[], const lv_buttonmatrix_ctrl_t []))lv_func_ptr)(kb, mode, map, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_map_mpobj, 4, mp_lv_keyboard_set_map, lv_keyboard_set_map);
    
/* Reusing lv_obj_get_screen for lv_keyboard_get_textarea */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_textarea_mpobj, 1, mp_lv_obj_get_screen, lv_keyboard_get_textarea);
    

/*
 * lvgl extension definition for:
 * lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t *kb)
 */

STATIC mp_obj_t mp_lv_keyboard_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *kb = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t _res = ((lv_keyboard_mode_t (*)(const lv_obj_t *))lv_func_ptr)(kb);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_mode_mpobj, 1, mp_lv_keyboard_get_mode, lv_keyboard_get_mode);
    
/* Reusing funcptr_lv_event_cb_t for lv_keyboard_def_event_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_keyboard_def_event_cb_mpobj, 1, mp_funcptr_lv_event_cb_t, lv_keyboard_def_event_cb);
    
/* Reusing lv_obj_create for lv_keyboard_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_create_mpobj, 1, mp_lv_obj_create, lv_keyboard_create);
    

/*
 * lvgl keyboard object definitions
 */
    

STATIC const mp_rom_map_elem_t keyboard_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_map_array), MP_ROM_PTR(&mp_lv_keyboard_get_map_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_button), MP_ROM_PTR(&mp_lv_keyboard_get_selected_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_button_text), MP_ROM_PTR(&mp_lv_keyboard_get_button_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_textarea), MP_ROM_PTR(&mp_lv_keyboard_set_textarea_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_keyboard_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_popovers), MP_ROM_PTR(&mp_lv_keyboard_set_popovers_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_keyboard_set_map_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_textarea), MP_ROM_PTR(&mp_lv_keyboard_get_textarea_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_keyboard_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_def_event_cb), MP_ROM_PTR(&mp_lv_keyboard_def_event_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_KEYBOARD_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(keyboard_locals_dict, keyboard_locals_dict_table);

STATIC void keyboard_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl keyboard");
}


STATIC mp_obj_t keyboard_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_keyboard_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_keyboard_type_base,
    MP_QSTR_keyboard,
    MP_TYPE_FLAG_NONE,
    print, keyboard_print,
    make_new, keyboard_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &keyboard_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_keyboard_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_keyboard_class,
#endif
    .mp_obj_type = &mp_lv_keyboard_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_led_set_color(lv_obj_t *led, lv_color_t color)
 */

STATIC mp_obj_t mp_lv_led_set_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *led = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_color_t))lv_func_ptr)(led, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_set_color_mpobj, 2, mp_lv_led_set_color, lv_led_set_color);
    
/* Reusing lv_obj_set_flex_grow for lv_led_set_brightness */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_set_brightness_mpobj, 2, mp_lv_obj_set_flex_grow, lv_led_set_brightness);
    
/* Reusing lv_obj_center for lv_led_on */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_on_mpobj, 1, mp_lv_obj_center, lv_led_on);
    
/* Reusing lv_obj_center for lv_led_off */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_off_mpobj, 1, mp_lv_obj_center, lv_led_off);
    
/* Reusing lv_obj_center for lv_led_toggle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_toggle_mpobj, 1, mp_lv_obj_center, lv_led_toggle);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_led_get_brightness(const lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_led_get_brightness(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_get_brightness_mpobj, 1, mp_lv_led_get_brightness, lv_led_get_brightness);
    
/* Reusing lv_obj_create for lv_led_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_create_mpobj, 1, mp_lv_obj_create, lv_led_create);
    

/*
 * lvgl led object definitions
 */
    

STATIC const mp_rom_map_elem_t led_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_color), MP_ROM_PTR(&mp_lv_led_set_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_brightness), MP_ROM_PTR(&mp_lv_led_set_brightness_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_on), MP_ROM_PTR(&mp_lv_led_on_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_off), MP_ROM_PTR(&mp_lv_led_off_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_led_toggle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_brightness), MP_ROM_PTR(&mp_lv_led_get_brightness_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(led_locals_dict, led_locals_dict_table);

STATIC void led_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl led");
}


STATIC mp_obj_t led_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_led_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_led_type_base,
    MP_QSTR_led,
    MP_TYPE_FLAG_NONE,
    print, led_print,
    make_new, led_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &led_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_led_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_led_class,
#endif
    .mp_obj_type = &mp_lv_led_type_base,
};
    

/*
 * Array convertors for lv_point_precise_t []
 */

GENMPY_UNUSED STATIC lv_point_precise_t *mp_arr_to_lv_point_precise_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_point_precise_t *lv_arr = (lv_point_precise_t*)m_malloc(len * sizeof(lv_point_precise_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_point_precise_t(item);
    }
    return (lv_point_precise_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_point_precise_t_____(const lv_point_precise_t *arr)
{
    return mp_read_ptr_lv_point_precise_t((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_line_set_points(lv_obj_t *obj, const lv_point_precise_t points[], uint32_t point_num)
 */

STATIC mp_obj_t mp_lv_line_set_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_point_precise_t *points = (const lv_point_precise_t *)mp_arr_to_lv_point_precise_t_____(mp_args[1]);
    uint32_t point_num = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_point_precise_t [], uint32_t))lv_func_ptr)(obj, points, point_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_points_mpobj, 3, mp_lv_line_set_points, lv_line_set_points);
    
/* Reusing lv_image_set_antialias for lv_line_set_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_y_invert_mpobj, 2, mp_lv_image_set_antialias, lv_line_set_y_invert);
    
/* Reusing lv_obj_is_layout_positioned for lv_line_get_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_get_y_invert_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_line_get_y_invert);
    
/* Reusing lv_obj_create for lv_line_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_create_mpobj, 1, mp_lv_obj_create, lv_line_create);
    

/*
 * lvgl line object definitions
 */
    

STATIC const mp_rom_map_elem_t line_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_points), MP_ROM_PTR(&mp_lv_line_set_points_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_invert), MP_ROM_PTR(&mp_lv_line_set_y_invert_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_invert), MP_ROM_PTR(&mp_lv_line_get_y_invert_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(line_locals_dict, line_locals_dict_table);

STATIC void line_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl line");
}


STATIC mp_obj_t line_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_line_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_line_type_base,
    MP_QSTR_line,
    MP_TYPE_FLAG_NONE,
    print, line_print,
    make_new, line_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &line_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_line_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_line_class,
#endif
    .mp_obj_type = &mp_lv_line_type_base,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_add_text(lv_obj_t *list, const char *txt)
 */

STATIC mp_obj_t mp_lv_list_add_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const char *))lv_func_ptr)(list, txt);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_add_text_mpobj, 2, mp_lv_list_add_text, lv_list_add_text);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_add_button(lv_obj_t *list, const void *icon, const char *txt)
 */

STATIC mp_obj_t mp_lv_list_add_button(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    const void *icon = (const void *)mp_to_ptr(mp_args[1]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *, const char *))lv_func_ptr)(list, icon, txt);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_add_button_mpobj, 3, mp_lv_list_add_button, lv_list_add_button);
    

/*
 * lvgl extension definition for:
 * const char *lv_list_get_button_text(lv_obj_t *list, lv_obj_t *btn)
 */

STATIC mp_obj_t mp_lv_list_get_button_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    lv_obj_t *btn = mp_to_lv(mp_args[1]);
    const char * _res = ((const char *(*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(list, btn);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_button_text_mpobj, 2, mp_lv_list_get_button_text, lv_list_get_button_text);
    

/*
 * lvgl extension definition for:
 * void lv_list_set_button_text(lv_obj_t *list, lv_obj_t *btn, const char *txt)
 */

STATIC mp_obj_t mp_lv_list_set_button_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    lv_obj_t *btn = mp_to_lv(mp_args[1]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, const char *))lv_func_ptr)(list, btn, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_button_text_mpobj, 3, mp_lv_list_set_button_text, lv_list_set_button_text);
    
/* Reusing lv_obj_create for lv_list_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_create_mpobj, 1, mp_lv_obj_create, lv_list_create);
    

/*
 * lvgl list object definitions
 */
    

STATIC const mp_rom_map_elem_t list_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_list_add_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_button), MP_ROM_PTR(&mp_lv_list_add_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_button_text), MP_ROM_PTR(&mp_lv_list_get_button_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_text), MP_ROM_PTR(&mp_lv_list_set_button_text_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(list_locals_dict, list_locals_dict_table);

STATIC void list_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl list");
}


STATIC mp_obj_t list_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_list_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_list_type_base,
    MP_QSTR_list,
    MP_TYPE_FLAG_NONE,
    print, list_print,
    make_new, list_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &list_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_list_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_list_class,
#endif
    .mp_obj_type = &mp_lv_list_type_base,
};
    
/* Reusing lv_obj_set_parent for lv_menu_set_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_page_mpobj, 2, mp_lv_obj_set_parent, lv_menu_set_page);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_page_title(lv_obj_t *page, const char * const title)
 */

STATIC mp_obj_t mp_lv_menu_set_page_title(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *page = mp_to_lv(mp_args[0]);
    const char * const title = (const char * const)(char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_obj_t *, const char * const))lv_func_ptr)(page, title);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_page_title_mpobj, 2, mp_lv_menu_set_page_title, lv_menu_set_page_title);
    
/* Reusing lv_menu_set_page_title for lv_menu_set_page_title_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_page_title_static_mpobj, 2, mp_lv_menu_set_page_title, lv_menu_set_page_title_static);
    
/* Reusing lv_obj_set_parent for lv_menu_set_sidebar_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_sidebar_page_mpobj, 2, mp_lv_obj_set_parent, lv_menu_set_sidebar_page);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_mode_header(lv_obj_t *obj, lv_menu_mode_header_t mode)
 */

STATIC mp_obj_t mp_lv_menu_set_mode_header(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_menu_mode_header_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_menu_mode_header_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_mode_header_mpobj, 2, mp_lv_menu_set_mode_header, lv_menu_set_mode_header);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_mode_root_back_button(lv_obj_t *obj, lv_menu_mode_root_back_button_t mode)
 */

STATIC mp_obj_t mp_lv_menu_set_mode_root_back_button(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_menu_mode_root_back_button_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_menu_mode_root_back_button_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_mode_root_back_button_mpobj, 2, mp_lv_menu_set_mode_root_back_button, lv_menu_set_mode_root_back_button);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_load_page_event(lv_obj_t *menu, lv_obj_t *obj, lv_obj_t *page)
 */

STATIC mp_obj_t mp_lv_menu_set_load_page_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *menu = mp_to_lv(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    lv_obj_t *page = mp_to_lv(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, lv_obj_t *))lv_func_ptr)(menu, obj, page);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_load_page_event_mpobj, 3, mp_lv_menu_set_load_page_event, lv_menu_set_load_page_event);
    
/* Reusing lv_obj_create for lv_menu_get_cur_main_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_cur_main_page_mpobj, 1, mp_lv_obj_create, lv_menu_get_cur_main_page);
    
/* Reusing lv_obj_create for lv_menu_get_cur_sidebar_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_cur_sidebar_page_mpobj, 1, mp_lv_obj_create, lv_menu_get_cur_sidebar_page);
    
/* Reusing lv_obj_create for lv_menu_get_main_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_main_header_mpobj, 1, mp_lv_obj_create, lv_menu_get_main_header);
    
/* Reusing lv_obj_create for lv_menu_get_main_header_back_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_main_header_back_button_mpobj, 1, mp_lv_obj_create, lv_menu_get_main_header_back_button);
    
/* Reusing lv_obj_create for lv_menu_get_sidebar_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_sidebar_header_mpobj, 1, mp_lv_obj_create, lv_menu_get_sidebar_header);
    
/* Reusing lv_obj_create for lv_menu_get_sidebar_header_back_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_sidebar_header_back_button_mpobj, 1, mp_lv_obj_create, lv_menu_get_sidebar_header_back_button);
    

/*
 * lvgl extension definition for:
 * bool lv_menu_back_button_is_root(lv_obj_t *menu, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_menu_back_button_is_root(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *menu = mp_to_lv(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(menu, obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_back_button_is_root_mpobj, 2, mp_lv_menu_back_button_is_root, lv_menu_back_button_is_root);
    
/* Reusing lv_obj_center for lv_menu_clear_history */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_clear_history_mpobj, 1, mp_lv_obj_center, lv_menu_clear_history);
    
/* Reusing lv_obj_create for lv_menu_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_create_mpobj, 1, mp_lv_obj_create, lv_menu_create);
    

/*
 * lvgl menu object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_page), MP_ROM_PTR(&mp_lv_menu_set_page_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_page_title), MP_ROM_PTR(&mp_lv_menu_set_page_title_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_page_title_static), MP_ROM_PTR(&mp_lv_menu_set_page_title_static_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_sidebar_page), MP_ROM_PTR(&mp_lv_menu_set_sidebar_page_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode_header), MP_ROM_PTR(&mp_lv_menu_set_mode_header_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode_root_back_button), MP_ROM_PTR(&mp_lv_menu_set_mode_root_back_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_load_page_event), MP_ROM_PTR(&mp_lv_menu_set_load_page_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cur_main_page), MP_ROM_PTR(&mp_lv_menu_get_cur_main_page_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cur_sidebar_page), MP_ROM_PTR(&mp_lv_menu_get_cur_sidebar_page_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_main_header), MP_ROM_PTR(&mp_lv_menu_get_main_header_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_main_header_back_button), MP_ROM_PTR(&mp_lv_menu_get_main_header_back_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_sidebar_header), MP_ROM_PTR(&mp_lv_menu_get_sidebar_header_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_sidebar_header_back_button), MP_ROM_PTR(&mp_lv_menu_get_sidebar_header_back_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_back_button_is_root), MP_ROM_PTR(&mp_lv_menu_back_button_is_root_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_history), MP_ROM_PTR(&mp_lv_menu_clear_history_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_HEADER), MP_ROM_PTR(&mp_lv_LV_MENU_HEADER_type_base) },
    { MP_ROM_QSTR(MP_QSTR_ROOT_BACK_BUTTON), MP_ROM_PTR(&mp_lv_LV_MENU_ROOT_BACK_BUTTON_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(menu_locals_dict, menu_locals_dict_table);

STATIC void menu_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu");
}


STATIC mp_obj_t menu_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_menu_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_menu_type_base,
    MP_QSTR_menu,
    MP_TYPE_FLAG_NONE,
    print, menu_print,
    make_new, menu_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &menu_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_menu_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_menu_class,
#endif
    .mp_obj_type = &mp_lv_menu_type_base,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_menu_page_create(lv_obj_t *parent, const char * const title)
 */

STATIC mp_obj_t mp_lv_menu_page_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    const char * const title = (const char * const)(char*)convert_from_str(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const char * const))lv_func_ptr)(parent, title);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_page_create_mpobj, 2, mp_lv_menu_page_create, lv_menu_page_create);
    

/*
 * lvgl menu_page object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_page_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(menu_page_locals_dict, menu_page_locals_dict_table);

STATIC void menu_page_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu_page");
}


STATIC mp_obj_t menu_page_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_menu_page_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_menu_page_type_base,
    MP_QSTR_menu_page,
    MP_TYPE_FLAG_NONE,
    print, menu_page_print,
    make_new, menu_page_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &menu_page_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_menu_page_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_menu_page_class,
#endif
    .mp_obj_type = &mp_lv_menu_page_type_base,
};
    
/* Reusing lv_obj_create for lv_menu_cont_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_cont_create_mpobj, 1, mp_lv_obj_create, lv_menu_cont_create);
    

/*
 * lvgl menu_cont object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_cont_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(menu_cont_locals_dict, menu_cont_locals_dict_table);

STATIC void menu_cont_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu_cont");
}


STATIC mp_obj_t menu_cont_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_menu_cont_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_menu_cont_type_base,
    MP_QSTR_menu_cont,
    MP_TYPE_FLAG_NONE,
    print, menu_cont_print,
    make_new, menu_cont_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &menu_cont_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_menu_cont_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_menu_cont_class,
#endif
    .mp_obj_type = &mp_lv_menu_cont_type_base,
};
    
/* Reusing lv_obj_create for lv_menu_section_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_section_create_mpobj, 1, mp_lv_obj_create, lv_menu_section_create);
    

/*
 * lvgl menu_section object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_section_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(menu_section_locals_dict, menu_section_locals_dict_table);

STATIC void menu_section_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu_section");
}


STATIC mp_obj_t menu_section_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_menu_section_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_menu_section_type_base,
    MP_QSTR_menu_section,
    MP_TYPE_FLAG_NONE,
    print, menu_section_print,
    make_new, menu_section_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &menu_section_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_menu_section_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_menu_section_class,
#endif
    .mp_obj_type = &mp_lv_menu_section_type_base,
};
    
/* Reusing lv_obj_create for lv_menu_separator_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_separator_create_mpobj, 1, mp_lv_obj_create, lv_menu_separator_create);
    

/*
 * lvgl menu_separator object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_separator_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(menu_separator_locals_dict, menu_separator_locals_dict_table);

STATIC void menu_separator_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu_separator");
}


STATIC mp_obj_t menu_separator_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_menu_separator_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_menu_separator_type_base,
    MP_QSTR_menu_separator,
    MP_TYPE_FLAG_NONE,
    print, menu_separator_print,
    make_new, menu_separator_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &menu_separator_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_menu_separator_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_menu_separator_class,
#endif
    .mp_obj_type = &mp_lv_menu_separator_type_base,
};
    
/* Reusing lv_list_add_text for lv_msgbox_add_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_title_mpobj, 2, mp_lv_list_add_text, lv_msgbox_add_title);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_msgbox_add_header_button(lv_obj_t *obj, const void *icon)
 */

STATIC mp_obj_t mp_lv_msgbox_add_header_button(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *icon = (const void *)mp_to_ptr(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *))lv_func_ptr)(obj, icon);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_header_button_mpobj, 2, mp_lv_msgbox_add_header_button, lv_msgbox_add_header_button);
    
/* Reusing lv_list_add_text for lv_msgbox_add_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_text_mpobj, 2, mp_lv_list_add_text, lv_msgbox_add_text);
    
/* Reusing lv_list_add_text for lv_msgbox_add_footer_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_footer_button_mpobj, 2, mp_lv_list_add_text, lv_msgbox_add_footer_button);
    
/* Reusing lv_obj_create for lv_msgbox_add_close_button */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_close_button_mpobj, 1, mp_lv_obj_create, lv_msgbox_add_close_button);
    
/* Reusing lv_obj_create for lv_msgbox_get_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_header_mpobj, 1, mp_lv_obj_create, lv_msgbox_get_header);
    
/* Reusing lv_obj_create for lv_msgbox_get_footer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_footer_mpobj, 1, mp_lv_obj_create, lv_msgbox_get_footer);
    
/* Reusing lv_obj_create for lv_msgbox_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_content_mpobj, 1, mp_lv_obj_create, lv_msgbox_get_content);
    
/* Reusing lv_obj_create for lv_msgbox_get_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_title_mpobj, 1, mp_lv_obj_create, lv_msgbox_get_title);
    
/* Reusing lv_obj_center for lv_msgbox_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_close_mpobj, 1, mp_lv_obj_center, lv_msgbox_close);
    
/* Reusing lv_obj_center for lv_msgbox_close_async */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_close_async_mpobj, 1, mp_lv_obj_center, lv_msgbox_close_async);
    
/* Reusing lv_obj_create for lv_msgbox_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_create_mpobj, 1, mp_lv_obj_create, lv_msgbox_create);
    

/*
 * lvgl msgbox object definitions
 */
    

STATIC const mp_rom_map_elem_t msgbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_title), MP_ROM_PTR(&mp_lv_msgbox_add_title_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_header_button), MP_ROM_PTR(&mp_lv_msgbox_add_header_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_msgbox_add_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_footer_button), MP_ROM_PTR(&mp_lv_msgbox_add_footer_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_close_button), MP_ROM_PTR(&mp_lv_msgbox_add_close_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_header), MP_ROM_PTR(&mp_lv_msgbox_get_header_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_footer), MP_ROM_PTR(&mp_lv_msgbox_get_footer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_msgbox_get_content_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_title), MP_ROM_PTR(&mp_lv_msgbox_get_title_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_msgbox_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close_async), MP_ROM_PTR(&mp_lv_msgbox_close_async_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(msgbox_locals_dict, msgbox_locals_dict_table);

STATIC void msgbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl msgbox");
}


STATIC mp_obj_t msgbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_msgbox_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_msgbox_type_base,
    MP_QSTR_msgbox,
    MP_TYPE_FLAG_NONE,
    print, msgbox_print,
    make_new, msgbox_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &msgbox_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_msgbox_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_msgbox_class,
#endif
    .mp_obj_type = &mp_lv_msgbox_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_options(lv_obj_t *obj, const char *options, lv_roller_mode_t mode)
 */

STATIC mp_obj_t mp_lv_roller_set_options(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *options = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_roller_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, lv_roller_mode_t))lv_func_ptr)(obj, options, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_options_mpobj, 3, mp_lv_roller_set_options, lv_roller_set_options);
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_selected(lv_obj_t *obj, uint32_t sel_opt, lv_anim_enable_t anim)
 */

STATIC mp_obj_t mp_lv_roller_set_selected(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t sel_opt = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_anim_enable_t))lv_func_ptr)(obj, sel_opt, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_selected_mpobj, 3, mp_lv_roller_set_selected, lv_roller_set_selected);
    
/* Reusing lv_obj_delete_delayed for lv_roller_set_visible_row_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_visible_row_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_roller_set_visible_row_count);
    
/* Reusing lv_obj_get_child_count for lv_roller_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_mpobj, 1, mp_lv_obj_get_child_count, lv_roller_get_selected);
    
/* Reusing lv_dropdown_get_selected_str for lv_roller_get_selected_str */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_str_mpobj, 3, mp_lv_dropdown_get_selected_str, lv_roller_get_selected_str);
    
/* Reusing lv_checkbox_get_text for lv_roller_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_options_mpobj, 1, mp_lv_checkbox_get_text, lv_roller_get_options);
    
/* Reusing lv_obj_get_child_count for lv_roller_get_option_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_option_count_mpobj, 1, mp_lv_obj_get_child_count, lv_roller_get_option_count);
    
/* Reusing lv_arc_bind_value for lv_roller_bind_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_bind_value_mpobj, 2, mp_lv_arc_bind_value, lv_roller_bind_value);
    
/* Reusing lv_obj_create for lv_roller_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_create_mpobj, 1, mp_lv_obj_create, lv_roller_create);
    

/*
 * lvgl roller object definitions
 */
    

STATIC const mp_rom_map_elem_t roller_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_roller_set_options_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_roller_set_selected_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_visible_row_count), MP_ROM_PTR(&mp_lv_roller_set_visible_row_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_roller_get_selected_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_roller_get_selected_str_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_roller_get_options_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_count), MP_ROM_PTR(&mp_lv_roller_get_option_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_value), MP_ROM_PTR(&mp_lv_roller_bind_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_ROLLER_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(roller_locals_dict, roller_locals_dict_table);

STATIC void roller_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl roller");
}


STATIC mp_obj_t roller_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_roller_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_roller_type_base,
    MP_QSTR_roller,
    MP_TYPE_FLAG_NONE,
    print, roller_print,
    make_new, roller_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &roller_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_roller_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_roller_class,
#endif
    .mp_obj_type = &mp_lv_roller_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_scale_set_mode(lv_obj_t *obj, lv_scale_mode_t mode)
 */

STATIC mp_obj_t mp_lv_scale_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scale_mode_t mode = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_scale_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_mode_mpobj, 2, mp_lv_scale_set_mode, lv_scale_set_mode);
    
/* Reusing lv_obj_delete_delayed for lv_scale_set_total_tick_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_total_tick_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_scale_set_total_tick_count);
    
/* Reusing lv_obj_delete_delayed for lv_scale_set_major_tick_every */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_major_tick_every_mpobj, 2, mp_lv_obj_delete_delayed, lv_scale_set_major_tick_every);
    
/* Reusing lv_image_set_antialias for lv_scale_set_label_show */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_label_show_mpobj, 2, mp_lv_image_set_antialias, lv_scale_set_label_show);
    
/* Reusing lv_obj_set_pos for lv_scale_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_range_mpobj, 3, mp_lv_obj_set_pos, lv_scale_set_range);
    
/* Reusing lv_obj_delete_delayed for lv_scale_set_angle_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_angle_range_mpobj, 2, mp_lv_obj_delete_delayed, lv_scale_set_angle_range);
    
/* Reusing lv_obj_move_to_index for lv_scale_set_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_rotation_mpobj, 2, mp_lv_obj_move_to_index, lv_scale_set_rotation);
    

/*
 * lvgl extension definition for:
 * void lv_scale_set_line_needle_value(lv_obj_t *obj, lv_obj_t *needle_line, int32_t needle_length, int32_t value)
 */

STATIC mp_obj_t mp_lv_scale_set_line_needle_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t *needle_line = mp_to_lv(mp_args[1]);
    int32_t needle_length = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_obj_t *, int32_t, int32_t))lv_func_ptr)(obj, needle_line, needle_length, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_line_needle_value_mpobj, 4, mp_lv_scale_set_line_needle_value, lv_scale_set_line_needle_value);
    

/*
 * lvgl extension definition for:
 * void lv_scale_set_image_needle_value(lv_obj_t *obj, lv_obj_t *needle_img, int32_t value)
 */

STATIC mp_obj_t mp_lv_scale_set_image_needle_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t *needle_img = mp_to_lv(mp_args[1]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, int32_t))lv_func_ptr)(obj, needle_img, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_image_needle_value_mpobj, 3, mp_lv_scale_set_image_needle_value, lv_scale_set_image_needle_value);
    
/* Reusing lv_buttonmatrix_set_map for lv_scale_set_text_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_text_src_mpobj, 2, mp_lv_buttonmatrix_set_map, lv_scale_set_text_src);
    
/* Reusing lv_image_set_antialias for lv_scale_set_post_draw */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_set_post_draw_mpobj, 2, mp_lv_image_set_antialias, lv_scale_set_post_draw);
    

/*
 * Struct lv_scale_section_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_scale_section_t_type();

STATIC inline void* mp_write_ptr_lv_scale_section_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_scale_section_t_type()));
    return (lv_scale_section_t*)self->data;
}

#define mp_write_lv_scale_section_t(struct_obj) *((lv_scale_section_t*)mp_write_ptr_lv_scale_section_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_scale_section_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_scale_section_t_type(), field);
}

#define mp_read_lv_scale_section_t(field) mp_read_ptr_lv_scale_section_t(copy_buffer(&field, sizeof(lv_scale_section_t)))
#define mp_read_byref_lv_scale_section_t(field) mp_read_ptr_lv_scale_section_t(&field)

STATIC void mp_lv_scale_section_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_scale_section_t *data = (lv_scale_section_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_main_style: dest[0] = mp_read_ptr_lv_style_t((void*)data->main_style); break; // converting from lv_style_t *;
            case MP_QSTR_indicator_style: dest[0] = mp_read_ptr_lv_style_t((void*)data->indicator_style); break; // converting from lv_style_t *;
            case MP_QSTR_items_style: dest[0] = mp_read_ptr_lv_style_t((void*)data->items_style); break; // converting from lv_style_t *;
            case MP_QSTR_minor_range: dest[0] = mp_obj_new_int(data->minor_range); break; // converting from int32_t;
            case MP_QSTR_major_range: dest[0] = mp_obj_new_int(data->major_range); break; // converting from int32_t;
            case MP_QSTR_first_tick_idx_in_section: dest[0] = mp_obj_new_int_from_uint(data->first_tick_idx_in_section); break; // converting from uint32_t;
            case MP_QSTR_last_tick_idx_in_section: dest[0] = mp_obj_new_int_from_uint(data->last_tick_idx_in_section); break; // converting from uint32_t;
            case MP_QSTR_first_tick_idx_is_major: dest[0] = mp_obj_new_int_from_uint(data->first_tick_idx_is_major); break; // converting from uint32_t;
            case MP_QSTR_last_tick_idx_is_major: dest[0] = mp_obj_new_int_from_uint(data->last_tick_idx_is_major); break; // converting from uint32_t;
            case MP_QSTR_first_tick_in_section_width: dest[0] = mp_obj_new_int(data->first_tick_in_section_width); break; // converting from int32_t;
            case MP_QSTR_last_tick_in_section_width: dest[0] = mp_obj_new_int(data->last_tick_in_section_width); break; // converting from int32_t;
            case MP_QSTR_first_tick_in_section: dest[0] = mp_read_byref_lv_point_t(data->first_tick_in_section); break; // converting from lv_point_t;
            case MP_QSTR_last_tick_in_section: dest[0] = mp_read_byref_lv_point_t(data->last_tick_in_section); break; // converting from lv_point_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_main_style: data->main_style = (void*)mp_write_ptr_lv_style_t(dest[1]); break; // converting to lv_style_t *;
                case MP_QSTR_indicator_style: data->indicator_style = (void*)mp_write_ptr_lv_style_t(dest[1]); break; // converting to lv_style_t *;
                case MP_QSTR_items_style: data->items_style = (void*)mp_write_ptr_lv_style_t(dest[1]); break; // converting to lv_style_t *;
                case MP_QSTR_minor_range: data->minor_range = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_major_range: data->major_range = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_first_tick_idx_in_section: data->first_tick_idx_in_section = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_tick_idx_in_section: data->last_tick_idx_in_section = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_first_tick_idx_is_major: data->first_tick_idx_is_major = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_tick_idx_is_major: data->last_tick_idx_is_major = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_first_tick_in_section_width: data->first_tick_in_section_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_last_tick_in_section_width: data->last_tick_in_section_width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_first_tick_in_section: data->first_tick_in_section = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_last_tick_in_section: data->last_tick_in_section = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_scale_section_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_scale_section_t");
}

STATIC const mp_obj_dict_t mp_lv_scale_section_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_scale_section_t_type,
    MP_QSTR_lv_scale_section_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_scale_section_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_scale_section_t_attr,
    locals_dict, &mp_lv_scale_section_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_scale_section_t_type()
{
    return &mp_lv_scale_section_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_scale_section_t *lv_scale_add_section(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_scale_add_section(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scale_section_t * _res = ((lv_scale_section_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_scale_section_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_add_section_mpobj, 1, mp_lv_scale_add_section, lv_scale_add_section);
    

/*
 * lvgl extension definition for:
 * void lv_scale_section_set_range(lv_scale_section_t *section, int32_t minor_range, int32_t major_range)
 */

STATIC mp_obj_t mp_lv_scale_section_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_scale_section_t *section = mp_write_ptr_lv_scale_section_t(mp_args[0]);
    int32_t minor_range = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t major_range = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_scale_section_t *, int32_t, int32_t))lv_func_ptr)(section, minor_range, major_range);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_section_set_range_mpobj, 3, mp_lv_scale_section_set_range, lv_scale_section_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_scale_section_set_style(lv_scale_section_t *section, uint32_t part, lv_style_t *section_part_style)
 */

STATIC mp_obj_t mp_lv_scale_section_set_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_scale_section_t *section = mp_write_ptr_lv_scale_section_t(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_t *section_part_style = mp_write_ptr_lv_style_t(mp_args[2]);
    ((void (*)(lv_scale_section_t *, uint32_t, lv_style_t *))lv_func_ptr)(section, part, section_part_style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_section_set_style_mpobj, 3, mp_lv_scale_section_set_style, lv_scale_section_set_style);
    

/*
 * lvgl extension definition for:
 * lv_scale_mode_t lv_scale_get_mode(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_scale_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scale_mode_t _res = ((lv_scale_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_mode_mpobj, 1, mp_lv_scale_get_mode, lv_scale_get_mode);
    
/* Reusing lv_obj_get_scroll_top for lv_scale_get_total_tick_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_total_tick_count_mpobj, 1, mp_lv_obj_get_scroll_top, lv_scale_get_total_tick_count);
    
/* Reusing lv_obj_get_scroll_top for lv_scale_get_major_tick_every */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_major_tick_every_mpobj, 1, mp_lv_obj_get_scroll_top, lv_scale_get_major_tick_every);
    
/* Reusing lv_obj_refr_size for lv_scale_get_label_show */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_label_show_mpobj, 1, mp_lv_obj_refr_size, lv_scale_get_label_show);
    
/* Reusing lv_obj_get_event_count for lv_scale_get_angle_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_angle_range_mpobj, 1, mp_lv_obj_get_event_count, lv_scale_get_angle_range);
    
/* Reusing lv_obj_get_scroll_top for lv_scale_get_range_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_range_min_value_mpobj, 1, mp_lv_obj_get_scroll_top, lv_scale_get_range_min_value);
    
/* Reusing lv_obj_get_scroll_top for lv_scale_get_range_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_get_range_max_value_mpobj, 1, mp_lv_obj_get_scroll_top, lv_scale_get_range_max_value);
    
/* Reusing lv_obj_create for lv_scale_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scale_create_mpobj, 1, mp_lv_obj_create, lv_scale_create);
    

/*
 * lvgl scale object definitions
 */
    

STATIC const mp_rom_map_elem_t scale_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_scale_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_total_tick_count), MP_ROM_PTR(&mp_lv_scale_set_total_tick_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_major_tick_every), MP_ROM_PTR(&mp_lv_scale_set_major_tick_every_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_label_show), MP_ROM_PTR(&mp_lv_scale_set_label_show_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_scale_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_angle_range), MP_ROM_PTR(&mp_lv_scale_set_angle_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_scale_set_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_needle_value), MP_ROM_PTR(&mp_lv_scale_set_line_needle_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_needle_value), MP_ROM_PTR(&mp_lv_scale_set_image_needle_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_src), MP_ROM_PTR(&mp_lv_scale_set_text_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_post_draw), MP_ROM_PTR(&mp_lv_scale_set_post_draw_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_section), MP_ROM_PTR(&mp_lv_scale_add_section_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_section_set_range), MP_ROM_PTR(&mp_lv_scale_section_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_section_set_style), MP_ROM_PTR(&mp_lv_scale_section_set_style_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_scale_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_total_tick_count), MP_ROM_PTR(&mp_lv_scale_get_total_tick_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_major_tick_every), MP_ROM_PTR(&mp_lv_scale_get_major_tick_every_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_label_show), MP_ROM_PTR(&mp_lv_scale_get_label_show_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_range), MP_ROM_PTR(&mp_lv_scale_get_angle_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_range_min_value), MP_ROM_PTR(&mp_lv_scale_get_range_min_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_range_max_value), MP_ROM_PTR(&mp_lv_scale_get_range_max_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_SCALE_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(scale_locals_dict, scale_locals_dict_table);

STATIC void scale_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl scale");
}


STATIC mp_obj_t scale_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_scale_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_scale_type_base,
    MP_QSTR_scale,
    MP_TYPE_FLAG_NONE,
    print, scale_print,
    make_new, scale_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &scale_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_scale_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_scale_class,
#endif
    .mp_obj_type = &mp_lv_scale_type_base,
};
    
/* Reusing lv_obj_scroll_to_x for lv_slider_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_value_mpobj, 3, mp_lv_obj_scroll_to_x, lv_slider_set_value);
    
/* Reusing lv_obj_scroll_to_x for lv_slider_set_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_left_value_mpobj, 3, mp_lv_obj_scroll_to_x, lv_slider_set_left_value);
    
/* Reusing lv_obj_set_pos for lv_slider_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_range_mpobj, 3, mp_lv_obj_set_pos, lv_slider_set_range);
    

/*
 * lvgl extension definition for:
 * inline static void lv_slider_set_mode(lv_obj_t *obj, lv_slider_mode_t mode)
 */

STATIC mp_obj_t mp_lv_slider_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_slider_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_slider_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_mode_mpobj, 2, mp_lv_slider_set_mode, lv_slider_set_mode);
    
/* Reusing lv_obj_get_index for lv_slider_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_value_mpobj, 1, mp_lv_obj_get_index, lv_slider_get_value);
    
/* Reusing lv_obj_get_index for lv_slider_get_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_left_value_mpobj, 1, mp_lv_obj_get_index, lv_slider_get_left_value);
    
/* Reusing lv_obj_get_index for lv_slider_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_min_value_mpobj, 1, mp_lv_obj_get_index, lv_slider_get_min_value);
    
/* Reusing lv_obj_get_index for lv_slider_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_max_value_mpobj, 1, mp_lv_obj_get_index, lv_slider_get_max_value);
    

/*
 * lvgl extension definition for:
 * inline static lv_slider_mode_t lv_slider_get_mode(lv_obj_t *slider)
 */

STATIC mp_obj_t mp_lv_slider_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *slider = mp_to_lv(mp_args[0]);
    lv_slider_mode_t _res = ((lv_slider_mode_t (*)(lv_obj_t *))lv_func_ptr)(slider);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_mode_mpobj, 1, mp_lv_slider_get_mode, lv_slider_get_mode);
    
/* Reusing lv_obj_refr_size for lv_slider_is_symmetrical */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_is_symmetrical_mpobj, 1, mp_lv_obj_refr_size, lv_slider_is_symmetrical);
    
/* Reusing lv_obj_is_layout_positioned for lv_slider_is_dragged */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_is_dragged_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_slider_is_dragged);
    
/* Reusing lv_arc_bind_value for lv_slider_bind_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_bind_value_mpobj, 2, mp_lv_arc_bind_value, lv_slider_bind_value);
    
/* Reusing lv_obj_create for lv_slider_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_create_mpobj, 1, mp_lv_obj_create, lv_slider_create);
    

/*
 * lvgl slider object definitions
 */
    

STATIC const mp_rom_map_elem_t slider_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_slider_set_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_left_value), MP_ROM_PTR(&mp_lv_slider_set_left_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_slider_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_slider_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_slider_get_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_left_value), MP_ROM_PTR(&mp_lv_slider_get_left_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_slider_get_min_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_slider_get_max_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_slider_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_symmetrical), MP_ROM_PTR(&mp_lv_slider_is_symmetrical_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_dragged), MP_ROM_PTR(&mp_lv_slider_is_dragged_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bind_value), MP_ROM_PTR(&mp_lv_slider_bind_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_lv_LV_SLIDER_MODE_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(slider_locals_dict, slider_locals_dict_table);

STATIC void slider_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl slider");
}


STATIC mp_obj_t slider_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_slider_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_slider_type_base,
    MP_QSTR_slider,
    MP_TYPE_FLAG_NONE,
    print, slider_print,
    make_new, slider_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &slider_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_slider_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_slider_class,
#endif
    .mp_obj_type = &mp_lv_slider_type_base,
};
    

/*
 * Struct lv_span_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_span_t_type();

STATIC inline void* mp_write_ptr_lv_span_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_span_t_type()));
    return (lv_span_t*)self->data;
}

#define mp_write_lv_span_t(struct_obj) *((lv_span_t*)mp_write_ptr_lv_span_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_span_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_span_t_type(), field);
}

#define mp_read_lv_span_t(field) mp_read_ptr_lv_span_t(copy_buffer(&field, sizeof(lv_span_t)))
#define mp_read_byref_lv_span_t(field) mp_read_ptr_lv_span_t(&field)

STATIC void mp_lv_span_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_span_t *data = (lv_span_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_txt: dest[0] = convert_to_str((void*)data->txt); break; // converting from char *;
            case MP_QSTR_spangroup: dest[0] = lv_to_mp((void*)data->spangroup); break; // converting from lv_obj_t *;
            case MP_QSTR_style: dest[0] = mp_read_byref_lv_style_t(data->style); break; // converting from lv_style_t;
            case MP_QSTR_static_flag: dest[0] = mp_obj_new_int_from_uint(data->static_flag); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_txt: data->txt = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_spangroup: data->spangroup = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_style: data->style = mp_write_lv_style_t(dest[1]); break; // converting to lv_style_t;
                case MP_QSTR_static_flag: data->static_flag = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_span_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_span_t");
}

STATIC const mp_obj_dict_t mp_lv_span_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_span_t_type,
    MP_QSTR_lv_span_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_span_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_span_t_attr,
    locals_dict, &mp_lv_span_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_span_t_type()
{
    return &mp_lv_span_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_span_t *lv_spangroup_new_span(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_spangroup_new_span(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_t * _res = ((lv_span_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_span_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_new_span_mpobj, 1, mp_lv_spangroup_new_span, lv_spangroup_new_span);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_delete_span(lv_obj_t *obj, lv_span_t *span)
 */

STATIC mp_obj_t mp_lv_spangroup_delete_span(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_t *span = mp_write_ptr_lv_span_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_t *))lv_func_ptr)(obj, span);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_delete_span_mpobj, 2, mp_lv_spangroup_delete_span, lv_spangroup_delete_span);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_set_align(lv_obj_t *obj, lv_text_align_t align)
 */

STATIC mp_obj_t mp_lv_spangroup_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_text_align_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_align_mpobj, 2, mp_lv_spangroup_set_align, lv_spangroup_set_align);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_set_overflow(lv_obj_t *obj, lv_span_overflow_t overflow)
 */

STATIC mp_obj_t mp_lv_spangroup_set_overflow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_overflow_t overflow = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_overflow_t))lv_func_ptr)(obj, overflow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_overflow_mpobj, 2, mp_lv_spangroup_set_overflow, lv_spangroup_set_overflow);
    
/* Reusing lv_obj_move_to_index for lv_spangroup_set_indent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_indent_mpobj, 2, mp_lv_obj_move_to_index, lv_spangroup_set_indent);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_set_mode(lv_obj_t *obj, lv_span_mode_t mode)
 */

STATIC mp_obj_t mp_lv_spangroup_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_mode_t mode = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_mode_mpobj, 2, mp_lv_spangroup_set_mode, lv_spangroup_set_mode);
    
/* Reusing lv_obj_move_to_index for lv_spangroup_set_max_lines */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_max_lines_mpobj, 2, mp_lv_obj_move_to_index, lv_spangroup_set_max_lines);
    

/*
 * lvgl extension definition for:
 * lv_span_t *lv_spangroup_get_child(const lv_obj_t *obj, int32_t id)
 */

STATIC mp_obj_t mp_lv_spangroup_get_child(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = (const lv_obj_t *)mp_to_lv(mp_args[0]);
    int32_t id = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_span_t * _res = ((lv_span_t *(*)(const lv_obj_t *, int32_t))lv_func_ptr)(obj, id);
    return mp_read_ptr_lv_span_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_child_mpobj, 2, mp_lv_spangroup_get_child, lv_spangroup_get_child);
    
/* Reusing lv_obj_get_child_count for lv_spangroup_get_span_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_span_count_mpobj, 1, mp_lv_obj_get_child_count, lv_spangroup_get_span_count);
    

/*
 * lvgl extension definition for:
 * lv_text_align_t lv_spangroup_get_align(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_spangroup_get_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t _res = ((lv_text_align_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_align_mpobj, 1, mp_lv_spangroup_get_align, lv_spangroup_get_align);
    

/*
 * lvgl extension definition for:
 * lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_spangroup_get_overflow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_overflow_t _res = ((lv_span_overflow_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_overflow_mpobj, 1, mp_lv_spangroup_get_overflow, lv_spangroup_get_overflow);
    
/* Reusing lv_obj_get_scroll_top for lv_spangroup_get_indent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_indent_mpobj, 1, mp_lv_obj_get_scroll_top, lv_spangroup_get_indent);
    

/*
 * lvgl extension definition for:
 * lv_span_mode_t lv_spangroup_get_mode(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_spangroup_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_mode_t _res = ((lv_span_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_mode_mpobj, 1, mp_lv_spangroup_get_mode, lv_spangroup_get_mode);
    
/* Reusing lv_obj_get_scroll_top for lv_spangroup_get_max_lines */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_max_lines_mpobj, 1, mp_lv_obj_get_scroll_top, lv_spangroup_get_max_lines);
    
/* Reusing lv_obj_get_scroll_top for lv_spangroup_get_max_line_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_max_line_height_mpobj, 1, mp_lv_obj_get_scroll_top, lv_spangroup_get_max_line_height);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_spangroup_get_expand_width(lv_obj_t *obj, uint32_t max_width)
 */

STATIC mp_obj_t mp_lv_spangroup_get_expand_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t max_width = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, max_width);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_expand_width_mpobj, 2, mp_lv_spangroup_get_expand_width, lv_spangroup_get_expand_width);
    

/*
 * lvgl extension definition for:
 * int32_t lv_spangroup_get_expand_height(lv_obj_t *obj, int32_t width)
 */

STATIC mp_obj_t mp_lv_spangroup_get_expand_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t width = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_obj_t *, int32_t))lv_func_ptr)(obj, width);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_expand_height_mpobj, 2, mp_lv_spangroup_get_expand_height, lv_spangroup_get_expand_height);
    
/* Reusing lv_obj_center for lv_spangroup_refr_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_refr_mode_mpobj, 1, mp_lv_obj_center, lv_spangroup_refr_mode);
    
/* Reusing lv_obj_create for lv_spangroup_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_create_mpobj, 1, mp_lv_obj_create, lv_spangroup_create);
    

/*
 * lvgl spangroup object definitions
 */
    

STATIC const mp_rom_map_elem_t spangroup_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_new_span), MP_ROM_PTR(&mp_lv_spangroup_new_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_span), MP_ROM_PTR(&mp_lv_spangroup_delete_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_spangroup_set_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_overflow), MP_ROM_PTR(&mp_lv_spangroup_set_overflow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_indent), MP_ROM_PTR(&mp_lv_spangroup_set_indent_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_spangroup_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_lines), MP_ROM_PTR(&mp_lv_spangroup_set_max_lines_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_child), MP_ROM_PTR(&mp_lv_spangroup_get_child_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_span_count), MP_ROM_PTR(&mp_lv_spangroup_get_span_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_spangroup_get_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_overflow), MP_ROM_PTR(&mp_lv_spangroup_get_overflow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_indent), MP_ROM_PTR(&mp_lv_spangroup_get_indent_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_spangroup_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_lines), MP_ROM_PTR(&mp_lv_spangroup_get_max_lines_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_line_height), MP_ROM_PTR(&mp_lv_spangroup_get_max_line_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_expand_width), MP_ROM_PTR(&mp_lv_spangroup_get_expand_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_expand_height), MP_ROM_PTR(&mp_lv_spangroup_get_expand_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refr_mode), MP_ROM_PTR(&mp_lv_spangroup_refr_mode_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(spangroup_locals_dict, spangroup_locals_dict_table);

STATIC void spangroup_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spangroup");
}


STATIC mp_obj_t spangroup_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_spangroup_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_spangroup_type_base,
    MP_QSTR_spangroup,
    MP_TYPE_FLAG_NONE,
    print, spangroup_print,
    make_new, spangroup_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &spangroup_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_spangroup_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_spangroup_class,
#endif
    .mp_obj_type = &mp_lv_spangroup_type_base,
};
    
/* Reusing lv_obj_delete_delayed for lv_textarea_add_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_char_mpobj, 2, mp_lv_obj_delete_delayed, lv_textarea_add_char);
    
/* Reusing lv_label_set_text for lv_textarea_add_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_text_mpobj, 2, mp_lv_label_set_text, lv_textarea_add_text);
    
/* Reusing lv_obj_center for lv_textarea_delete_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_delete_char_mpobj, 1, mp_lv_obj_center, lv_textarea_delete_char);
    
/* Reusing lv_obj_center for lv_textarea_delete_char_forward */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_delete_char_forward_mpobj, 1, mp_lv_obj_center, lv_textarea_delete_char_forward);
    
/* Reusing lv_label_set_text for lv_textarea_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_mpobj, 2, mp_lv_label_set_text, lv_textarea_set_text);
    
/* Reusing lv_label_set_text for lv_textarea_set_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_placeholder_text_mpobj, 2, mp_lv_label_set_text, lv_textarea_set_placeholder_text);
    
/* Reusing lv_obj_move_to_index for lv_textarea_set_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_pos_mpobj, 2, mp_lv_obj_move_to_index, lv_textarea_set_cursor_pos);
    
/* Reusing lv_image_set_antialias for lv_textarea_set_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_click_pos_mpobj, 2, mp_lv_image_set_antialias, lv_textarea_set_cursor_click_pos);
    
/* Reusing lv_image_set_antialias for lv_textarea_set_password_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_mode_mpobj, 2, mp_lv_image_set_antialias, lv_textarea_set_password_mode);
    
/* Reusing lv_label_set_text for lv_textarea_set_password_bullet */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_bullet_mpobj, 2, mp_lv_label_set_text, lv_textarea_set_password_bullet);
    
/* Reusing lv_image_set_antialias for lv_textarea_set_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_one_line_mpobj, 2, mp_lv_image_set_antialias, lv_textarea_set_one_line);
    
/* Reusing lv_label_set_text for lv_textarea_set_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_accepted_chars_mpobj, 2, mp_lv_label_set_text, lv_textarea_set_accepted_chars);
    
/* Reusing lv_obj_delete_delayed for lv_textarea_set_max_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_max_length_mpobj, 2, mp_lv_obj_delete_delayed, lv_textarea_set_max_length);
    
/* Reusing lv_label_set_text for lv_textarea_set_insert_replace */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_insert_replace_mpobj, 2, mp_lv_label_set_text, lv_textarea_set_insert_replace);
    
/* Reusing lv_image_set_antialias for lv_textarea_set_text_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_selection_mpobj, 2, mp_lv_image_set_antialias, lv_textarea_set_text_selection);
    
/* Reusing lv_obj_delete_delayed for lv_textarea_set_password_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_show_time_mpobj, 2, mp_lv_obj_delete_delayed, lv_textarea_set_password_show_time);
    
/* Reusing lv_spangroup_set_align for lv_textarea_set_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_align_mpobj, 2, mp_lv_spangroup_set_align, lv_textarea_set_align);
    
/* Reusing lv_checkbox_get_text for lv_textarea_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_mpobj, 1, mp_lv_checkbox_get_text, lv_textarea_get_text);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_placeholder_text_mpobj, 1, mp_lv_dropdown_get_text, lv_textarea_get_placeholder_text);
    
/* Reusing lv_obj_get_screen for lv_textarea_get_label */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_label_mpobj, 1, mp_lv_obj_get_screen, lv_textarea_get_label);
    
/* Reusing lv_obj_get_child_count for lv_textarea_get_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_pos_mpobj, 1, mp_lv_obj_get_child_count, lv_textarea_get_cursor_pos);
    
/* Reusing lv_obj_refr_size for lv_textarea_get_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_click_pos_mpobj, 1, mp_lv_obj_refr_size, lv_textarea_get_cursor_click_pos);
    
/* Reusing lv_obj_is_layout_positioned for lv_textarea_get_password_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_mode_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_textarea_get_password_mode);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_password_bullet */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_bullet_mpobj, 1, mp_lv_dropdown_get_text, lv_textarea_get_password_bullet);
    
/* Reusing lv_obj_is_layout_positioned for lv_textarea_get_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_one_line_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_textarea_get_one_line);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_accepted_chars_mpobj, 1, mp_lv_dropdown_get_text, lv_textarea_get_accepted_chars);
    
/* Reusing lv_obj_get_event_count for lv_textarea_get_max_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_max_length_mpobj, 1, mp_lv_obj_get_event_count, lv_textarea_get_max_length);
    
/* Reusing lv_obj_is_layout_positioned for lv_textarea_text_is_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_text_is_selected_mpobj, 1, mp_lv_obj_is_layout_positioned, lv_textarea_text_is_selected);
    
/* Reusing lv_obj_refr_size for lv_textarea_get_text_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_selection_mpobj, 1, mp_lv_obj_refr_size, lv_textarea_get_text_selection);
    
/* Reusing lv_obj_get_event_count for lv_textarea_get_password_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_show_time_mpobj, 1, mp_lv_obj_get_event_count, lv_textarea_get_password_show_time);
    
/* Reusing lv_obj_get_event_count for lv_textarea_get_current_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_current_char_mpobj, 1, mp_lv_obj_get_event_count, lv_textarea_get_current_char);
    
/* Reusing lv_obj_center for lv_textarea_clear_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_clear_selection_mpobj, 1, mp_lv_obj_center, lv_textarea_clear_selection);
    
/* Reusing lv_obj_center for lv_textarea_cursor_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_right_mpobj, 1, mp_lv_obj_center, lv_textarea_cursor_right);
    
/* Reusing lv_obj_center for lv_textarea_cursor_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_left_mpobj, 1, mp_lv_obj_center, lv_textarea_cursor_left);
    
/* Reusing lv_obj_center for lv_textarea_cursor_down */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_down_mpobj, 1, mp_lv_obj_center, lv_textarea_cursor_down);
    
/* Reusing lv_obj_center for lv_textarea_cursor_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_up_mpobj, 1, mp_lv_obj_center, lv_textarea_cursor_up);
    
/* Reusing lv_obj_create for lv_textarea_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_create_mpobj, 1, mp_lv_obj_create, lv_textarea_create);
    

/*
 * lvgl textarea object definitions
 */
    

STATIC const mp_rom_map_elem_t textarea_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_char), MP_ROM_PTR(&mp_lv_textarea_add_char_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_textarea_add_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_char), MP_ROM_PTR(&mp_lv_textarea_delete_char_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_char_forward), MP_ROM_PTR(&mp_lv_textarea_delete_char_forward_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_textarea_set_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_set_placeholder_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_click_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_mode), MP_ROM_PTR(&mp_lv_textarea_set_password_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_bullet), MP_ROM_PTR(&mp_lv_textarea_set_password_bullet_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_line), MP_ROM_PTR(&mp_lv_textarea_set_one_line_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_set_accepted_chars_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_length), MP_ROM_PTR(&mp_lv_textarea_set_max_length_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_insert_replace), MP_ROM_PTR(&mp_lv_textarea_set_insert_replace_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_selection), MP_ROM_PTR(&mp_lv_textarea_set_text_selection_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_show_time), MP_ROM_PTR(&mp_lv_textarea_set_password_show_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_textarea_set_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_textarea_get_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_get_placeholder_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_label), MP_ROM_PTR(&mp_lv_textarea_get_label_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_click_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_mode), MP_ROM_PTR(&mp_lv_textarea_get_password_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_bullet), MP_ROM_PTR(&mp_lv_textarea_get_password_bullet_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_line), MP_ROM_PTR(&mp_lv_textarea_get_one_line_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_get_accepted_chars_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_length), MP_ROM_PTR(&mp_lv_textarea_get_max_length_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_text_is_selected), MP_ROM_PTR(&mp_lv_textarea_text_is_selected_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection), MP_ROM_PTR(&mp_lv_textarea_get_text_selection_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_show_time), MP_ROM_PTR(&mp_lv_textarea_get_password_show_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_current_char), MP_ROM_PTR(&mp_lv_textarea_get_current_char_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_selection), MP_ROM_PTR(&mp_lv_textarea_clear_selection_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_right), MP_ROM_PTR(&mp_lv_textarea_cursor_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_left), MP_ROM_PTR(&mp_lv_textarea_cursor_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_down), MP_ROM_PTR(&mp_lv_textarea_cursor_down_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_up), MP_ROM_PTR(&mp_lv_textarea_cursor_up_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(textarea_locals_dict, textarea_locals_dict_table);

STATIC void textarea_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl textarea");
}


STATIC mp_obj_t textarea_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_textarea_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_textarea_type_base,
    MP_QSTR_textarea,
    MP_TYPE_FLAG_NONE,
    print, textarea_print,
    make_new, textarea_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &textarea_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_textarea_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_textarea_class,
#endif
    .mp_obj_type = &mp_lv_textarea_type_base,
};
    
/* Reusing lv_obj_move_to_index for lv_spinbox_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_value_mpobj, 2, mp_lv_obj_move_to_index, lv_spinbox_set_value);
    
/* Reusing lv_image_set_antialias for lv_spinbox_set_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_rollover_mpobj, 2, mp_lv_image_set_antialias, lv_spinbox_set_rollover);
    
/* Reusing lv_obj_fade_in for lv_spinbox_set_digit_format */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_digit_format_mpobj, 3, mp_lv_obj_fade_in, lv_spinbox_set_digit_format);
    
/* Reusing lv_obj_delete_delayed for lv_spinbox_set_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_step_mpobj, 2, mp_lv_obj_delete_delayed, lv_spinbox_set_step);
    
/* Reusing lv_obj_set_pos for lv_spinbox_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_range_mpobj, 3, mp_lv_obj_set_pos, lv_spinbox_set_range);
    
/* Reusing lv_obj_delete_delayed for lv_spinbox_set_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_cursor_pos_mpobj, 2, mp_lv_obj_delete_delayed, lv_spinbox_set_cursor_pos);
    
/* Reusing lv_obj_set_scroll_dir for lv_spinbox_set_digit_step_direction */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_digit_step_direction_mpobj, 2, mp_lv_obj_set_scroll_dir, lv_spinbox_set_digit_step_direction);
    
/* Reusing lv_obj_refr_size for lv_spinbox_get_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_rollover_mpobj, 1, mp_lv_obj_refr_size, lv_spinbox_get_rollover);
    
/* Reusing lv_obj_get_scroll_top for lv_spinbox_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_value_mpobj, 1, mp_lv_obj_get_scroll_top, lv_spinbox_get_value);
    
/* Reusing lv_obj_get_scroll_top for lv_spinbox_get_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_step_mpobj, 1, mp_lv_obj_get_scroll_top, lv_spinbox_get_step);
    
/* Reusing lv_obj_center for lv_spinbox_step_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_next_mpobj, 1, mp_lv_obj_center, lv_spinbox_step_next);
    
/* Reusing lv_obj_center for lv_spinbox_step_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_prev_mpobj, 1, mp_lv_obj_center, lv_spinbox_step_prev);
    
/* Reusing lv_obj_center for lv_spinbox_increment */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_increment_mpobj, 1, mp_lv_obj_center, lv_spinbox_increment);
    
/* Reusing lv_obj_center for lv_spinbox_decrement */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_decrement_mpobj, 1, mp_lv_obj_center, lv_spinbox_decrement);
    
/* Reusing lv_obj_create for lv_spinbox_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_create_mpobj, 1, mp_lv_obj_create, lv_spinbox_create);
    

/*
 * lvgl spinbox object definitions
 */
    

STATIC const mp_rom_map_elem_t spinbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_spinbox_set_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_rollover), MP_ROM_PTR(&mp_lv_spinbox_set_rollover_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_digit_format), MP_ROM_PTR(&mp_lv_spinbox_set_digit_format_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_step), MP_ROM_PTR(&mp_lv_spinbox_set_step_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_spinbox_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_spinbox_set_cursor_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_digit_step_direction), MP_ROM_PTR(&mp_lv_spinbox_set_digit_step_direction_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_rollover), MP_ROM_PTR(&mp_lv_spinbox_get_rollover_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_spinbox_get_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_step), MP_ROM_PTR(&mp_lv_spinbox_get_step_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_step_next), MP_ROM_PTR(&mp_lv_spinbox_step_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_step_prev), MP_ROM_PTR(&mp_lv_spinbox_step_prev_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_increment), MP_ROM_PTR(&mp_lv_spinbox_increment_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_decrement), MP_ROM_PTR(&mp_lv_spinbox_decrement_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(spinbox_locals_dict, spinbox_locals_dict_table);

STATIC void spinbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinbox");
}


STATIC mp_obj_t spinbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_spinbox_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_spinbox_type_base,
    MP_QSTR_spinbox,
    MP_TYPE_FLAG_NONE,
    print, spinbox_print,
    make_new, spinbox_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &spinbox_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_spinbox_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_spinbox_class,
#endif
    .mp_obj_type = &mp_lv_spinbox_type_base,
};
    
/* Reusing lv_obj_fade_in for lv_spinner_set_anim_params */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_set_anim_params_mpobj, 3, mp_lv_obj_fade_in, lv_spinner_set_anim_params);
    
/* Reusing lv_obj_create for lv_spinner_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_create_mpobj, 1, mp_lv_obj_create, lv_spinner_create);
    

/*
 * lvgl spinner object definitions
 */
    

STATIC const mp_rom_map_elem_t spinner_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_anim_params), MP_ROM_PTR(&mp_lv_spinner_set_anim_params_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(spinner_locals_dict, spinner_locals_dict_table);

STATIC void spinner_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinner");
}


STATIC mp_obj_t spinner_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_spinner_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_spinner_type_base,
    MP_QSTR_spinner,
    MP_TYPE_FLAG_NONE,
    print, spinner_print,
    make_new, spinner_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &spinner_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_spinner_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_spinner_class,
#endif
    .mp_obj_type = &mp_lv_spinner_type_base,
};
    
/* Reusing lv_obj_create for lv_switch_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_create_mpobj, 1, mp_lv_obj_create, lv_switch_create);
    

/*
 * lvgl switch object definitions
 */
    

STATIC const mp_rom_map_elem_t switch_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(switch_locals_dict, switch_locals_dict_table);

STATIC void switch_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl switch");
}


STATIC mp_obj_t switch_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_switch_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_switch_type_base,
    MP_QSTR_switch,
    MP_TYPE_FLAG_NONE,
    print, switch_print,
    make_new, switch_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &switch_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_switch_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_switch_class,
#endif
    .mp_obj_type = &mp_lv_switch_type_base,
};
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_value(lv_obj_t *obj, uint32_t row, uint32_t col, const char *txt)
 */

STATIC mp_obj_t mp_lv_table_set_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t row = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t col = (uint32_t)mp_obj_get_int(mp_args[2]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, const char *))lv_func_ptr)(obj, row, col, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_value_mpobj, 4, mp_lv_table_set_cell_value, lv_table_set_cell_value);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_table_set_cell_value_fmt(lv_obj_t *obj, uint32_t row, uint32_t col, const char *fmt, ...)
 */
    
/* Reusing lv_obj_delete_delayed for lv_table_set_row_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_row_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_table_set_row_count);
    
/* Reusing lv_obj_delete_delayed for lv_table_set_column_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_column_count_mpobj, 2, mp_lv_obj_delete_delayed, lv_table_set_column_count);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_column_width(lv_obj_t *obj, uint32_t col_id, int32_t w)
 */

STATIC mp_obj_t mp_lv_table_set_column_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t col_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    int32_t w = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, int32_t))lv_func_ptr)(obj, col_id, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_column_width_mpobj, 3, mp_lv_table_set_column_width, lv_table_set_column_width);
    

/*
 * lvgl extension definition for:
 * void lv_table_add_cell_ctrl(lv_obj_t *obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl)
 */

STATIC mp_obj_t mp_lv_table_add_cell_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t row = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t col = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_table_cell_ctrl_t ctrl = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, lv_table_cell_ctrl_t))lv_func_ptr)(obj, row, col, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_add_cell_ctrl_mpobj, 4, mp_lv_table_add_cell_ctrl, lv_table_add_cell_ctrl);
    
/* Reusing lv_table_add_cell_ctrl for lv_table_clear_cell_ctrl */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_clear_cell_ctrl_mpobj, 4, mp_lv_table_add_cell_ctrl, lv_table_clear_cell_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_user_data(lv_obj_t *obj, uint16_t row, uint16_t col, void *user_data)
 */

STATIC mp_obj_t mp_lv_table_set_cell_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, void *))lv_func_ptr)(obj, row, col, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_user_data_mpobj, 4, mp_lv_table_set_cell_user_data, lv_table_set_cell_user_data);
    

/*
 * lvgl extension definition for:
 * const char *lv_table_get_cell_value(lv_obj_t *obj, uint32_t row, uint32_t col)
 */

STATIC mp_obj_t mp_lv_table_get_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t row = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t col = (uint32_t)mp_obj_get_int(mp_args[2]);
    const char * _res = ((const char *(*)(lv_obj_t *, uint32_t, uint32_t))lv_func_ptr)(obj, row, col);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_value_mpobj, 3, mp_lv_table_get_cell_value, lv_table_get_cell_value);
    
/* Reusing lv_obj_get_event_count for lv_table_get_row_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_row_count_mpobj, 1, mp_lv_obj_get_event_count, lv_table_get_row_count);
    
/* Reusing lv_obj_get_event_count for lv_table_get_column_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_column_count_mpobj, 1, mp_lv_obj_get_event_count, lv_table_get_column_count);
    
/* Reusing lv_obj_calculate_ext_draw_size for lv_table_get_column_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_column_width_mpobj, 2, mp_lv_obj_calculate_ext_draw_size, lv_table_get_column_width);
    

/*
 * lvgl extension definition for:
 * bool lv_table_has_cell_ctrl(lv_obj_t *obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl)
 */

STATIC mp_obj_t mp_lv_table_has_cell_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t row = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t col = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_table_cell_ctrl_t ctrl = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(lv_obj_t *, uint32_t, uint32_t, lv_table_cell_ctrl_t))lv_func_ptr)(obj, row, col, ctrl);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_has_cell_ctrl_mpobj, 4, mp_lv_table_has_cell_ctrl, lv_table_has_cell_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_table_get_selected_cell(lv_obj_t *obj, uint32_t *row, uint32_t *col)
 */

STATIC mp_obj_t mp_lv_table_get_selected_cell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t *row = mp_array_to_u32ptr(mp_args[1]);
    uint32_t *col = mp_array_to_u32ptr(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t *, uint32_t *))lv_func_ptr)(obj, row, col);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_selected_cell_mpobj, 3, mp_lv_table_get_selected_cell, lv_table_get_selected_cell);
    

/*
 * lvgl extension definition for:
 * void *lv_table_get_cell_user_data(lv_obj_t *obj, uint16_t row, uint16_t col)
 */

STATIC mp_obj_t mp_lv_table_get_cell_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(obj, row, col);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_user_data_mpobj, 3, mp_lv_table_get_cell_user_data, lv_table_get_cell_user_data);
    
/* Reusing lv_obj_create for lv_table_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_create_mpobj, 1, mp_lv_obj_create, lv_table_create);
    

/*
 * lvgl table object definitions
 */
    

STATIC const mp_rom_map_elem_t table_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_cell_value), MP_ROM_PTR(&mp_lv_table_set_cell_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_row_count), MP_ROM_PTR(&mp_lv_table_set_row_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_column_count), MP_ROM_PTR(&mp_lv_table_set_column_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_column_width), MP_ROM_PTR(&mp_lv_table_set_column_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_cell_ctrl), MP_ROM_PTR(&mp_lv_table_add_cell_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear_cell_ctrl), MP_ROM_PTR(&mp_lv_table_clear_cell_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cell_user_data), MP_ROM_PTR(&mp_lv_table_set_cell_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_value), MP_ROM_PTR(&mp_lv_table_get_cell_value_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_row_count), MP_ROM_PTR(&mp_lv_table_get_row_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_column_count), MP_ROM_PTR(&mp_lv_table_get_column_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_column_width), MP_ROM_PTR(&mp_lv_table_get_column_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_has_cell_ctrl), MP_ROM_PTR(&mp_lv_table_has_cell_ctrl_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_cell), MP_ROM_PTR(&mp_lv_table_get_selected_cell_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_user_data), MP_ROM_PTR(&mp_lv_table_get_cell_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_CELL_CTRL), MP_ROM_PTR(&mp_lv_LV_TABLE_CELL_CTRL_type_base) }
};

STATIC MP_DEFINE_CONST_DICT(table_locals_dict, table_locals_dict_table);

STATIC void table_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl table");
}


STATIC mp_obj_t table_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_table_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_table_type_base,
    MP_QSTR_table,
    MP_TYPE_FLAG_NONE,
    print, table_print,
    make_new, table_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &table_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_table_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_table_class,
#endif
    .mp_obj_type = &mp_lv_table_type_base,
};
    
/* Reusing lv_list_add_text for lv_tabview_add_tab */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_add_tab_mpobj, 2, mp_lv_list_add_text, lv_tabview_add_tab);
    
/* Reusing lv_label_ins_text for lv_tabview_rename_tab */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_rename_tab_mpobj, 3, mp_lv_label_ins_text, lv_tabview_rename_tab);
    
/* Reusing lv_roller_set_selected for lv_tabview_set_active */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_active_mpobj, 3, mp_lv_roller_set_selected, lv_tabview_set_active);
    
/* Reusing lv_obj_set_scroll_dir for lv_tabview_set_tab_bar_position */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_tab_bar_position_mpobj, 2, mp_lv_obj_set_scroll_dir, lv_tabview_set_tab_bar_position);
    
/* Reusing lv_obj_move_to_index for lv_tabview_set_tab_bar_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_tab_bar_size_mpobj, 2, mp_lv_obj_move_to_index, lv_tabview_set_tab_bar_size);
    
/* Reusing lv_obj_get_event_count for lv_tabview_get_tab_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_count_mpobj, 1, mp_lv_obj_get_event_count, lv_tabview_get_tab_count);
    
/* Reusing lv_obj_get_event_count for lv_tabview_get_tab_active */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_active_mpobj, 1, mp_lv_obj_get_event_count, lv_tabview_get_tab_active);
    
/* Reusing lv_obj_create for lv_tabview_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_content_mpobj, 1, mp_lv_obj_create, lv_tabview_get_content);
    
/* Reusing lv_obj_create for lv_tabview_get_tab_bar */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_bar_mpobj, 1, mp_lv_obj_create, lv_tabview_get_tab_bar);
    
/* Reusing lv_obj_create for lv_tabview_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_create_mpobj, 1, mp_lv_obj_create, lv_tabview_create);
    

/*
 * lvgl tabview object definitions
 */
    

STATIC const mp_rom_map_elem_t tabview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_tab), MP_ROM_PTR(&mp_lv_tabview_add_tab_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_rename_tab), MP_ROM_PTR(&mp_lv_tabview_rename_tab_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_active), MP_ROM_PTR(&mp_lv_tabview_set_active_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_tab_bar_position), MP_ROM_PTR(&mp_lv_tabview_set_tab_bar_position_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_tab_bar_size), MP_ROM_PTR(&mp_lv_tabview_set_tab_bar_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_count), MP_ROM_PTR(&mp_lv_tabview_get_tab_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_active), MP_ROM_PTR(&mp_lv_tabview_get_tab_active_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_tabview_get_content_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_bar), MP_ROM_PTR(&mp_lv_tabview_get_tab_bar_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(tabview_locals_dict, tabview_locals_dict_table);

STATIC void tabview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tabview");
}


STATIC mp_obj_t tabview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_tabview_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_tabview_type_base,
    MP_QSTR_tabview,
    MP_TYPE_FLAG_NONE,
    print, tabview_print,
    make_new, tabview_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &tabview_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_tabview_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_tabview_class,
#endif
    .mp_obj_type = &mp_lv_tabview_type_base,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_tileview_add_tile(lv_obj_t *tv, uint8_t col_id, uint8_t row_id, lv_dir_t dir)
 */

STATIC mp_obj_t mp_lv_tileview_add_tile(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    uint8_t col_id = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t row_id = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, uint8_t, uint8_t, lv_dir_t))lv_func_ptr)(tv, col_id, row_id, dir);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_add_tile_mpobj, 4, mp_lv_tileview_add_tile, lv_tileview_add_tile);
    

/*
 * lvgl extension definition for:
 * void lv_tileview_set_tile(lv_obj_t *tv, lv_obj_t *tile_obj, lv_anim_enable_t anim_en)
 */

STATIC mp_obj_t mp_lv_tileview_set_tile(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    lv_obj_t *tile_obj = mp_to_lv(mp_args[1]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(tv, tile_obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_tile_mpobj, 3, mp_lv_tileview_set_tile, lv_tileview_set_tile);
    

/*
 * lvgl extension definition for:
 * void lv_tileview_set_tile_by_index(lv_obj_t *tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en)
 */

STATIC mp_obj_t mp_lv_tileview_set_tile_by_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    uint32_t col_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t row_id = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, lv_anim_enable_t))lv_func_ptr)(tv, col_id, row_id, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_tile_by_index_mpobj, 4, mp_lv_tileview_set_tile_by_index, lv_tileview_set_tile_by_index);
    
/* Reusing lv_obj_create for lv_tileview_get_tile_active */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_get_tile_active_mpobj, 1, mp_lv_obj_create, lv_tileview_get_tile_active);
    
/* Reusing lv_obj_create for lv_tileview_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_create_mpobj, 1, mp_lv_obj_create, lv_tileview_create);
    

/*
 * lvgl tileview object definitions
 */
    

STATIC const mp_rom_map_elem_t tileview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_tile), MP_ROM_PTR(&mp_lv_tileview_add_tile_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_tile), MP_ROM_PTR(&mp_lv_tileview_set_tile_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_tile_by_index), MP_ROM_PTR(&mp_lv_tileview_set_tile_by_index_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_tile_active), MP_ROM_PTR(&mp_lv_tileview_get_tile_active_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(tileview_locals_dict, tileview_locals_dict_table);

STATIC void tileview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tileview");
}


STATIC mp_obj_t tileview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_tileview_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_tileview_type_base,
    MP_QSTR_tileview,
    MP_TYPE_FLAG_NONE,
    print, tileview_print,
    make_new, tileview_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &tileview_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_tileview_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_tileview_class,
#endif
    .mp_obj_type = &mp_lv_tileview_type_base,
};
    
/* Reusing lv_list_add_text for lv_win_add_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_title_mpobj, 2, mp_lv_list_add_text, lv_win_add_title);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_win_add_button(lv_obj_t *win, const void *icon, int32_t btn_w)
 */

STATIC mp_obj_t mp_lv_win_add_button(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *win = mp_to_lv(mp_args[0]);
    const void *icon = (const void *)mp_to_ptr(mp_args[1]);
    int32_t btn_w = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *, int32_t))lv_func_ptr)(win, icon, btn_w);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_button_mpobj, 3, mp_lv_win_add_button, lv_win_add_button);
    
/* Reusing lv_obj_create for lv_win_get_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_header_mpobj, 1, mp_lv_obj_create, lv_win_get_header);
    
/* Reusing lv_obj_create for lv_win_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_content_mpobj, 1, mp_lv_obj_create, lv_win_get_content);
    
/* Reusing lv_obj_create for lv_win_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_create_mpobj, 1, mp_lv_obj_create, lv_win_create);
    

/*
 * lvgl win object definitions
 */
    

STATIC const mp_rom_map_elem_t win_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_title), MP_ROM_PTR(&mp_lv_win_add_title_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_button), MP_ROM_PTR(&mp_lv_win_add_button_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_header), MP_ROM_PTR(&mp_lv_win_get_header_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_win_get_content_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(win_locals_dict, win_locals_dict_table);

STATIC void win_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl win");
}


STATIC mp_obj_t win_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_win_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_win_type_base,
    MP_QSTR_win,
    MP_TYPE_FLAG_NONE,
    print, win_print,
    make_new, win_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &win_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_win_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_win_class,
#endif
    .mp_obj_type = &mp_lv_win_type_base,
};
    
/* Reusing lv_led_set_color for lv_barcode_set_dark_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_set_dark_color_mpobj, 2, mp_lv_led_set_color, lv_barcode_set_dark_color);
    
/* Reusing lv_led_set_color for lv_barcode_set_light_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_set_light_color_mpobj, 2, mp_lv_led_set_color, lv_barcode_set_light_color);
    

/*
 * lvgl extension definition for:
 * void lv_barcode_set_scale(lv_obj_t *obj, uint16_t scale)
 */

STATIC mp_obj_t mp_lv_barcode_set_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t scale = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint16_t))lv_func_ptr)(obj, scale);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_set_scale_mpobj, 2, mp_lv_barcode_set_scale, lv_barcode_set_scale);
    
/* Reusing lv_obj_set_scroll_dir for lv_barcode_set_direction */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_set_direction_mpobj, 2, mp_lv_obj_set_scroll_dir, lv_barcode_set_direction);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_barcode_update(lv_obj_t *obj, const char *data)
 */

STATIC mp_obj_t mp_lv_barcode_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *data = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_obj_t *, const char *))lv_func_ptr)(obj, data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_update_mpobj, 2, mp_lv_barcode_update, lv_barcode_update);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_barcode_get_dark_color(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_barcode_get_dark_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_get_dark_color_mpobj, 1, mp_lv_barcode_get_dark_color, lv_barcode_get_dark_color);
    
/* Reusing lv_barcode_get_dark_color for lv_barcode_get_light_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_get_light_color_mpobj, 1, mp_lv_barcode_get_dark_color, lv_barcode_get_light_color);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_barcode_get_scale(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_barcode_get_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_get_scale_mpobj, 1, mp_lv_barcode_get_scale, lv_barcode_get_scale);
    
/* Reusing lv_obj_create for lv_barcode_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_barcode_create_mpobj, 1, mp_lv_obj_create, lv_barcode_create);
    

/*
 * lvgl barcode object definitions
 */
    

STATIC const mp_rom_map_elem_t barcode_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_dark_color), MP_ROM_PTR(&mp_lv_barcode_set_dark_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_light_color), MP_ROM_PTR(&mp_lv_barcode_set_light_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale), MP_ROM_PTR(&mp_lv_barcode_set_scale_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_direction), MP_ROM_PTR(&mp_lv_barcode_set_direction_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&mp_lv_barcode_update_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_dark_color), MP_ROM_PTR(&mp_lv_barcode_get_dark_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_light_color), MP_ROM_PTR(&mp_lv_barcode_get_light_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale), MP_ROM_PTR(&mp_lv_barcode_get_scale_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(barcode_locals_dict, barcode_locals_dict_table);

STATIC void barcode_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl barcode");
}


STATIC mp_obj_t barcode_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_barcode_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_barcode_type_base,
    MP_QSTR_barcode,
    MP_TYPE_FLAG_NONE,
    print, barcode_print,
    make_new, barcode_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &barcode_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_barcode_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_barcode_class,
#endif
    .mp_obj_type = &mp_lv_barcode_type_base,
};
    
/* Reusing lv_image_set_src for lv_gif_set_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_set_src_mpobj, 2, mp_lv_image_set_src, lv_gif_set_src);
    
/* Reusing lv_obj_center for lv_gif_restart */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_restart_mpobj, 1, mp_lv_obj_center, lv_gif_restart);
    
/* Reusing lv_obj_center for lv_gif_pause */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_pause_mpobj, 1, mp_lv_obj_center, lv_gif_pause);
    
/* Reusing lv_obj_center for lv_gif_resume */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_resume_mpobj, 1, mp_lv_obj_center, lv_gif_resume);
    
/* Reusing lv_obj_create for lv_gif_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_create_mpobj, 1, mp_lv_obj_create, lv_gif_create);
    

/*
 * lvgl gif object definitions
 */
    

STATIC const mp_rom_map_elem_t gif_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_gif_set_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_restart), MP_ROM_PTR(&mp_lv_gif_restart_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&mp_lv_gif_pause_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_resume), MP_ROM_PTR(&mp_lv_gif_resume_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(gif_locals_dict, gif_locals_dict_table);

STATIC void gif_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl gif");
}


STATIC mp_obj_t gif_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_gif_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_gif_type_base,
    MP_QSTR_gif,
    MP_TYPE_FLAG_NONE,
    print, gif_print,
    make_new, gif_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &gif_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_gif_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_gif_class,
#endif
    .mp_obj_type = &mp_lv_gif_type_base,
};
    
/* Reusing lv_obj_move_to_index for lv_qrcode_set_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_set_size_mpobj, 2, mp_lv_obj_move_to_index, lv_qrcode_set_size);
    
/* Reusing lv_led_set_color for lv_qrcode_set_dark_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_set_dark_color_mpobj, 2, mp_lv_led_set_color, lv_qrcode_set_dark_color);
    
/* Reusing lv_led_set_color for lv_qrcode_set_light_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_set_light_color_mpobj, 2, mp_lv_led_set_color, lv_qrcode_set_light_color);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_qrcode_update(lv_obj_t *obj, const void *data, uint32_t data_len)
 */

STATIC mp_obj_t mp_lv_qrcode_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *data = (const void *)mp_to_ptr(mp_args[1]);
    uint32_t data_len = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_obj_t *, const void *, uint32_t))lv_func_ptr)(obj, data, data_len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_update_mpobj, 3, mp_lv_qrcode_update, lv_qrcode_update);
    
/* Reusing lv_obj_create for lv_qrcode_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_create_mpobj, 1, mp_lv_obj_create, lv_qrcode_create);
    

/*
 * lvgl qrcode object definitions
 */
    

STATIC const mp_rom_map_elem_t qrcode_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_qrcode_set_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_dark_color), MP_ROM_PTR(&mp_lv_qrcode_set_dark_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_light_color), MP_ROM_PTR(&mp_lv_qrcode_set_light_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&mp_lv_qrcode_update_mpobj) }
};

STATIC MP_DEFINE_CONST_DICT(qrcode_locals_dict, qrcode_locals_dict_table);

STATIC void qrcode_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl qrcode");
}


STATIC mp_obj_t qrcode_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&mp_lv_qrcode_create_mpobj, type, n_args, n_kw, args);
}


STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_qrcode_type_base,
    MP_QSTR_qrcode,
    MP_TYPE_FLAG_NONE,
    print, qrcode_print,
    make_new, qrcode_make_new,
    binary_op, mp_lv_obj_binary_op,
    attr, call_parent_methods,
    buffer, mp_lv_obj_get_buffer,
    parent, &mp_lv_obj_type_base,
    locals_dict, &qrcode_locals_dict
);

GENMPY_UNUSED STATIC const mp_lv_obj_type_t mp_lv_qrcode_type = {
#ifdef LV_OBJ_T
    .lv_obj_class = &lv_qrcode_class,
#endif
    .mp_obj_type = &mp_lv_qrcode_type_base,
};
    

/*
 * lvgl lv_color_filter_shade global definitions
 */

STATIC const mp_lv_struct_t mp_lv_color_filter_shade = {
    { &mp_lv_color_filter_dsc_t_type },
    (lv_color_filter_dsc_t*)&lv_color_filter_shade
};
    

/*
 * lvgl lv_cache_class_lru_rb_count global definitions
 */

STATIC const mp_lv_struct_t mp_lv_cache_class_lru_rb_count = {
    { &mp_lv_cache_class_t_type },
    (lv_cache_class_t*)&lv_cache_class_lru_rb_count
};
    

/*
 * lvgl lv_cache_class_lru_rb_size global definitions
 */

STATIC const mp_lv_struct_t mp_lv_cache_class_lru_rb_size = {
    { &mp_lv_cache_class_t_type },
    (lv_cache_class_t*)&lv_cache_class_lru_rb_size
};
    

/*
 * lvgl lv_font_montserrat_14 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_14 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_14
};
    

/*
 * lvgl lv_font_montserrat_16 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_16 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_16
};
    

/*
 * lvgl lv_font_montserrat_24 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_24 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_24
};
    
/* Global struct wrapper for int */

typedef struct {
    int value;
} _lv_mp_int_wrapper;
        

/*
 * Struct _lv_mp_int_wrapper
 */

STATIC inline const mp_obj_type_t *get_mp__lv_mp_int_wrapper_type();

STATIC inline void* mp_write_ptr__lv_mp_int_wrapper(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_mp_int_wrapper_type()));
    return (_lv_mp_int_wrapper*)self->data;
}

#define mp_write__lv_mp_int_wrapper(struct_obj) *((_lv_mp_int_wrapper*)mp_write_ptr__lv_mp_int_wrapper(struct_obj))

STATIC inline mp_obj_t mp_read_ptr__lv_mp_int_wrapper(void *field)
{
    return lv_to_mp_struct(get_mp__lv_mp_int_wrapper_type(), field);
}

#define mp_read__lv_mp_int_wrapper(field) mp_read_ptr__lv_mp_int_wrapper(copy_buffer(&field, sizeof(_lv_mp_int_wrapper)))
#define mp_read_byref__lv_mp_int_wrapper(field) mp_read_ptr__lv_mp_int_wrapper(&field)

STATIC void mp__lv_mp_int_wrapper_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED _lv_mp_int_wrapper *data = (_lv_mp_int_wrapper*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_value: dest[0] = mp_obj_new_int(data->value); break; // converting from int;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_value: data->value = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_mp_int_wrapper_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_mp_int_wrapper");
}

STATIC const mp_obj_dict_t mp__lv_mp_int_wrapper_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp__lv_mp_int_wrapper_type,
    MP_QSTR__lv_mp_int_wrapper,
    MP_TYPE_FLAG_NONE,
    print, mp__lv_mp_int_wrapper_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp__lv_mp_int_wrapper_attr,
    locals_dict, &mp__lv_mp_int_wrapper_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp__lv_mp_int_wrapper_type()
{
    return &mp__lv_mp_int_wrapper_type;
}
    

/*
 * lvgl lv_style_const_prop_id_inv global definitions
 */

STATIC const mp_lv_struct_t mp_lv_style_const_prop_id_inv = {
    { &mp__lv_mp_int_wrapper_type },
    (lv_style_prop_t*)&lv_style_const_prop_id_inv
};
    

/*
 * lvgl lv_obj_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_obj_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_obj_class
};
    

/*
 * lvgl lv_image_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_image_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_image_class
};
    

/*
 * lvgl lv_animimg_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_animimg_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_animimg_class
};
    

/*
 * lvgl lv_arc_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_arc_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_arc_class
};
    

/*
 * lvgl lv_label_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_label_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_label_class
};
    

/*
 * lvgl lv_bar_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_bar_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_bar_class
};
    

/*
 * lvgl lv_button_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_button_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_button_class
};
    

/*
 * lvgl lv_buttonmatrix_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_buttonmatrix_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_buttonmatrix_class
};
    

/*
 * lvgl lv_calendar_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_class
};
    

/*
 * lvgl lv_calendar_header_arrow_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_header_arrow_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_header_arrow_class
};
    

/*
 * lvgl lv_calendar_header_dropdown_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_header_dropdown_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_header_dropdown_class
};
    

/*
 * lvgl lv_canvas_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_canvas_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_canvas_class
};
    

/*
 * lvgl lv_chart_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_chart_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_chart_class
};
    

/*
 * lvgl lv_checkbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_checkbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_checkbox_class
};
    

/*
 * lvgl lv_dropdown_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_dropdown_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_dropdown_class
};
    

/*
 * lvgl lv_dropdownlist_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_dropdownlist_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_dropdownlist_class
};
    

/*
 * lvgl lv_imagebutton_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_imagebutton_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_imagebutton_class
};
    

/*
 * lvgl lv_keyboard_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_keyboard_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_keyboard_class
};
    

/*
 * lvgl lv_led_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_led_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_led_class
};
    

/*
 * lvgl lv_line_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_line_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_line_class
};
    

/*
 * lvgl lv_list_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_class
};
    

/*
 * lvgl lv_list_text_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_text_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_text_class
};
    

/*
 * lvgl lv_list_button_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_button_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_button_class
};
    

/*
 * lvgl lv_menu_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_class
};
    

/*
 * lvgl lv_menu_page_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_page_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_page_class
};
    

/*
 * lvgl lv_menu_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_cont_class
};
    

/*
 * lvgl lv_menu_section_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_section_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_section_class
};
    

/*
 * lvgl lv_menu_separator_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_separator_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_separator_class
};
    

/*
 * lvgl lv_menu_sidebar_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_sidebar_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_sidebar_cont_class
};
    

/*
 * lvgl lv_menu_main_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_main_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_main_cont_class
};
    

/*
 * lvgl lv_menu_sidebar_header_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_sidebar_header_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_sidebar_header_cont_class
};
    

/*
 * lvgl lv_menu_main_header_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_main_header_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_main_header_cont_class
};
    

/*
 * lvgl lv_msgbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_class
};
    

/*
 * lvgl lv_msgbox_header_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_header_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_header_class
};
    

/*
 * lvgl lv_msgbox_content_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_content_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_content_class
};
    

/*
 * lvgl lv_msgbox_footer_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_footer_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_footer_class
};
    

/*
 * lvgl lv_msgbox_header_button_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_header_button_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_header_button_class
};
    

/*
 * lvgl lv_msgbox_footer_button_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_footer_button_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_footer_button_class
};
    

/*
 * lvgl lv_msgbox_backdrop_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_backdrop_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_backdrop_class
};
    

/*
 * lvgl lv_roller_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_roller_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_roller_class
};
    

/*
 * lvgl lv_scale_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_scale_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_scale_class
};
    

/*
 * lvgl lv_slider_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_slider_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_slider_class
};
    

/*
 * lvgl lv_spangroup_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spangroup_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spangroup_class
};
    

/*
 * lvgl lv_textarea_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_textarea_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_textarea_class
};
    

/*
 * lvgl lv_spinbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spinbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spinbox_class
};
    

/*
 * lvgl lv_spinner_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spinner_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spinner_class
};
    

/*
 * lvgl lv_switch_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_switch_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_switch_class
};
    

/*
 * lvgl lv_table_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_table_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_table_class
};
    

/*
 * lvgl lv_tabview_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tabview_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tabview_class
};
    

/*
 * lvgl lv_tileview_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tileview_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tileview_class
};
    

/*
 * lvgl lv_tileview_tile_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tileview_tile_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tileview_tile_class
};
    

/*
 * lvgl lv_win_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_win_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_win_class
};
    

/*
 * lvgl lv_barcode_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_barcode_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_barcode_class
};
    

/*
 * lvgl lv_gif_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_gif_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_gif_class
};
    

/*
 * lvgl lv_qrcode_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_qrcode_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_qrcode_class
};
    

/*
 * lvgl _nesting global definitions
 */

STATIC const mp_lv_struct_t mp__nesting = {
    { &mp__lv_mp_int_wrapper_type },
    (int*)&_nesting
};
    
#define funcptr_lv_timer_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_timer_cb_t(lv_timer_t *)
 */

STATIC mp_obj_t mp_funcptr_lv_timer_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_timer_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_timer_cb_t_mpobj, 1, mp_funcptr_lv_timer_cb_t, funcptr_lv_timer_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_timer_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_timer_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_timer_t_timer_cb_callback(lv_timer_t *);

/*
 * Struct lv_timer_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_timer_t_type();

STATIC inline void* mp_write_ptr_lv_timer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_timer_t_type()));
    return (lv_timer_t*)self->data;
}

#define mp_write_lv_timer_t(struct_obj) *((lv_timer_t*)mp_write_ptr_lv_timer_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_timer_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_timer_t_type(), field);
}

#define mp_read_lv_timer_t(field) mp_read_ptr_lv_timer_t(copy_buffer(&field, sizeof(lv_timer_t)))
#define mp_read_byref_lv_timer_t(field) mp_read_ptr_lv_timer_t(&field)

STATIC void mp_lv_timer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_timer_t *data = (lv_timer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_period: dest[0] = mp_obj_new_int_from_uint(data->period); break; // converting from uint32_t;
            case MP_QSTR_last_run: dest[0] = mp_obj_new_int_from_uint(data->last_run); break; // converting from uint32_t;
            case MP_QSTR_timer_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_timer_cb_t_mpobj, data->timer_cb, lv_timer_t_timer_cb_callback ,MP_QSTR_lv_timer_t_timer_cb, data->user_data); break; // converting from callback lv_timer_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_repeat_count: dest[0] = mp_obj_new_int(data->repeat_count); break; // converting from int32_t;
            case MP_QSTR_paused: dest[0] = mp_obj_new_int_from_uint(data->paused); break; // converting from uint32_t;
            case MP_QSTR_auto_delete: dest[0] = mp_obj_new_int_from_uint(data->auto_delete); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_period: data->period = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_run: data->last_run = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_timer_cb: data->timer_cb = mp_lv_callback(dest[1], lv_timer_t_timer_cb_callback ,MP_QSTR_lv_timer_t_timer_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_timer_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_repeat_count: data->repeat_count = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_paused: data->paused = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_auto_delete: data->auto_delete = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_timer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_timer_t");
}

STATIC const mp_obj_dict_t mp_lv_timer_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_timer_t_type,
    MP_QSTR_lv_timer_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_timer_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_timer_t_attr,
    locals_dict, &mp_lv_timer_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_timer_t_type()
{
    return &mp_lv_timer_t_type;
}
    

/*
 * Struct lv_array_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_array_t_type();

STATIC inline void* mp_write_ptr_lv_array_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_array_t_type()));
    return (lv_array_t*)self->data;
}

#define mp_write_lv_array_t(struct_obj) *((lv_array_t*)mp_write_ptr_lv_array_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_array_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_array_t_type(), field);
}

#define mp_read_lv_array_t(field) mp_read_ptr_lv_array_t(copy_buffer(&field, sizeof(lv_array_t)))
#define mp_read_byref_lv_array_t(field) mp_read_ptr_lv_array_t(&field)

STATIC void mp_lv_array_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_array_t *data = (lv_array_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_data: dest[0] = mp_array_from_u8ptr((void*)data->data); break; // converting from uint8_t *;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            case MP_QSTR_capacity: dest[0] = mp_obj_new_int_from_uint(data->capacity); break; // converting from uint32_t;
            case MP_QSTR_element_size: dest[0] = mp_obj_new_int_from_uint(data->element_size); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_data: data->data = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_capacity: data->capacity = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_element_size: data->element_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_array_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_array_t");
}

STATIC const mp_obj_dict_t mp_lv_array_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_array_t_type,
    MP_QSTR_lv_array_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_array_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_array_t_attr,
    locals_dict, &mp_lv_array_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_array_t_type()
{
    return &mp_lv_array_t_type;
}
    

/*
 * Struct lv_color16_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color16_t_type();

STATIC inline void* mp_write_ptr_lv_color16_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color16_t_type()));
    return (lv_color16_t*)self->data;
}

#define mp_write_lv_color16_t(struct_obj) *((lv_color16_t*)mp_write_ptr_lv_color16_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_color16_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_color16_t_type(), field);
}

#define mp_read_lv_color16_t(field) mp_read_ptr_lv_color16_t(copy_buffer(&field, sizeof(lv_color16_t)))
#define mp_read_byref_lv_color16_t(field) mp_read_ptr_lv_color16_t(&field)

STATIC void mp_lv_color16_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_color16_t *data = (lv_color16_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blue: dest[0] = mp_obj_new_int_from_uint(data->blue); break; // converting from uint16_t;
            case MP_QSTR_green: dest[0] = mp_obj_new_int_from_uint(data->green); break; // converting from uint16_t;
            case MP_QSTR_red: dest[0] = mp_obj_new_int_from_uint(data->red); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blue: data->blue = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_green: data->green = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_red: data->red = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color16_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color16_t");
}

STATIC const mp_obj_dict_t mp_lv_color16_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_color16_t_type,
    MP_QSTR_lv_color16_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_color16_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_color16_t_attr,
    locals_dict, &mp_lv_color16_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_color16_t_type()
{
    return &mp_lv_color16_t_type;
}
    

/*
 * Struct lv_mem_monitor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type();

STATIC inline void* mp_write_ptr_lv_mem_monitor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_mem_monitor_t_type()));
    return (lv_mem_monitor_t*)self->data;
}

#define mp_write_lv_mem_monitor_t(struct_obj) *((lv_mem_monitor_t*)mp_write_ptr_lv_mem_monitor_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_mem_monitor_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_mem_monitor_t_type(), field);
}

#define mp_read_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(copy_buffer(&field, sizeof(lv_mem_monitor_t)))
#define mp_read_byref_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(&field)

STATIC void mp_lv_mem_monitor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_mem_monitor_t *data = (lv_mem_monitor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_total_size: dest[0] = mp_obj_new_int_from_uint(data->total_size); break; // converting from uint32_t;
            case MP_QSTR_free_cnt: dest[0] = mp_obj_new_int_from_uint(data->free_cnt); break; // converting from uint32_t;
            case MP_QSTR_free_size: dest[0] = mp_obj_new_int_from_uint(data->free_size); break; // converting from uint32_t;
            case MP_QSTR_free_biggest_size: dest[0] = mp_obj_new_int_from_uint(data->free_biggest_size); break; // converting from uint32_t;
            case MP_QSTR_used_cnt: dest[0] = mp_obj_new_int_from_uint(data->used_cnt); break; // converting from uint32_t;
            case MP_QSTR_max_used: dest[0] = mp_obj_new_int_from_uint(data->max_used); break; // converting from uint32_t;
            case MP_QSTR_used_pct: dest[0] = mp_obj_new_int_from_uint(data->used_pct); break; // converting from uint8_t;
            case MP_QSTR_frag_pct: dest[0] = mp_obj_new_int_from_uint(data->frag_pct); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_total_size: data->total_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_cnt: data->free_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_size: data->free_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_biggest_size: data->free_biggest_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_cnt: data->used_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_max_used: data->max_used = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_pct: data->used_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_frag_pct: data->frag_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_mem_monitor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_mem_monitor_t");
}

STATIC const mp_obj_dict_t mp_lv_mem_monitor_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_mem_monitor_t_type,
    MP_QSTR_lv_mem_monitor_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_mem_monitor_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_mem_monitor_t_attr,
    locals_dict, &mp_lv_mem_monitor_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type()
{
    return &mp_lv_mem_monitor_t_type;
}
    
#define funcptr_lv_tick_get_cb_t NULL


/*
 * lvgl extension definition for:
 * uint32_t lv_tick_get_cb_t(void)
 */

STATIC mp_obj_t mp_funcptr_lv_tick_get_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint32_t _res = ((uint32_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_tick_get_cb_t_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, funcptr_lv_tick_get_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_tick_get_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_tick_get_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_lv_delay_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_delay_cb_t(uint32_t ms)
 */

STATIC mp_obj_t mp_funcptr_lv_delay_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t ms = (uint32_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(uint32_t))lv_func_ptr)(ms);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_delay_cb_t_mpobj, 1, mp_funcptr_lv_delay_cb_t, funcptr_lv_delay_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_delay_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_delay_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_lv_timer_handler_resume_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_timer_handler_resume_cb_t(void *data)
 */

STATIC mp_obj_t mp_funcptr_lv_timer_handler_resume_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *data = mp_to_ptr(mp_args[0]);
    ((void (*)(void *))lv_func_ptr)(data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_timer_handler_resume_cb_t_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, funcptr_lv_timer_handler_resume_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_timer_handler_resume_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_timer_handler_resume_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_lv_async_cb_t NULL

/* Reusing funcptr_lv_timer_handler_resume_cb_t for funcptr_lv_async_cb_t */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_async_cb_t_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, funcptr_lv_async_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_async_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_async_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Struct lv_anim_timeline_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_timeline_t_type();

STATIC inline void* mp_write_ptr_lv_anim_timeline_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_timeline_t_type()));
    return (lv_anim_timeline_t*)self->data;
}

#define mp_write_lv_anim_timeline_t(struct_obj) *((lv_anim_timeline_t*)mp_write_ptr_lv_anim_timeline_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_anim_timeline_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_timeline_t_type(), field);
}

#define mp_read_lv_anim_timeline_t(field) mp_read_ptr_lv_anim_timeline_t(copy_buffer(&field, sizeof(lv_anim_timeline_t)))
#define mp_read_byref_lv_anim_timeline_t(field) mp_read_ptr_lv_anim_timeline_t(&field)

STATIC void mp_lv_anim_timeline_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_anim_timeline_t *data = (lv_anim_timeline_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            ;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                ;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_timeline_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_timeline_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_timeline_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_anim_timeline_t_type,
    MP_QSTR_lv_anim_timeline_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_anim_timeline_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_anim_timeline_t_attr,
    locals_dict, &mp_lv_anim_timeline_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_anim_timeline_t_type()
{
    return &mp_lv_anim_timeline_t_type;
}
    

/*
 * Struct lv_rb_node_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_rb_node_t_type();

STATIC inline void* mp_write_ptr_lv_rb_node_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_rb_node_t_type()));
    return (lv_rb_node_t*)self->data;
}

#define mp_write_lv_rb_node_t(struct_obj) *((lv_rb_node_t*)mp_write_ptr_lv_rb_node_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_rb_node_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_rb_node_t_type(), field);
}

#define mp_read_lv_rb_node_t(field) mp_read_ptr_lv_rb_node_t(copy_buffer(&field, sizeof(lv_rb_node_t)))
#define mp_read_byref_lv_rb_node_t(field) mp_read_ptr_lv_rb_node_t(&field)

STATIC void mp_lv_rb_node_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_rb_node_t *data = (lv_rb_node_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_parent: dest[0] = ptr_to_mp((void*)data->parent); break; // converting from lv_rb_node_t *;
            case MP_QSTR_left: dest[0] = ptr_to_mp((void*)data->left); break; // converting from lv_rb_node_t *;
            case MP_QSTR_right: dest[0] = ptr_to_mp((void*)data->right); break; // converting from lv_rb_node_t *;
            case MP_QSTR_color: dest[0] = mp_obj_new_int(data->color); break; // converting from lv_rb_color_t;
            case MP_QSTR_data: dest[0] = ptr_to_mp((void*)data->data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_parent: data->parent = (void*)mp_to_ptr(dest[1]); break; // converting to lv_rb_node_t *;
                case MP_QSTR_left: data->left = (void*)mp_to_ptr(dest[1]); break; // converting to lv_rb_node_t *;
                case MP_QSTR_right: data->right = (void*)mp_to_ptr(dest[1]); break; // converting to lv_rb_node_t *;
                case MP_QSTR_color: data->color = (int)mp_obj_get_int(dest[1]); break; // converting to lv_rb_color_t;
                case MP_QSTR_data: data->data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_rb_node_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_rb_node_t");
}

STATIC const mp_obj_dict_t mp_lv_rb_node_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_rb_node_t_type,
    MP_QSTR_lv_rb_node_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_rb_node_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_rb_node_t_attr,
    locals_dict, &mp_lv_rb_node_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_rb_node_t_type()
{
    return &mp_lv_rb_node_t_type;
}
    
#define funcptr_lv_rb_compare_t NULL


/*
 * lvgl extension definition for:
 * lv_rb_compare_res_t lv_rb_compare_t(const void *a, const void *b)
 */

STATIC mp_obj_t mp_funcptr_lv_rb_compare_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *a = (const void *)mp_to_ptr(mp_args[0]);
    const void *b = (const void *)mp_to_ptr(mp_args[1]);
    lv_rb_compare_res_t _res = ((lv_rb_compare_res_t (*)(const void *, const void *))lv_func_ptr)(a, b);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_rb_compare_t_mpobj, 2, mp_funcptr_lv_rb_compare_t, funcptr_lv_rb_compare_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_rb_compare_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_rb_compare_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_rb_t_compare_callback'
 * lv_rb_compare_t compare
 */
    

/*
 * Struct lv_rb_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_rb_t_type();

STATIC inline void* mp_write_ptr_lv_rb_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_rb_t_type()));
    return (lv_rb_t*)self->data;
}

#define mp_write_lv_rb_t(struct_obj) *((lv_rb_t*)mp_write_ptr_lv_rb_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_rb_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_rb_t_type(), field);
}

#define mp_read_lv_rb_t(field) mp_read_ptr_lv_rb_t(copy_buffer(&field, sizeof(lv_rb_t)))
#define mp_read_byref_lv_rb_t(field) mp_read_ptr_lv_rb_t(&field)

STATIC void mp_lv_rb_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_rb_t *data = (lv_rb_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_root: dest[0] = mp_read_ptr_lv_rb_node_t((void*)data->root); break; // converting from lv_rb_node_t *;
            case MP_QSTR_compare: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_rb_compare_t_mpobj, data->compare, NULL ,MP_QSTR_lv_rb_t_compare, NULL); break; // converting from callback lv_rb_compare_t;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from size_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_root: data->root = (void*)mp_write_ptr_lv_rb_node_t(dest[1]); break; // converting to lv_rb_node_t *;
                case MP_QSTR_compare: data->compare = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_rb_t_compare, NULL, NULL, NULL, NULL); break; // converting to callback lv_rb_compare_t;
                case MP_QSTR_size: data->size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_rb_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_rb_t");
}

STATIC const mp_obj_dict_t mp_lv_rb_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_rb_t_type,
    MP_QSTR_lv_rb_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_rb_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_rb_t_attr,
    locals_dict, &mp_lv_rb_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_rb_t_type()
{
    return &mp_lv_rb_t_type;
}
    
#define funcptr_lv_layout_update_cb_t NULL

/* Reusing lv_obj_set_user_data for funcptr_lv_layout_update_cb_t */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_layout_update_cb_t_mpobj, 2, mp_lv_obj_set_user_data, funcptr_lv_layout_update_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_layout_update_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_layout_update_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_ready_cb NULL


/*
 * lvgl extension definition for:
 * bool ready_cb(lv_fs_drv_t *drv)
 */

STATIC mp_obj_t mp_funcptr_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(lv_fs_drv_t *))lv_func_ptr)(drv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_ready_cb_mpobj, 1, mp_funcptr_ready_cb, funcptr_ready_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_ready_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_ready_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_fs_drv_t_ready_cb_callback(lv_fs_drv_t *drv);
#define funcptr_open_cb NULL


/*
 * lvgl extension definition for:
 * void *open_cb(lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
 */

STATIC mp_obj_t mp_funcptr_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *path = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(lv_fs_drv_t *, const char *, lv_fs_mode_t))lv_func_ptr)(drv, path, mode);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_open_cb_mpobj, 3, mp_funcptr_open_cb, funcptr_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_open_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void * lv_fs_drv_t_open_cb_callback(lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode);
#define funcptr_close_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t close_cb(lv_fs_drv_t *drv, void *file_p)
 */

STATIC mp_obj_t mp_funcptr_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *))lv_func_ptr)(drv, file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_close_cb_mpobj, 2, mp_funcptr_close_cb, funcptr_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_close_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(lv_fs_drv_t *drv, void *file_p);
#define funcptr_read_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t read_cb(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */

STATIC mp_obj_t mp_funcptr_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    void *buf = mp_to_ptr(mp_args[2]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *br = mp_array_to_u32ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *, void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_read_cb_mpobj, 5, mp_funcptr_read_cb, funcptr_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_read_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
#define funcptr_write_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t write_cb(lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */

STATIC mp_obj_t mp_funcptr_write_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    const void *buf = (const void *)mp_to_ptr(mp_args[2]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *bw = mp_array_to_u32ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *, const void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_write_cb_mpobj, 5, mp_funcptr_write_cb, funcptr_write_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_write_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_write_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw);
#define funcptr_seek_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t seek_cb(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
 */

STATIC mp_obj_t mp_funcptr_seek_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_fs_whence_t whence = (int)mp_obj_get_int(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *, uint32_t, lv_fs_whence_t))lv_func_ptr)(drv, file_p, pos, whence);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_seek_cb_mpobj, 4, mp_funcptr_seek_cb, funcptr_seek_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_seek_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_seek_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
#define funcptr_tell_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t tell_cb(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */

STATIC mp_obj_t mp_funcptr_tell_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t *pos_p = mp_array_to_u32ptr(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *, uint32_t *))lv_func_ptr)(drv, file_p, pos_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_tell_cb_mpobj, 3, mp_funcptr_tell_cb, funcptr_tell_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_tell_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_tell_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
#define funcptr_dir_open_cb NULL


/*
 * lvgl extension definition for:
 * void *dir_open_cb(lv_fs_drv_t *drv, const char *path)
 */

STATIC mp_obj_t mp_funcptr_dir_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *path = (const char *)(char*)convert_from_str(mp_args[1]);
    void * _res = ((void *(*)(lv_fs_drv_t *, const char *))lv_func_ptr)(drv, path);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_open_cb_mpobj, 2, mp_funcptr_dir_open_cb, funcptr_dir_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_open_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void * lv_fs_drv_t_dir_open_cb_callback(lv_fs_drv_t *drv, const char *path);
#define funcptr_dir_read_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t dir_read_cb(lv_fs_drv_t *drv, void *rddir_p, char *fn, uint32_t fn_len)
 */

STATIC mp_obj_t mp_funcptr_dir_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *rddir_p = mp_to_ptr(mp_args[1]);
    char *fn = (char*)convert_from_str(mp_args[2]);
    uint32_t fn_len = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_drv_t *, void *, char *, uint32_t))lv_func_ptr)(drv, rddir_p, fn, fn_len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_read_cb_mpobj, 4, mp_funcptr_dir_read_cb, funcptr_dir_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_read_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(lv_fs_drv_t *drv, void *rddir_p, char *fn, uint32_t fn_len);
#define funcptr_dir_close_cb NULL

/* Reusing funcptr_close_cb for funcptr_dir_close_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_close_cb_mpobj, 2, mp_funcptr_close_cb, funcptr_dir_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_close_cb_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(lv_fs_drv_t *drv, void *rddir_p);

/*
 * Struct lv_fs_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type();

STATIC inline void* mp_write_ptr_lv_fs_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_drv_t_type()));
    return (lv_fs_drv_t*)self->data;
}

#define mp_write_lv_fs_drv_t(struct_obj) *((lv_fs_drv_t*)mp_write_ptr_lv_fs_drv_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_fs_drv_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_drv_t_type(), field);
}

#define mp_read_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(copy_buffer(&field, sizeof(lv_fs_drv_t)))
#define mp_read_byref_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(&field)

STATIC void mp_lv_fs_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_fs_drv_t *data = (lv_fs_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_letter: dest[0] = mp_obj_new_int(data->letter); break; // converting from char;
            case MP_QSTR_cache_size: dest[0] = mp_obj_new_int_from_uint(data->cache_size); break; // converting from uint32_t;
            case MP_QSTR_ready_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_ready_cb_mpobj, (void*)data->ready_cb, lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, data->user_data); break; // converting from callback bool (*)(lv_fs_drv_t *drv);
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_open_cb_mpobj, (void*)data->open_cb, lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, data->user_data); break; // converting from callback void *(*)(lv_fs_drv_t *drv, char *path, lv_fs_mode_t mode);
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_close_cb_mpobj, (void*)data->close_cb, lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
            case MP_QSTR_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_read_cb_mpobj, (void*)data->read_cb, lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
            case MP_QSTR_write_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_write_cb_mpobj, (void*)data->write_cb, lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
            case MP_QSTR_seek_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_seek_cb_mpobj, (void*)data->seek_cb, lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
            case MP_QSTR_tell_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_tell_cb_mpobj, (void*)data->tell_cb, lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
            case MP_QSTR_dir_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_open_cb_mpobj, (void*)data->dir_open_cb, lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, data->user_data); break; // converting from callback void *(*)(lv_fs_drv_t *drv, char *path);
            case MP_QSTR_dir_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_read_cb_mpobj, (void*)data->dir_read_cb, lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn, uint32_t fn_len);
            case MP_QSTR_dir_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_close_cb_mpobj, (void*)data->dir_close_cb, lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_letter: data->letter = (char)mp_obj_get_int(dest[1]); break; // converting to char;
                case MP_QSTR_cache_size: data->cache_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_ready_cb: data->ready_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback bool (*)(lv_fs_drv_t *drv);
                case MP_QSTR_open_cb: data->open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback void *(*)(lv_fs_drv_t *drv, char *path, lv_fs_mode_t mode);
                case MP_QSTR_close_cb: data->close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
                case MP_QSTR_read_cb: data->read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
                case MP_QSTR_write_cb: data->write_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
                case MP_QSTR_seek_cb: data->seek_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
                case MP_QSTR_tell_cb: data->tell_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
                case MP_QSTR_dir_open_cb: data->dir_open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback void *(*)(lv_fs_drv_t *drv, char *path);
                case MP_QSTR_dir_read_cb: data->dir_read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn, uint32_t fn_len);
                case MP_QSTR_dir_close_cb: data->dir_close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_drv_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_fs_drv_t_type,
    MP_QSTR_lv_fs_drv_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_fs_drv_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_fs_drv_t_attr,
    locals_dict, &mp_lv_fs_drv_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type()
{
    return &mp_lv_fs_drv_t_type;
}
    

/*
 * Struct lv_fs_file_cache_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_cache_t_type();

STATIC inline void* mp_write_ptr_lv_fs_file_cache_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_file_cache_t_type()));
    return (lv_fs_file_cache_t*)self->data;
}

#define mp_write_lv_fs_file_cache_t(struct_obj) *((lv_fs_file_cache_t*)mp_write_ptr_lv_fs_file_cache_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_fs_file_cache_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_file_cache_t_type(), field);
}

#define mp_read_lv_fs_file_cache_t(field) mp_read_ptr_lv_fs_file_cache_t(copy_buffer(&field, sizeof(lv_fs_file_cache_t)))
#define mp_read_byref_lv_fs_file_cache_t(field) mp_read_ptr_lv_fs_file_cache_t(&field)

STATIC void mp_lv_fs_file_cache_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_fs_file_cache_t *data = (lv_fs_file_cache_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_start: dest[0] = mp_obj_new_int_from_uint(data->start); break; // converting from uint32_t;
            case MP_QSTR_end: dest[0] = mp_obj_new_int_from_uint(data->end); break; // converting from uint32_t;
            case MP_QSTR_file_position: dest[0] = mp_obj_new_int_from_uint(data->file_position); break; // converting from uint32_t;
            case MP_QSTR_buffer: dest[0] = ptr_to_mp((void*)data->buffer); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_start: data->start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_end: data->end = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_file_position: data->file_position = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_buffer: data->buffer = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_file_cache_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_file_cache_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_file_cache_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_fs_file_cache_t_type,
    MP_QSTR_lv_fs_file_cache_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_fs_file_cache_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_fs_file_cache_t_attr,
    locals_dict, &mp_lv_fs_file_cache_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_cache_t_type()
{
    return &mp_lv_fs_file_cache_t_type;
}
    

/*
 * Struct lv_fs_file_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type();

STATIC inline void* mp_write_ptr_lv_fs_file_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_file_t_type()));
    return (lv_fs_file_t*)self->data;
}

#define mp_write_lv_fs_file_t(struct_obj) *((lv_fs_file_t*)mp_write_ptr_lv_fs_file_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_fs_file_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_file_t_type(), field);
}

#define mp_read_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(copy_buffer(&field, sizeof(lv_fs_file_t)))
#define mp_read_byref_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(&field)

STATIC void mp_lv_fs_file_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_fs_file_t *data = (lv_fs_file_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_file_d: dest[0] = ptr_to_mp((void*)data->file_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            case MP_QSTR_cache: dest[0] = mp_read_ptr_lv_fs_file_cache_t((void*)data->cache); break; // converting from lv_fs_file_cache_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_file_d: data->file_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                case MP_QSTR_cache: data->cache = (void*)mp_write_ptr_lv_fs_file_cache_t(dest[1]); break; // converting to lv_fs_file_cache_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_file_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_file_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_file_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_fs_file_t_type,
    MP_QSTR_lv_fs_file_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_fs_file_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_fs_file_t_attr,
    locals_dict, &mp_lv_fs_file_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type()
{
    return &mp_lv_fs_file_t_type;
}
    

/*
 * Array convertors for char [4]
 */

GENMPY_UNUSED STATIC char *mp_arr_to_char___4__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_char___4__(char *arr)
{
    mp_obj_t obj_arr[4];
    for (size_t i=0; i<4; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(4, obj_arr); // TODO: return custom iterable object!
}


/*
 * Struct lv_fs_path_ex_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_path_ex_t_type();

STATIC inline void* mp_write_ptr_lv_fs_path_ex_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_path_ex_t_type()));
    return (lv_fs_path_ex_t*)self->data;
}

#define mp_write_lv_fs_path_ex_t(struct_obj) *((lv_fs_path_ex_t*)mp_write_ptr_lv_fs_path_ex_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_fs_path_ex_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_path_ex_t_type(), field);
}

#define mp_read_lv_fs_path_ex_t(field) mp_read_ptr_lv_fs_path_ex_t(copy_buffer(&field, sizeof(lv_fs_path_ex_t)))
#define mp_read_byref_lv_fs_path_ex_t(field) mp_read_ptr_lv_fs_path_ex_t(&field)

STATIC void mp_lv_fs_path_ex_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_fs_path_ex_t *data = (lv_fs_path_ex_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_path: dest[0] = mp_arr_from_char___4__(data->path); break; // converting from char [4];
            case MP_QSTR_buffer: dest[0] = ptr_to_mp((void*)data->buffer); break; // converting from void *;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_path: memcpy((void*)&data->path, mp_arr_to_char___4__(dest[1]), sizeof(char)*4); break; // converting to char [4];
                case MP_QSTR_buffer: data->buffer = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_path_ex_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_path_ex_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_path_ex_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_fs_path_ex_t_type,
    MP_QSTR_lv_fs_path_ex_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_fs_path_ex_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_fs_path_ex_t_attr,
    locals_dict, &mp_lv_fs_path_ex_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_fs_path_ex_t_type()
{
    return &mp_lv_fs_path_ex_t_type;
}
    

/*
 * Struct lv_fs_dir_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type();

STATIC inline void* mp_write_ptr_lv_fs_dir_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_dir_t_type()));
    return (lv_fs_dir_t*)self->data;
}

#define mp_write_lv_fs_dir_t(struct_obj) *((lv_fs_dir_t*)mp_write_ptr_lv_fs_dir_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_fs_dir_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_dir_t_type(), field);
}

#define mp_read_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(copy_buffer(&field, sizeof(lv_fs_dir_t)))
#define mp_read_byref_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(&field)

STATIC void mp_lv_fs_dir_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_fs_dir_t *data = (lv_fs_dir_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dir_d: dest[0] = ptr_to_mp((void*)data->dir_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dir_d: data->dir_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_dir_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_dir_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_dir_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_fs_dir_t_type,
    MP_QSTR_lv_fs_dir_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_fs_dir_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_fs_dir_t_attr,
    locals_dict, &mp_lv_fs_dir_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type()
{
    return &mp_lv_fs_dir_t_type;
}
    

/*
 * Struct lv_grad_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_grad_t_type();

STATIC inline void* mp_write_ptr_lv_grad_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_grad_t_type()));
    return (lv_grad_t*)self->data;
}

#define mp_write_lv_grad_t(struct_obj) *((lv_grad_t*)mp_write_ptr_lv_grad_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_grad_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_grad_t_type(), field);
}

#define mp_read_lv_grad_t(field) mp_read_ptr_lv_grad_t(copy_buffer(&field, sizeof(lv_grad_t)))
#define mp_read_byref_lv_grad_t(field) mp_read_ptr_lv_grad_t(&field)

STATIC void mp_lv_grad_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_grad_t *data = (lv_grad_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color_map: dest[0] = mp_read_ptr_lv_color_t((void*)data->color_map); break; // converting from lv_color_t *;
            case MP_QSTR_opa_map: dest[0] = mp_array_from_u8ptr((void*)data->opa_map); break; // converting from lv_opa_t *;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color_map: data->color_map = (void*)mp_write_ptr_lv_color_t(dest[1]); break; // converting to lv_color_t *;
                case MP_QSTR_opa_map: data->opa_map = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to lv_opa_t *;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_grad_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_grad_t");
}

STATIC const mp_obj_dict_t mp_lv_grad_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_grad_t_type,
    MP_QSTR_lv_grad_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_grad_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_grad_t_attr,
    locals_dict, &mp_lv_grad_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_grad_t_type()
{
    return &mp_lv_grad_t_type;
}
    

/*
 * Struct lv_draw_fill_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_fill_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_fill_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_fill_dsc_t_type()));
    return (lv_draw_fill_dsc_t*)self->data;
}

#define mp_write_lv_draw_fill_dsc_t(struct_obj) *((lv_draw_fill_dsc_t*)mp_write_ptr_lv_draw_fill_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_fill_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_fill_dsc_t_type(), field);
}

#define mp_read_lv_draw_fill_dsc_t(field) mp_read_ptr_lv_draw_fill_dsc_t(copy_buffer(&field, sizeof(lv_draw_fill_dsc_t)))
#define mp_read_byref_lv_draw_fill_dsc_t(field) mp_read_ptr_lv_draw_fill_dsc_t(&field)

STATIC void mp_lv_draw_fill_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_fill_dsc_t *data = (lv_draw_fill_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_grad: dest[0] = mp_read_byref_lv_grad_dsc_t(data->grad); break; // converting from lv_grad_dsc_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_grad: data->grad = mp_write_lv_grad_dsc_t(dest[1]); break; // converting to lv_grad_dsc_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_fill_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_fill_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_fill_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_fill_dsc_t_type,
    MP_QSTR_lv_draw_fill_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_fill_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_fill_dsc_t_attr,
    locals_dict, &mp_lv_draw_fill_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_fill_dsc_t_type()
{
    return &mp_lv_draw_fill_dsc_t_type;
}
    

/*
 * Struct lv_draw_border_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_border_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_border_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_border_dsc_t_type()));
    return (lv_draw_border_dsc_t*)self->data;
}

#define mp_write_lv_draw_border_dsc_t(struct_obj) *((lv_draw_border_dsc_t*)mp_write_ptr_lv_draw_border_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_border_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_border_dsc_t_type(), field);
}

#define mp_read_lv_draw_border_dsc_t(field) mp_read_ptr_lv_draw_border_dsc_t(copy_buffer(&field, sizeof(lv_draw_border_dsc_t)))
#define mp_read_byref_lv_draw_border_dsc_t(field) mp_read_ptr_lv_draw_border_dsc_t(&field)

STATIC void mp_lv_draw_border_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_border_dsc_t *data = (lv_draw_border_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from int32_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_side: dest[0] = mp_obj_new_int_from_uint(data->side); break; // converting from lv_border_side_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_side: data->side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_border_side_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_border_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_border_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_border_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_border_dsc_t_type,
    MP_QSTR_lv_draw_border_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_border_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_border_dsc_t_attr,
    locals_dict, &mp_lv_draw_border_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_border_dsc_t_type()
{
    return &mp_lv_draw_border_dsc_t_type;
}
    

/*
 * Struct lv_draw_box_shadow_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_box_shadow_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_box_shadow_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_box_shadow_dsc_t_type()));
    return (lv_draw_box_shadow_dsc_t*)self->data;
}

#define mp_write_lv_draw_box_shadow_dsc_t(struct_obj) *((lv_draw_box_shadow_dsc_t*)mp_write_ptr_lv_draw_box_shadow_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_box_shadow_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_box_shadow_dsc_t_type(), field);
}

#define mp_read_lv_draw_box_shadow_dsc_t(field) mp_read_ptr_lv_draw_box_shadow_dsc_t(copy_buffer(&field, sizeof(lv_draw_box_shadow_dsc_t)))
#define mp_read_byref_lv_draw_box_shadow_dsc_t(field) mp_read_ptr_lv_draw_box_shadow_dsc_t(&field)

STATIC void mp_lv_draw_box_shadow_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_box_shadow_dsc_t *data = (lv_draw_box_shadow_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from int32_t;
            case MP_QSTR_spread: dest[0] = mp_obj_new_int(data->spread); break; // converting from int32_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from int32_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from int32_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_cover: dest[0] = mp_obj_new_int_from_uint(data->bg_cover); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_spread: data->spread = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_cover: data->bg_cover = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_box_shadow_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_box_shadow_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_box_shadow_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_box_shadow_dsc_t_type,
    MP_QSTR_lv_draw_box_shadow_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_box_shadow_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_box_shadow_dsc_t_attr,
    locals_dict, &mp_lv_draw_box_shadow_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_box_shadow_dsc_t_type()
{
    return &mp_lv_draw_box_shadow_dsc_t_type;
}
    

/*
 * Struct lv_draw_glyph_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_glyph_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_glyph_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_glyph_dsc_t_type()));
    return (lv_draw_glyph_dsc_t*)self->data;
}

#define mp_write_lv_draw_glyph_dsc_t(struct_obj) *((lv_draw_glyph_dsc_t*)mp_write_ptr_lv_draw_glyph_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_glyph_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_glyph_dsc_t_type(), field);
}

#define mp_read_lv_draw_glyph_dsc_t(field) mp_read_ptr_lv_draw_glyph_dsc_t(copy_buffer(&field, sizeof(lv_draw_glyph_dsc_t)))
#define mp_read_byref_lv_draw_glyph_dsc_t(field) mp_read_ptr_lv_draw_glyph_dsc_t(&field)

STATIC void mp_lv_draw_glyph_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_glyph_dsc_t *data = (lv_draw_glyph_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_glyph_data: dest[0] = ptr_to_mp((void*)data->glyph_data); break; // converting from void *;
            case MP_QSTR_format: dest[0] = mp_obj_new_int(data->format); break; // converting from lv_draw_glyph_bitmap_format_t;
            case MP_QSTR_letter_coords: dest[0] = mp_read_ptr_lv_area_t((void*)data->letter_coords); break; // converting from lv_area_t *;
            case MP_QSTR_bg_coords: dest[0] = mp_read_ptr_lv_area_t((void*)data->bg_coords); break; // converting from lv_area_t *;
            case MP_QSTR_g: dest[0] = mp_read_ptr_lv_font_glyph_dsc_t((void*)data->g); break; // converting from lv_font_glyph_dsc_t *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR__draw_buf: dest[0] = mp_read_ptr_lv_draw_buf_t((void*)data->_draw_buf); break; // converting from lv_draw_buf_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_glyph_data: data->glyph_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_format: data->format = (int)mp_obj_get_int(dest[1]); break; // converting to lv_draw_glyph_bitmap_format_t;
                case MP_QSTR_letter_coords: data->letter_coords = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_bg_coords: data->bg_coords = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_g: data->g = (void*)mp_write_ptr_lv_font_glyph_dsc_t(dest[1]); break; // converting to lv_font_glyph_dsc_t *;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR__draw_buf: data->_draw_buf = (void*)mp_write_ptr_lv_draw_buf_t(dest[1]); break; // converting to lv_draw_buf_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_glyph_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_glyph_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_glyph_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_glyph_dsc_t_type,
    MP_QSTR_lv_draw_glyph_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_glyph_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_glyph_dsc_t_attr,
    locals_dict, &mp_lv_draw_glyph_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_glyph_dsc_t_type()
{
    return &mp_lv_draw_glyph_dsc_t_type;
}
    
#define funcptr_dispatch_cb NULL


/*
 * lvgl extension definition for:
 * int32_t dispatch_cb(lv_draw_unit_t *draw_unit, lv_layer_t *layer)
 */

STATIC mp_obj_t mp_funcptr_dispatch_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_to_ptr(mp_args[0]);
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_draw_unit_t *, lv_layer_t *))lv_func_ptr)(draw_unit, layer);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dispatch_cb_mpobj, 2, mp_funcptr_dispatch_cb, funcptr_dispatch_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dispatch_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dispatch_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_unit_t_dispatch_cb_callback'
 * int32_t (*dispatch_cb)(lv_draw_unit_t *draw_unit, lv_layer_t *layer)
 */
    
#define funcptr_evaluate_cb NULL


/*
 * lvgl extension definition for:
 * int32_t evaluate_cb(lv_draw_unit_t *draw_unit, lv_draw_task_t *task)
 */

STATIC mp_obj_t mp_funcptr_evaluate_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_to_ptr(mp_args[0]);
    lv_draw_task_t *task = mp_write_ptr_lv_draw_task_t(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_draw_unit_t *, lv_draw_task_t *))lv_func_ptr)(draw_unit, task);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_evaluate_cb_mpobj, 2, mp_funcptr_evaluate_cb, funcptr_evaluate_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_evaluate_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_evaluate_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_unit_t_evaluate_cb_callback'
 * int32_t (*evaluate_cb)(lv_draw_unit_t *draw_unit, lv_draw_task_t *task)
 */
    
#define funcptr_delete_cb NULL


/*
 * lvgl extension definition for:
 * int32_t delete_cb(lv_draw_unit_t *draw_unit)
 */

STATIC mp_obj_t mp_funcptr_delete_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_to_ptr(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_draw_unit_t *))lv_func_ptr)(draw_unit);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_delete_cb_mpobj, 1, mp_funcptr_delete_cb, funcptr_delete_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_delete_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_delete_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_unit_t_delete_cb_callback'
 * int32_t (*delete_cb)(lv_draw_unit_t *draw_unit)
 */
    

/*
 * Struct lv_draw_unit_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_unit_t_type();

STATIC inline void* mp_write_ptr_lv_draw_unit_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_unit_t_type()));
    return (lv_draw_unit_t*)self->data;
}

#define mp_write_lv_draw_unit_t(struct_obj) *((lv_draw_unit_t*)mp_write_ptr_lv_draw_unit_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_unit_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_unit_t_type(), field);
}

#define mp_read_lv_draw_unit_t(field) mp_read_ptr_lv_draw_unit_t(copy_buffer(&field, sizeof(lv_draw_unit_t)))
#define mp_read_byref_lv_draw_unit_t(field) mp_read_ptr_lv_draw_unit_t(&field)

STATIC void mp_lv_draw_unit_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_unit_t *data = (lv_draw_unit_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_next: dest[0] = ptr_to_mp((void*)data->next); break; // converting from lv_draw_unit_t *;
            case MP_QSTR_target_layer: dest[0] = mp_read_ptr_lv_layer_t((void*)data->target_layer); break; // converting from lv_layer_t *;
            case MP_QSTR_clip_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->clip_area); break; // converting from lv_area_t *;
            case MP_QSTR_dispatch_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dispatch_cb_mpobj, (void*)data->dispatch_cb, NULL ,MP_QSTR_lv_draw_unit_t_dispatch_cb, NULL); break; // converting from callback int32_t (*)(lv_draw_unit_t *draw_unit, lv_layer_t *layer);
            case MP_QSTR_evaluate_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_evaluate_cb_mpobj, (void*)data->evaluate_cb, NULL ,MP_QSTR_lv_draw_unit_t_evaluate_cb, NULL); break; // converting from callback int32_t (*)(lv_draw_unit_t *draw_unit, lv_draw_task_t *task);
            case MP_QSTR_delete_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_delete_cb_mpobj, (void*)data->delete_cb, NULL ,MP_QSTR_lv_draw_unit_t_delete_cb, NULL); break; // converting from callback int32_t (*)(lv_draw_unit_t *draw_unit);
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_next: data->next = (void*)mp_to_ptr(dest[1]); break; // converting to lv_draw_unit_t *;
                case MP_QSTR_target_layer: data->target_layer = (void*)mp_write_ptr_lv_layer_t(dest[1]); break; // converting to lv_layer_t *;
                case MP_QSTR_clip_area: data->clip_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_dispatch_cb: data->dispatch_cb = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_unit_t_dispatch_cb, NULL, NULL, NULL, NULL); break; // converting to callback int32_t (*)(lv_draw_unit_t *draw_unit, lv_layer_t *layer);
                case MP_QSTR_evaluate_cb: data->evaluate_cb = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_unit_t_evaluate_cb, NULL, NULL, NULL, NULL); break; // converting to callback int32_t (*)(lv_draw_unit_t *draw_unit, lv_draw_task_t *task);
                case MP_QSTR_delete_cb: data->delete_cb = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_unit_t_delete_cb, NULL, NULL, NULL, NULL); break; // converting to callback int32_t (*)(lv_draw_unit_t *draw_unit);
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_unit_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_unit_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_unit_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_unit_t_type,
    MP_QSTR_lv_draw_unit_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_unit_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_unit_t_attr,
    locals_dict, &mp_lv_draw_unit_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_unit_t_type()
{
    return &mp_lv_draw_unit_t_type;
}
    

/*
 * Array convertors for lv_point_precise_t [3]
 */

GENMPY_UNUSED STATIC lv_point_precise_t *mp_arr_to_lv_point_precise_t___3__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    lv_point_precise_t *lv_arr = (lv_point_precise_t*)m_malloc(len * sizeof(lv_point_precise_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_point_precise_t(item);
    }
    return (lv_point_precise_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_point_precise_t___3__(lv_point_precise_t *arr)
{
    mp_obj_t obj_arr[3];
    for (size_t i=0; i<3; i++){
        obj_arr[i] = mp_read_lv_point_precise_t(arr[i]);
    }
    return mp_obj_new_list(3, obj_arr); // TODO: return custom iterable object!
}


/*
 * Struct lv_draw_triangle_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_triangle_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_triangle_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_triangle_dsc_t_type()));
    return (lv_draw_triangle_dsc_t*)self->data;
}

#define mp_write_lv_draw_triangle_dsc_t(struct_obj) *((lv_draw_triangle_dsc_t*)mp_write_ptr_lv_draw_triangle_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_triangle_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_triangle_dsc_t_type(), field);
}

#define mp_read_lv_draw_triangle_dsc_t(field) mp_read_ptr_lv_draw_triangle_dsc_t(copy_buffer(&field, sizeof(lv_draw_triangle_dsc_t)))
#define mp_read_byref_lv_draw_triangle_dsc_t(field) mp_read_ptr_lv_draw_triangle_dsc_t(&field)

STATIC void mp_lv_draw_triangle_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_triangle_dsc_t *data = (lv_draw_triangle_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_grad: dest[0] = mp_read_byref_lv_grad_dsc_t(data->bg_grad); break; // converting from lv_grad_dsc_t;
            case MP_QSTR_p: dest[0] = mp_arr_from_lv_point_precise_t___3__(data->p); break; // converting from lv_point_precise_t [3];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_grad: data->bg_grad = mp_write_lv_grad_dsc_t(dest[1]); break; // converting to lv_grad_dsc_t;
                case MP_QSTR_p: memcpy((void*)&data->p, mp_arr_to_lv_point_precise_t___3__(dest[1]), sizeof(lv_point_precise_t)*3); break; // converting to lv_point_precise_t [3];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_triangle_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_triangle_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_triangle_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_triangle_dsc_t_type,
    MP_QSTR_lv_draw_triangle_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_triangle_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_triangle_dsc_t_attr,
    locals_dict, &mp_lv_draw_triangle_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_triangle_dsc_t_type()
{
    return &mp_lv_draw_triangle_dsc_t_type;
}
    

/*
 * Struct lv_draw_mask_rect_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_rect_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_mask_rect_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_rect_dsc_t_type()));
    return (lv_draw_mask_rect_dsc_t*)self->data;
}

#define mp_write_lv_draw_mask_rect_dsc_t(struct_obj) *((lv_draw_mask_rect_dsc_t*)mp_write_ptr_lv_draw_mask_rect_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_rect_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_rect_dsc_t_type(), field);
}

#define mp_read_lv_draw_mask_rect_dsc_t(field) mp_read_ptr_lv_draw_mask_rect_dsc_t(copy_buffer(&field, sizeof(lv_draw_mask_rect_dsc_t)))
#define mp_read_byref_lv_draw_mask_rect_dsc_t(field) mp_read_ptr_lv_draw_mask_rect_dsc_t(&field)

STATIC void mp_lv_draw_mask_rect_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_mask_rect_dsc_t *data = (lv_draw_mask_rect_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base: dest[0] = mp_read_byref_lv_draw_dsc_base_t(data->base); break; // converting from lv_draw_dsc_base_t;
            case MP_QSTR_area: dest[0] = mp_read_byref_lv_area_t(data->area); break; // converting from lv_area_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base: data->base = mp_write_lv_draw_dsc_base_t(dest[1]); break; // converting to lv_draw_dsc_base_t;
                case MP_QSTR_area: data->area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_rect_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_rect_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_rect_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_mask_rect_dsc_t_type,
    MP_QSTR_lv_draw_mask_rect_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_mask_rect_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_mask_rect_dsc_t_attr,
    locals_dict, &mp_lv_draw_mask_rect_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_rect_dsc_t_type()
{
    return &mp_lv_draw_mask_rect_dsc_t_type;
}
    

/*
 * Struct lv_indev_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type();

STATIC inline void* mp_write_ptr_lv_indev_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_t_type()));
    return (lv_indev_t*)self->data;
}

#define mp_write_lv_indev_t(struct_obj) *((lv_indev_t*)mp_write_ptr_lv_indev_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_indev_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_t_type(), field);
}

#define mp_read_lv_indev_t(field) mp_read_ptr_lv_indev_t(copy_buffer(&field, sizeof(lv_indev_t)))
#define mp_read_byref_lv_indev_t(field) mp_read_ptr_lv_indev_t(&field)

STATIC void mp_lv_indev_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_indev_t *data = (lv_indev_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            ;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                ;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_indev_t_type,
    MP_QSTR_lv_indev_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_indev_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_indev_t_attr,
    locals_dict, &mp_lv_indev_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type()
{
    return &mp_lv_indev_t_type;
}
    

/*
 * Struct gd_GCE
 */

STATIC inline const mp_obj_type_t *get_mp_gd_GCE_type();

STATIC inline void* mp_write_ptr_gd_GCE(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_GCE_type()));
    return (gd_GCE*)self->data;
}

#define mp_write_gd_GCE(struct_obj) *((gd_GCE*)mp_write_ptr_gd_GCE(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_gd_GCE(void *field)
{
    return lv_to_mp_struct(get_mp_gd_GCE_type(), field);
}

#define mp_read_gd_GCE(field) mp_read_ptr_gd_GCE(copy_buffer(&field, sizeof(gd_GCE)))
#define mp_read_byref_gd_GCE(field) mp_read_ptr_gd_GCE(&field)

STATIC void mp_gd_GCE_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED gd_GCE *data = (gd_GCE*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_delay: dest[0] = mp_obj_new_int_from_uint(data->delay); break; // converting from uint16_t;
            case MP_QSTR_tindex: dest[0] = mp_obj_new_int_from_uint(data->tindex); break; // converting from uint8_t;
            case MP_QSTR_disposal: dest[0] = mp_obj_new_int_from_uint(data->disposal); break; // converting from uint8_t;
            case MP_QSTR_input: dest[0] = mp_obj_new_int(data->input); break; // converting from int;
            case MP_QSTR_transparency: dest[0] = mp_obj_new_int(data->transparency); break; // converting from int;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_delay: data->delay = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tindex: data->tindex = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_disposal: data->disposal = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_input: data->input = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_transparency: data->transparency = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_GCE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_GCE");
}

STATIC const mp_obj_dict_t mp_gd_GCE_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_gd_GCE_type,
    MP_QSTR_gd_GCE,
    MP_TYPE_FLAG_NONE,
    print, mp_gd_GCE_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_gd_GCE_attr,
    locals_dict, &mp_gd_GCE_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_gd_GCE_type()
{
    return &mp_gd_GCE_type;
}
    

/*
 * Array convertors for uint8_t [0x100 * 3]
 */

GENMPY_UNUSED STATIC uint8_t *mp_arr_to_uint8_t___0x100_ptr_3__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    uint8_t *lv_arr = (uint8_t*)m_malloc(len * sizeof(uint8_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint8_t)mp_obj_get_int(item);
    }
    return (uint8_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_uint8_t___0x100_ptr_3__(uint8_t *arr)
{
    mp_obj_t obj_arr[0x100 * 3];
    for (size_t i=0; i<0x100 * 3; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(0x100 * 3, obj_arr); // TODO: return custom iterable object!
}


/*
 * Struct gd_Palette
 */

STATIC inline const mp_obj_type_t *get_mp_gd_Palette_type();

STATIC inline void* mp_write_ptr_gd_Palette(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_Palette_type()));
    return (gd_Palette*)self->data;
}

#define mp_write_gd_Palette(struct_obj) *((gd_Palette*)mp_write_ptr_gd_Palette(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_gd_Palette(void *field)
{
    return lv_to_mp_struct(get_mp_gd_Palette_type(), field);
}

#define mp_read_gd_Palette(field) mp_read_ptr_gd_Palette(copy_buffer(&field, sizeof(gd_Palette)))
#define mp_read_byref_gd_Palette(field) mp_read_ptr_gd_Palette(&field)

STATIC void mp_gd_Palette_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED gd_Palette *data = (gd_Palette*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_size: dest[0] = mp_obj_new_int(data->size); break; // converting from int;
            case MP_QSTR_colors: dest[0] = mp_arr_from_uint8_t___0x100_ptr_3__(data->colors); break; // converting from uint8_t [0x100 * 3];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_size: data->size = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_colors: memcpy((void*)&data->colors, mp_arr_to_uint8_t___0x100_ptr_3__(dest[1]), sizeof(uint8_t)*0x100 * 3); break; // converting to uint8_t [0x100 * 3];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_Palette_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_Palette");
}

STATIC const mp_obj_dict_t mp_gd_Palette_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_gd_Palette_type,
    MP_QSTR_gd_Palette,
    MP_TYPE_FLAG_NONE,
    print, mp_gd_Palette_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_gd_Palette_attr,
    locals_dict, &mp_gd_Palette_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_gd_Palette_type()
{
    return &mp_gd_Palette_type;
}
    
#define funcptr_plain_text NULL


/*
 * lvgl extension definition for:
 * void plain_text(struct _gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */

STATIC mp_obj_t mp_funcptr_plain_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _gd_GIF *gif = mp_to_ptr(mp_args[0]);
    uint16_t tx = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t ty = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t tw = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t th = (uint16_t)mp_obj_get_int(mp_args[4]);
    uint8_t cw = (uint8_t)mp_obj_get_int(mp_args[5]);
    uint8_t ch = (uint8_t)mp_obj_get_int(mp_args[6]);
    uint8_t fg = (uint8_t)mp_obj_get_int(mp_args[7]);
    uint8_t bg = (uint8_t)mp_obj_get_int(mp_args[8]);
    ((void (*)(struct _gd_GIF *, uint16_t, uint16_t, uint16_t, uint16_t, uint8_t, uint8_t, uint8_t, uint8_t))lv_func_ptr)(gif, tx, ty, tw, th, cw, ch, fg, bg);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_plain_text_mpobj, 9, mp_funcptr_plain_text, funcptr_plain_text);
    
STATIC inline mp_obj_t mp_lv_funcptr_plain_text(void *func){ return mp_lv_funcptr(&mp_funcptr_plain_text_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_plain_text_callback'
 * void (*plain_text)(struct _gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */
    
#define funcptr_comment NULL


/*
 * lvgl extension definition for:
 * void comment(struct _gd_GIF *gif)
 */

STATIC mp_obj_t mp_funcptr_comment(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _gd_GIF *gif = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _gd_GIF *))lv_func_ptr)(gif);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_comment_mpobj, 1, mp_funcptr_comment, funcptr_comment);
    
STATIC inline mp_obj_t mp_lv_funcptr_comment(void *func){ return mp_lv_funcptr(&mp_funcptr_comment_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_comment_callback'
 * void (*comment)(struct _gd_GIF *gif)
 */
    
#define funcptr_application NULL


/*
 * Array convertors for char [8]
 */

GENMPY_UNUSED STATIC char *mp_arr_to_char___8__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_char___8__(char *arr)
{
    mp_obj_t obj_arr[8];
    for (size_t i=0; i<8; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(8, obj_arr); // TODO: return custom iterable object!
}


/*
 * Array convertors for char [3]
 */

GENMPY_UNUSED STATIC char *mp_arr_to_char___3__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_char___3__(char *arr)
{
    mp_obj_t obj_arr[3];
    for (size_t i=0; i<3; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(3, obj_arr); // TODO: return custom iterable object!
}


/*
 * lvgl extension definition for:
 * void application(struct _gd_GIF *gif, char id[8], char auth[3])
 */

STATIC mp_obj_t mp_funcptr_application(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _gd_GIF *gif = mp_to_ptr(mp_args[0]);
    char *id = mp_arr_to_char___8__(mp_args[1]);
    char *auth = mp_arr_to_char___3__(mp_args[2]);
    ((void (*)(struct _gd_GIF *, char [8], char [3]))lv_func_ptr)(gif, id, auth);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_application_mpobj, 3, mp_funcptr_application, funcptr_application);
    
STATIC inline mp_obj_t mp_lv_funcptr_application(void *func){ return mp_lv_funcptr(&mp_funcptr_application_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_application_callback'
 * void (*application)(struct _gd_GIF *gif, char id[8], char auth[3])
 */
    

/*
 * Struct gd_GIF
 */

STATIC inline const mp_obj_type_t *get_mp_gd_GIF_type();

STATIC inline void* mp_write_ptr_gd_GIF(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_GIF_type()));
    return (gd_GIF*)self->data;
}

#define mp_write_gd_GIF(struct_obj) *((gd_GIF*)mp_write_ptr_gd_GIF(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_gd_GIF(void *field)
{
    return lv_to_mp_struct(get_mp_gd_GIF_type(), field);
}

#define mp_read_gd_GIF(field) mp_read_ptr_gd_GIF(copy_buffer(&field, sizeof(gd_GIF)))
#define mp_read_byref_gd_GIF(field) mp_read_ptr_gd_GIF(&field)

STATIC void mp_gd_GIF_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED gd_GIF *data = (gd_GIF*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_fd: dest[0] = mp_read_byref_lv_fs_file_t(data->fd); break; // converting from lv_fs_file_t;
            case MP_QSTR_data: dest[0] = convert_to_str((void*)data->data); break; // converting from char *;
            case MP_QSTR_is_file: dest[0] = mp_obj_new_int_from_uint(data->is_file); break; // converting from uint8_t;
            case MP_QSTR_f_rw_p: dest[0] = mp_obj_new_int_from_uint(data->f_rw_p); break; // converting from uint32_t;
            case MP_QSTR_anim_start: dest[0] = mp_obj_new_int(data->anim_start); break; // converting from int32_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int_from_uint(data->width); break; // converting from uint16_t;
            case MP_QSTR_height: dest[0] = mp_obj_new_int_from_uint(data->height); break; // converting from uint16_t;
            case MP_QSTR_depth: dest[0] = mp_obj_new_int_from_uint(data->depth); break; // converting from uint16_t;
            case MP_QSTR_loop_count: dest[0] = mp_obj_new_int(data->loop_count); break; // converting from int32_t;
            case MP_QSTR_gce: dest[0] = mp_read_byref_gd_GCE(data->gce); break; // converting from gd_GCE;
            case MP_QSTR_palette: dest[0] = mp_read_ptr_gd_Palette((void*)data->palette); break; // converting from gd_Palette *;
            case MP_QSTR_lct: dest[0] = mp_read_byref_gd_Palette(data->lct); break; // converting from gd_Palette;
            case MP_QSTR_gct: dest[0] = mp_read_byref_gd_Palette(data->gct); break; // converting from gd_Palette;
            case MP_QSTR_plain_text: dest[0] = mp_lv_funcptr(&mp_funcptr_plain_text_mpobj, (void*)data->plain_text, NULL ,MP_QSTR_gd_GIF_plain_text, NULL); break; // converting from callback void (*)(gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg);
            case MP_QSTR_comment: dest[0] = mp_lv_funcptr(&mp_funcptr_comment_mpobj, (void*)data->comment, NULL ,MP_QSTR_gd_GIF_comment, NULL); break; // converting from callback void (*)(gd_GIF *gif);
            case MP_QSTR_application: dest[0] = mp_lv_funcptr(&mp_funcptr_application_mpobj, (void*)data->application, NULL ,MP_QSTR_gd_GIF_application, NULL); break; // converting from callback void (*)(gd_GIF *gif, char id[8], char auth[3]);
            case MP_QSTR_fx: dest[0] = mp_obj_new_int_from_uint(data->fx); break; // converting from uint16_t;
            case MP_QSTR_fy: dest[0] = mp_obj_new_int_from_uint(data->fy); break; // converting from uint16_t;
            case MP_QSTR_fw: dest[0] = mp_obj_new_int_from_uint(data->fw); break; // converting from uint16_t;
            case MP_QSTR_fh: dest[0] = mp_obj_new_int_from_uint(data->fh); break; // converting from uint16_t;
            case MP_QSTR_bgindex: dest[0] = mp_obj_new_int_from_uint(data->bgindex); break; // converting from uint8_t;
            case MP_QSTR_canvas: dest[0] = mp_array_from_u8ptr((void*)data->canvas); break; // converting from uint8_t *;
            case MP_QSTR_frame: dest[0] = mp_array_from_u8ptr((void*)data->frame); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_fd: data->fd = mp_write_lv_fs_file_t(dest[1]); break; // converting to lv_fs_file_t;
                case MP_QSTR_data: data->data = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_is_file: data->is_file = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_f_rw_p: data->f_rw_p = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_anim_start: data->anim_start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_width: data->width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_height: data->height = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_depth: data->depth = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_loop_count: data->loop_count = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_gce: data->gce = mp_write_gd_GCE(dest[1]); break; // converting to gd_GCE;
                case MP_QSTR_palette: data->palette = (void*)mp_write_ptr_gd_Palette(dest[1]); break; // converting to gd_Palette *;
                case MP_QSTR_lct: data->lct = mp_write_gd_Palette(dest[1]); break; // converting to gd_Palette;
                case MP_QSTR_gct: data->gct = mp_write_gd_Palette(dest[1]); break; // converting to gd_Palette;
                case MP_QSTR_plain_text: data->plain_text = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_plain_text, NULL, NULL, NULL, NULL); break; // converting to callback void (*)(gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg);
                case MP_QSTR_comment: data->comment = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_comment, NULL, NULL, NULL, NULL); break; // converting to callback void (*)(gd_GIF *gif);
                case MP_QSTR_application: data->application = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_application, NULL, NULL, NULL, NULL); break; // converting to callback void (*)(gd_GIF *gif, char id[8], char auth[3]);
                case MP_QSTR_fx: data->fx = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fy: data->fy = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fw: data->fw = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fh: data->fh = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_bgindex: data->bgindex = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_canvas: data->canvas = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_frame: data->frame = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_GIF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_GIF");
}

STATIC const mp_obj_dict_t mp_gd_GIF_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_gd_GIF_type,
    MP_QSTR_gd_GIF,
    MP_TYPE_FLAG_NONE,
    print, mp_gd_GIF_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_gd_GIF_attr,
    locals_dict, &mp_gd_GIF_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_gd_GIF_type()
{
    return &mp_gd_GIF_type;
}
    
#define funcptr_lv_theme_apply_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_theme_apply_cb_t(lv_theme_t *, lv_obj_t *)
 */

STATIC mp_obj_t mp_funcptr_lv_theme_apply_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *arg0 = mp_to_ptr(mp_args[0]);
    lv_obj_t *arg1 = mp_to_lv(mp_args[1]);
    ((void (*)(lv_theme_t *, lv_obj_t *))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_theme_apply_cb_t_mpobj, 2, mp_funcptr_lv_theme_apply_cb_t, funcptr_lv_theme_apply_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_theme_apply_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_theme_t_apply_cb_callback(lv_theme_t *, lv_obj_t *);

/*
 * Struct lv_theme_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type();

STATIC inline void* mp_write_ptr_lv_theme_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_theme_t_type()));
    return (lv_theme_t*)self->data;
}

#define mp_write_lv_theme_t(struct_obj) *((lv_theme_t*)mp_write_ptr_lv_theme_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_theme_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_theme_t_type(), field);
}

#define mp_read_lv_theme_t(field) mp_read_ptr_lv_theme_t(copy_buffer(&field, sizeof(lv_theme_t)))
#define mp_read_byref_lv_theme_t(field) mp_read_ptr_lv_theme_t(&field)

STATIC void mp_lv_theme_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_theme_t *data = (lv_theme_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_apply_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_mpobj, data->apply_cb, lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, data->user_data); break; // converting from callback lv_theme_apply_cb_t;
            case MP_QSTR_parent: dest[0] = ptr_to_mp((void*)data->parent); break; // converting from lv_theme_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_disp: dest[0] = mp_read_ptr_lv_display_t((void*)data->disp); break; // converting from lv_display_t *;
            case MP_QSTR_color_primary: dest[0] = mp_read_byref_lv_color_t(data->color_primary); break; // converting from lv_color_t;
            case MP_QSTR_color_secondary: dest[0] = mp_read_byref_lv_color_t(data->color_secondary); break; // converting from lv_color_t;
            case MP_QSTR_font_small: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_small); break; // converting from lv_font_t *;
            case MP_QSTR_font_normal: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_normal); break; // converting from lv_font_t *;
            case MP_QSTR_font_large: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_large); break; // converting from lv_font_t *;
            case MP_QSTR_flags: dest[0] = mp_obj_new_int_from_uint(data->flags); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_apply_cb: data->apply_cb = mp_lv_callback(dest[1], lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, &data->user_data, NULL, NULL, NULL); break; // converting to callback lv_theme_apply_cb_t;
                case MP_QSTR_parent: data->parent = (void*)mp_to_ptr(dest[1]); break; // converting to lv_theme_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_disp: data->disp = (void*)mp_write_ptr_lv_display_t(dest[1]); break; // converting to lv_display_t *;
                case MP_QSTR_color_primary: data->color_primary = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_color_secondary: data->color_secondary = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_font_small: data->font_small = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_normal: data->font_normal = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_large: data->font_large = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_flags: data->flags = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_theme_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_theme_t");
}

STATIC const mp_obj_dict_t mp_lv_theme_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_theme_t_type,
    MP_QSTR_lv_theme_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_theme_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_theme_t_attr,
    locals_dict, &mp_lv_theme_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type()
{
    return &mp_lv_theme_t_type;
}
    
#define funcptr_lv_draw_sw_mask_xcb_t NULL


/*
 * lvgl extension definition for:
 * lv_draw_sw_mask_res_t lv_draw_sw_mask_xcb_t(lv_opa_t *mask_buf, int32_t abs_x, int32_t abs_y, int32_t len, void *p)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_sw_mask_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_array_to_u8ptr(mp_args[0]);
    int32_t abs_x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t abs_y = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t len = (int32_t)mp_obj_get_int(mp_args[3]);
    void *p = mp_to_ptr(mp_args[4]);
    lv_draw_sw_mask_res_t _res = ((lv_draw_sw_mask_res_t (*)(lv_opa_t *, int32_t, int32_t, int32_t, void *))lv_func_ptr)(mask_buf, abs_x, abs_y, len, p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_sw_mask_xcb_t_mpobj, 5, mp_funcptr_lv_draw_sw_mask_xcb_t, funcptr_lv_draw_sw_mask_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_sw_mask_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_sw_mask_xcb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function '_lv_draw_sw_mask_common_dsc_t_cb_callback'
 * lv_draw_sw_mask_xcb_t cb
 */
    

/*
 * Struct _lv_draw_sw_mask_common_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_draw_sw_mask_common_dsc_t_type();

STATIC inline void* mp_write_ptr__lv_draw_sw_mask_common_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_draw_sw_mask_common_dsc_t_type()));
    return (_lv_draw_sw_mask_common_dsc_t*)self->data;
}

#define mp_write__lv_draw_sw_mask_common_dsc_t(struct_obj) *((_lv_draw_sw_mask_common_dsc_t*)mp_write_ptr__lv_draw_sw_mask_common_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr__lv_draw_sw_mask_common_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp__lv_draw_sw_mask_common_dsc_t_type(), field);
}

#define mp_read__lv_draw_sw_mask_common_dsc_t(field) mp_read_ptr__lv_draw_sw_mask_common_dsc_t(copy_buffer(&field, sizeof(_lv_draw_sw_mask_common_dsc_t)))
#define mp_read_byref__lv_draw_sw_mask_common_dsc_t(field) mp_read_ptr__lv_draw_sw_mask_common_dsc_t(&field)

STATIC void mp__lv_draw_sw_mask_common_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED _lv_draw_sw_mask_common_dsc_t *data = (_lv_draw_sw_mask_common_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_sw_mask_xcb_t_mpobj, data->cb, NULL ,MP_QSTR__lv_draw_sw_mask_common_dsc_t_cb, NULL); break; // converting from callback lv_draw_sw_mask_xcb_t;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from lv_draw_sw_mask_type_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], NULL ,MP_QSTR__lv_draw_sw_mask_common_dsc_t_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_sw_mask_xcb_t;
                case MP_QSTR_type: data->type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_sw_mask_type_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_draw_sw_mask_common_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_draw_sw_mask_common_dsc_t");
}

STATIC const mp_obj_dict_t mp__lv_draw_sw_mask_common_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp__lv_draw_sw_mask_common_dsc_t_type,
    MP_QSTR__lv_draw_sw_mask_common_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp__lv_draw_sw_mask_common_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp__lv_draw_sw_mask_common_dsc_t_attr,
    locals_dict, &mp__lv_draw_sw_mask_common_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp__lv_draw_sw_mask_common_dsc_t_type()
{
    return &mp__lv_draw_sw_mask_common_dsc_t_type;
}
    
typedef __typeof__( ((lv_draw_sw_mask_line_param_t*)(0))->cfg ) lv_draw_sw_mask_line_param_cfg_t;

/*
 * Struct lv_draw_sw_mask_line_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_line_param_cfg_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_line_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_line_param_cfg_t_type()));
    return (lv_draw_sw_mask_line_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_line_param_cfg_t(struct_obj) *((lv_draw_sw_mask_line_param_cfg_t*)mp_write_ptr_lv_draw_sw_mask_line_param_cfg_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_line_param_cfg_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_line_param_cfg_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_line_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_line_param_cfg_t)))
#define mp_read_byref_lv_draw_sw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_line_param_cfg_t(&field)

STATIC void mp_lv_draw_sw_mask_line_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_line_param_cfg_t *data = (lv_draw_sw_mask_line_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_p1: dest[0] = mp_read_byref_lv_point_t(data->p1); break; // converting from lv_point_t;
            case MP_QSTR_p2: dest[0] = mp_read_byref_lv_point_t(data->p2); break; // converting from lv_point_t;
            case MP_QSTR_side: dest[0] = mp_obj_new_int_from_uint(data->side); break; // converting from lv_draw_sw_mask_line_side_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_p1: data->p1 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_p2: data->p2 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_side: data->side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_sw_mask_line_side_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_line_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_line_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_line_param_cfg_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_line_param_cfg_t_type,
    MP_QSTR_lv_draw_sw_mask_line_param_cfg_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_line_param_cfg_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_line_param_cfg_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_line_param_cfg_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_line_param_cfg_t_type()
{
    return &mp_lv_draw_sw_mask_line_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_sw_mask_line_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_line_param_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_line_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_line_param_t_type()));
    return (lv_draw_sw_mask_line_param_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_line_param_t(struct_obj) *((lv_draw_sw_mask_line_param_t*)mp_write_ptr_lv_draw_sw_mask_line_param_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_line_param_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_line_param_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_line_param_t(field) mp_read_ptr_lv_draw_sw_mask_line_param_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_line_param_t)))
#define mp_read_byref_lv_draw_sw_mask_line_param_t(field) mp_read_ptr_lv_draw_sw_mask_line_param_t(&field)

STATIC void mp_lv_draw_sw_mask_line_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_line_param_t *data = (lv_draw_sw_mask_line_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_sw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_sw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_sw_mask_line_param_cfg_t(data->cfg); break; // converting from lv_draw_sw_mask_line_param_cfg_t;
            case MP_QSTR_origo: dest[0] = mp_read_byref_lv_point_t(data->origo); break; // converting from lv_point_t;
            case MP_QSTR_xy_steep: dest[0] = mp_obj_new_int(data->xy_steep); break; // converting from int32_t;
            case MP_QSTR_yx_steep: dest[0] = mp_obj_new_int(data->yx_steep); break; // converting from int32_t;
            case MP_QSTR_steep: dest[0] = mp_obj_new_int(data->steep); break; // converting from int32_t;
            case MP_QSTR_spx: dest[0] = mp_obj_new_int(data->spx); break; // converting from int32_t;
            case MP_QSTR_flat: dest[0] = mp_obj_new_int_from_uint(data->flat); break; // converting from uint8_t;
            case MP_QSTR_inv: dest[0] = mp_obj_new_int_from_uint(data->inv); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_sw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_sw_mask_line_param_cfg_t(dest[1]); break; // converting to lv_draw_sw_mask_line_param_cfg_t;
                case MP_QSTR_origo: data->origo = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_xy_steep: data->xy_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_yx_steep: data->yx_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_steep: data->steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_spx: data->spx = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_flat: data->flat = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_inv: data->inv = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_line_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_line_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_line_param_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_line_param_t_type,
    MP_QSTR_lv_draw_sw_mask_line_param_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_line_param_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_line_param_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_line_param_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_line_param_t_type()
{
    return &mp_lv_draw_sw_mask_line_param_t_type;
}
    
typedef __typeof__( ((lv_draw_sw_mask_angle_param_t*)(0))->cfg ) lv_draw_sw_mask_angle_param_cfg_t;

/*
 * Struct lv_draw_sw_mask_angle_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_angle_param_cfg_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_angle_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_angle_param_cfg_t_type()));
    return (lv_draw_sw_mask_angle_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_angle_param_cfg_t(struct_obj) *((lv_draw_sw_mask_angle_param_cfg_t*)mp_write_ptr_lv_draw_sw_mask_angle_param_cfg_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_angle_param_cfg_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_angle_param_cfg_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_angle_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_angle_param_cfg_t)))
#define mp_read_byref_lv_draw_sw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_angle_param_cfg_t(&field)

STATIC void mp_lv_draw_sw_mask_angle_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_angle_param_cfg_t *data = (lv_draw_sw_mask_angle_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_vertex_p: dest[0] = mp_read_byref_lv_point_t(data->vertex_p); break; // converting from lv_point_t;
            case MP_QSTR_start_angle: dest[0] = mp_obj_new_int(data->start_angle); break; // converting from int32_t;
            case MP_QSTR_end_angle: dest[0] = mp_obj_new_int(data->end_angle); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_vertex_p: data->vertex_p = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_start_angle: data->start_angle = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_end_angle: data->end_angle = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_angle_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_angle_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_angle_param_cfg_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_angle_param_cfg_t_type,
    MP_QSTR_lv_draw_sw_mask_angle_param_cfg_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_angle_param_cfg_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_angle_param_cfg_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_angle_param_cfg_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_angle_param_cfg_t_type()
{
    return &mp_lv_draw_sw_mask_angle_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_sw_mask_angle_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_angle_param_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_angle_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_angle_param_t_type()));
    return (lv_draw_sw_mask_angle_param_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_angle_param_t(struct_obj) *((lv_draw_sw_mask_angle_param_t*)mp_write_ptr_lv_draw_sw_mask_angle_param_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_angle_param_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_angle_param_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_angle_param_t(field) mp_read_ptr_lv_draw_sw_mask_angle_param_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_angle_param_t)))
#define mp_read_byref_lv_draw_sw_mask_angle_param_t(field) mp_read_ptr_lv_draw_sw_mask_angle_param_t(&field)

STATIC void mp_lv_draw_sw_mask_angle_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_angle_param_t *data = (lv_draw_sw_mask_angle_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_sw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_sw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_sw_mask_angle_param_cfg_t(data->cfg); break; // converting from lv_draw_sw_mask_angle_param_cfg_t;
            case MP_QSTR_start_line: dest[0] = mp_read_byref_lv_draw_sw_mask_line_param_t(data->start_line); break; // converting from lv_draw_sw_mask_line_param_t;
            case MP_QSTR_end_line: dest[0] = mp_read_byref_lv_draw_sw_mask_line_param_t(data->end_line); break; // converting from lv_draw_sw_mask_line_param_t;
            case MP_QSTR_delta_deg: dest[0] = mp_obj_new_int_from_uint(data->delta_deg); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_sw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_sw_mask_angle_param_cfg_t(dest[1]); break; // converting to lv_draw_sw_mask_angle_param_cfg_t;
                case MP_QSTR_start_line: data->start_line = mp_write_lv_draw_sw_mask_line_param_t(dest[1]); break; // converting to lv_draw_sw_mask_line_param_t;
                case MP_QSTR_end_line: data->end_line = mp_write_lv_draw_sw_mask_line_param_t(dest[1]); break; // converting to lv_draw_sw_mask_line_param_t;
                case MP_QSTR_delta_deg: data->delta_deg = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_angle_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_angle_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_angle_param_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_angle_param_t_type,
    MP_QSTR_lv_draw_sw_mask_angle_param_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_angle_param_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_angle_param_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_angle_param_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_angle_param_t_type()
{
    return &mp_lv_draw_sw_mask_angle_param_t_type;
}
    
typedef __typeof__( ((lv_draw_sw_mask_radius_param_t*)(0))->cfg ) lv_draw_sw_mask_radius_param_cfg_t;

/*
 * Struct lv_draw_sw_mask_radius_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_radius_param_cfg_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_radius_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_radius_param_cfg_t_type()));
    return (lv_draw_sw_mask_radius_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_radius_param_cfg_t(struct_obj) *((lv_draw_sw_mask_radius_param_cfg_t*)mp_write_ptr_lv_draw_sw_mask_radius_param_cfg_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_radius_param_cfg_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_radius_param_cfg_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_radius_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_radius_param_cfg_t)))
#define mp_read_byref_lv_draw_sw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_radius_param_cfg_t(&field)

STATIC void mp_lv_draw_sw_mask_radius_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_radius_param_cfg_t *data = (lv_draw_sw_mask_radius_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_rect: dest[0] = mp_read_byref_lv_area_t(data->rect); break; // converting from lv_area_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            case MP_QSTR_outer: dest[0] = mp_obj_new_int_from_uint(data->outer); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_rect: data->rect = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_outer: data->outer = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_radius_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_radius_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_radius_param_cfg_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_radius_param_cfg_t_type,
    MP_QSTR_lv_draw_sw_mask_radius_param_cfg_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_radius_param_cfg_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_radius_param_cfg_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_radius_param_cfg_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_radius_param_cfg_t_type()
{
    return &mp_lv_draw_sw_mask_radius_param_cfg_t_type;
}
    

/*
 * Struct _lv_draw_sw_mask_radius_circle_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_draw_sw_mask_radius_circle_dsc_t_type();

STATIC inline void* mp_write_ptr__lv_draw_sw_mask_radius_circle_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_draw_sw_mask_radius_circle_dsc_t_type()));
    return (_lv_draw_sw_mask_radius_circle_dsc_t*)self->data;
}

#define mp_write__lv_draw_sw_mask_radius_circle_dsc_t(struct_obj) *((_lv_draw_sw_mask_radius_circle_dsc_t*)mp_write_ptr__lv_draw_sw_mask_radius_circle_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr__lv_draw_sw_mask_radius_circle_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp__lv_draw_sw_mask_radius_circle_dsc_t_type(), field);
}

#define mp_read__lv_draw_sw_mask_radius_circle_dsc_t(field) mp_read_ptr__lv_draw_sw_mask_radius_circle_dsc_t(copy_buffer(&field, sizeof(_lv_draw_sw_mask_radius_circle_dsc_t)))
#define mp_read_byref__lv_draw_sw_mask_radius_circle_dsc_t(field) mp_read_ptr__lv_draw_sw_mask_radius_circle_dsc_t(&field)

STATIC void mp__lv_draw_sw_mask_radius_circle_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED _lv_draw_sw_mask_radius_circle_dsc_t *data = (_lv_draw_sw_mask_radius_circle_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf: dest[0] = mp_array_from_u8ptr((void*)data->buf); break; // converting from uint8_t *;
            case MP_QSTR_cir_opa: dest[0] = mp_array_from_u8ptr((void*)data->cir_opa); break; // converting from lv_opa_t *;
            case MP_QSTR_x_start_on_y: dest[0] = mp_array_from_u16ptr((void*)data->x_start_on_y); break; // converting from uint16_t *;
            case MP_QSTR_opa_start_on_y: dest[0] = mp_array_from_u16ptr((void*)data->opa_start_on_y); break; // converting from uint16_t *;
            case MP_QSTR_life: dest[0] = mp_obj_new_int(data->life); break; // converting from int32_t;
            case MP_QSTR_used_cnt: dest[0] = mp_obj_new_int_from_uint(data->used_cnt); break; // converting from uint32_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf: data->buf = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_cir_opa: data->cir_opa = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to lv_opa_t *;
                case MP_QSTR_x_start_on_y: data->x_start_on_y = (void*)mp_array_to_u16ptr(dest[1]); break; // converting to uint16_t *;
                case MP_QSTR_opa_start_on_y: data->opa_start_on_y = (void*)mp_array_to_u16ptr(dest[1]); break; // converting to uint16_t *;
                case MP_QSTR_life: data->life = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_used_cnt: data->used_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_radius: data->radius = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_draw_sw_mask_radius_circle_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_draw_sw_mask_radius_circle_dsc_t");
}

STATIC const mp_obj_dict_t mp__lv_draw_sw_mask_radius_circle_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp__lv_draw_sw_mask_radius_circle_dsc_t_type,
    MP_QSTR__lv_draw_sw_mask_radius_circle_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp__lv_draw_sw_mask_radius_circle_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp__lv_draw_sw_mask_radius_circle_dsc_t_attr,
    locals_dict, &mp__lv_draw_sw_mask_radius_circle_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp__lv_draw_sw_mask_radius_circle_dsc_t_type()
{
    return &mp__lv_draw_sw_mask_radius_circle_dsc_t_type;
}
    

/*
 * Struct lv_draw_sw_mask_radius_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_radius_param_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_radius_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_radius_param_t_type()));
    return (lv_draw_sw_mask_radius_param_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_radius_param_t(struct_obj) *((lv_draw_sw_mask_radius_param_t*)mp_write_ptr_lv_draw_sw_mask_radius_param_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_radius_param_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_radius_param_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_radius_param_t(field) mp_read_ptr_lv_draw_sw_mask_radius_param_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_radius_param_t)))
#define mp_read_byref_lv_draw_sw_mask_radius_param_t(field) mp_read_ptr_lv_draw_sw_mask_radius_param_t(&field)

STATIC void mp_lv_draw_sw_mask_radius_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_radius_param_t *data = (lv_draw_sw_mask_radius_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_sw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_sw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_sw_mask_radius_param_cfg_t(data->cfg); break; // converting from lv_draw_sw_mask_radius_param_cfg_t;
            case MP_QSTR_circle: dest[0] = mp_read_ptr__lv_draw_sw_mask_radius_circle_dsc_t((void*)data->circle); break; // converting from _lv_draw_sw_mask_radius_circle_dsc_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_sw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_sw_mask_radius_param_cfg_t(dest[1]); break; // converting to lv_draw_sw_mask_radius_param_cfg_t;
                case MP_QSTR_circle: data->circle = (void*)mp_write_ptr__lv_draw_sw_mask_radius_circle_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_radius_circle_dsc_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_radius_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_radius_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_radius_param_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_radius_param_t_type,
    MP_QSTR_lv_draw_sw_mask_radius_param_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_radius_param_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_radius_param_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_radius_param_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_radius_param_t_type()
{
    return &mp_lv_draw_sw_mask_radius_param_t_type;
}
    
typedef __typeof__( ((lv_draw_sw_mask_fade_param_t*)(0))->cfg ) lv_draw_sw_mask_fade_param_cfg_t;

/*
 * Struct lv_draw_sw_mask_fade_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_fade_param_cfg_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_fade_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_fade_param_cfg_t_type()));
    return (lv_draw_sw_mask_fade_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_fade_param_cfg_t(struct_obj) *((lv_draw_sw_mask_fade_param_cfg_t*)mp_write_ptr_lv_draw_sw_mask_fade_param_cfg_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_fade_param_cfg_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_fade_param_cfg_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_fade_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_fade_param_cfg_t)))
#define mp_read_byref_lv_draw_sw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_fade_param_cfg_t(&field)

STATIC void mp_lv_draw_sw_mask_fade_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_fade_param_cfg_t *data = (lv_draw_sw_mask_fade_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_y_top: dest[0] = mp_obj_new_int(data->y_top); break; // converting from int32_t;
            case MP_QSTR_y_bottom: dest[0] = mp_obj_new_int(data->y_bottom); break; // converting from int32_t;
            case MP_QSTR_opa_top: dest[0] = mp_obj_new_int_from_uint(data->opa_top); break; // converting from lv_opa_t;
            case MP_QSTR_opa_bottom: dest[0] = mp_obj_new_int_from_uint(data->opa_bottom); break; // converting from lv_opa_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_y_top: data->y_top = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y_bottom: data->y_bottom = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_opa_top: data->opa_top = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_opa_bottom: data->opa_bottom = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_fade_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_fade_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_fade_param_cfg_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_fade_param_cfg_t_type,
    MP_QSTR_lv_draw_sw_mask_fade_param_cfg_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_fade_param_cfg_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_fade_param_cfg_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_fade_param_cfg_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_fade_param_cfg_t_type()
{
    return &mp_lv_draw_sw_mask_fade_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_sw_mask_fade_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_fade_param_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_fade_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_fade_param_t_type()));
    return (lv_draw_sw_mask_fade_param_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_fade_param_t(struct_obj) *((lv_draw_sw_mask_fade_param_t*)mp_write_ptr_lv_draw_sw_mask_fade_param_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_fade_param_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_fade_param_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_fade_param_t(field) mp_read_ptr_lv_draw_sw_mask_fade_param_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_fade_param_t)))
#define mp_read_byref_lv_draw_sw_mask_fade_param_t(field) mp_read_ptr_lv_draw_sw_mask_fade_param_t(&field)

STATIC void mp_lv_draw_sw_mask_fade_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_fade_param_t *data = (lv_draw_sw_mask_fade_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_sw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_sw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_sw_mask_fade_param_cfg_t(data->cfg); break; // converting from lv_draw_sw_mask_fade_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_sw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_sw_mask_fade_param_cfg_t(dest[1]); break; // converting to lv_draw_sw_mask_fade_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_fade_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_fade_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_fade_param_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_fade_param_t_type,
    MP_QSTR_lv_draw_sw_mask_fade_param_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_fade_param_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_fade_param_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_fade_param_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_fade_param_t_type()
{
    return &mp_lv_draw_sw_mask_fade_param_t_type;
}
    
typedef __typeof__( ((lv_draw_sw_mask_map_param_t*)(0))->cfg ) lv_draw_sw_mask_map_param_cfg_t;

/*
 * Struct lv_draw_sw_mask_map_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_map_param_cfg_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_map_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_map_param_cfg_t_type()));
    return (lv_draw_sw_mask_map_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_map_param_cfg_t(struct_obj) *((lv_draw_sw_mask_map_param_cfg_t*)mp_write_ptr_lv_draw_sw_mask_map_param_cfg_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_map_param_cfg_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_map_param_cfg_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_map_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_map_param_cfg_t)))
#define mp_read_byref_lv_draw_sw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_sw_mask_map_param_cfg_t(&field)

STATIC void mp_lv_draw_sw_mask_map_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_map_param_cfg_t *data = (lv_draw_sw_mask_map_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_map: dest[0] = mp_array_from_u8ptr((void*)data->map); break; // converting from lv_opa_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_map: data->map = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to lv_opa_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_map_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_map_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_map_param_cfg_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_map_param_cfg_t_type,
    MP_QSTR_lv_draw_sw_mask_map_param_cfg_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_map_param_cfg_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_map_param_cfg_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_map_param_cfg_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_map_param_cfg_t_type()
{
    return &mp_lv_draw_sw_mask_map_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_sw_mask_map_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_map_param_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_mask_map_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_mask_map_param_t_type()));
    return (lv_draw_sw_mask_map_param_t*)self->data;
}

#define mp_write_lv_draw_sw_mask_map_param_t(struct_obj) *((lv_draw_sw_mask_map_param_t*)mp_write_ptr_lv_draw_sw_mask_map_param_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_mask_map_param_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_mask_map_param_t_type(), field);
}

#define mp_read_lv_draw_sw_mask_map_param_t(field) mp_read_ptr_lv_draw_sw_mask_map_param_t(copy_buffer(&field, sizeof(lv_draw_sw_mask_map_param_t)))
#define mp_read_byref_lv_draw_sw_mask_map_param_t(field) mp_read_ptr_lv_draw_sw_mask_map_param_t(&field)

STATIC void mp_lv_draw_sw_mask_map_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_mask_map_param_t *data = (lv_draw_sw_mask_map_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_sw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_sw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_sw_mask_map_param_cfg_t(data->cfg); break; // converting from lv_draw_sw_mask_map_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_sw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_sw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_sw_mask_map_param_cfg_t(dest[1]); break; // converting to lv_draw_sw_mask_map_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_mask_map_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_mask_map_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_mask_map_param_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_mask_map_param_t_type,
    MP_QSTR_lv_draw_sw_mask_map_param_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_mask_map_param_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_mask_map_param_t_attr,
    locals_dict, &mp_lv_draw_sw_mask_map_param_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_mask_map_param_t_type()
{
    return &mp_lv_draw_sw_mask_map_param_t_type;
}
    

STATIC const mp_rom_map_elem_t mp_C_Pointer_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(C_Pointer))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_C_Pointer_locals_dict, mp_C_Pointer_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_color_to_int(lv_color_t c)
 */

STATIC mp_obj_t mp_lv_color_to_int(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_color_t))lv_func_ptr)(c);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_int_mpobj, 1, mp_lv_color_to_int, lv_color_to_int);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_color_eq(lv_color_t c1, lv_color_t c2)
 */

STATIC mp_obj_t mp_lv_color_eq(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c1 = mp_write_lv_color_t(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color_t(mp_args[1]);
    bool _res = ((bool (*)(lv_color_t, lv_color_t))lv_func_ptr)(c1, c2);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_eq_mpobj, 2, mp_lv_color_eq, lv_color_eq);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
 */

STATIC mp_obj_t mp_lv_color_mix(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c1 = mp_write_lv_color_t(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color_t(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_color_t, uint8_t))lv_func_ptr)(c1, c2, mix);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix_mpobj, 3, mp_lv_color_mix, lv_color_mix);
    

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_color_brightness(lv_color_t c)
 */

STATIC mp_obj_t mp_lv_color_brightness(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color_t(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_color_t))lv_func_ptr)(c);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_brightness_mpobj, 1, mp_lv_color_brightness, lv_color_brightness);
    

/*
 * lvgl extension definition for:
 * lv_color32_t lv_color_to_32(lv_color_t color, lv_opa_t opa)
 */

STATIC mp_obj_t mp_lv_color_to_32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color_t(mp_args[0]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color32_t _res = ((lv_color32_t (*)(lv_color_t, lv_opa_t))lv_func_ptr)(color, opa);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_32_mpobj, 2, mp_lv_color_to_32, lv_color_to_32);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_color_to_u16(lv_color_t color)
 */

STATIC mp_obj_t mp_lv_color_to_u16(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_u16_mpobj, 1, mp_lv_color_to_u16, lv_color_to_u16);
    
/* Reusing lv_color_to_int for lv_color_to_u32 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_u32_mpobj, 1, mp_lv_color_to_int, lv_color_to_u32);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)
 */

STATIC mp_obj_t mp_lv_color_lighten(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color_t(mp_args[0]);
    lv_opa_t lvl = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_opa_t))lv_func_ptr)(c, lvl);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_lighten_mpobj, 2, mp_lv_color_lighten, lv_color_lighten);
    
/* Reusing lv_color_lighten for lv_color_darken */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_darken_mpobj, 2, mp_lv_color_lighten, lv_color_darken);
    

/*
 * Struct lv_color_hsv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type();

STATIC inline void* mp_write_ptr_lv_color_hsv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_hsv_t_type()));
    return (lv_color_hsv_t*)self->data;
}

#define mp_write_lv_color_hsv_t(struct_obj) *((lv_color_hsv_t*)mp_write_ptr_lv_color_hsv_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_color_hsv_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_color_hsv_t_type(), field);
}

#define mp_read_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(copy_buffer(&field, sizeof(lv_color_hsv_t)))
#define mp_read_byref_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(&field)

STATIC void mp_lv_color_hsv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_color_hsv_t *data = (lv_color_hsv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint16_t;
            case MP_QSTR_s: dest[0] = mp_obj_new_int_from_uint(data->s); break; // converting from uint8_t;
            case MP_QSTR_v: dest[0] = mp_obj_new_int_from_uint(data->v); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_h: data->h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_s: data->s = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_v: data->v = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_hsv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_hsv_t");
}

STATIC const mp_obj_dict_t mp_lv_color_hsv_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_color_hsv_t_type,
    MP_QSTR_lv_color_hsv_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_color_hsv_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_color_hsv_t_attr,
    locals_dict, &mp_lv_color_hsv_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type()
{
    return &mp_lv_color_hsv_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_to_hsv(lv_color_t color)
 */

STATIC mp_obj_t mp_lv_color_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color_t(mp_args[0]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_hsv_mpobj, 1, mp_lv_color_to_hsv, lv_color_to_hsv);
    

STATIC const mp_rom_map_elem_t mp_lv_color_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_t))) },
    { MP_ROM_QSTR(MP_QSTR_to_int), MP_ROM_PTR(&mp_lv_color_to_int_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_eq), MP_ROM_PTR(&mp_lv_color_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mix), MP_ROM_PTR(&mp_lv_color_mix_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_brightness), MP_ROM_PTR(&mp_lv_color_brightness_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_to_32), MP_ROM_PTR(&mp_lv_color_to_32_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_to_u16), MP_ROM_PTR(&mp_lv_color_to_u16_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_to_u32), MP_ROM_PTR(&mp_lv_color_to_u32_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_lighten), MP_ROM_PTR(&mp_lv_color_lighten_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_darken), MP_ROM_PTR(&mp_lv_color_darken_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_to_hsv), MP_ROM_PTR(&mp_lv_color_to_hsv_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_t_locals_dict, mp_lv_color_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_gradient_color_calculate(const lv_grad_dsc_t *dsc, int32_t range, int32_t frac, lv_grad_color_t *color_out, lv_opa_t *opa_out)
 */

STATIC mp_obj_t mp_lv_gradient_color_calculate(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_grad_dsc_t *dsc = (const lv_grad_dsc_t *)mp_write_ptr_lv_grad_dsc_t(mp_args[0]);
    int32_t range = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t frac = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_grad_color_t *color_out = mp_to_ptr(mp_args[3]);
    lv_opa_t *opa_out = mp_array_to_u8ptr(mp_args[4]);
    ((void (*)(const lv_grad_dsc_t *, int32_t, int32_t, lv_grad_color_t *, lv_opa_t *))lv_func_ptr)(dsc, range, frac, color_out, opa_out);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_color_calculate_mpobj, 5, mp_lv_gradient_color_calculate, lv_gradient_color_calculate);
    

/*
 * lvgl extension definition for:
 * lv_grad_t *lv_gradient_get(const lv_grad_dsc_t *gradient, int32_t w, int32_t h)
 */

STATIC mp_obj_t mp_lv_gradient_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_grad_dsc_t *gradient = (const lv_grad_dsc_t *)mp_write_ptr_lv_grad_dsc_t(mp_args[0]);
    int32_t w = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t h = (int32_t)mp_obj_get_int(mp_args[2]);
    lv_grad_t * _res = ((lv_grad_t *(*)(const lv_grad_dsc_t *, int32_t, int32_t))lv_func_ptr)(gradient, w, h);
    return mp_read_ptr_lv_grad_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_get_mpobj, 3, mp_lv_gradient_get, lv_gradient_get);
    

STATIC const mp_rom_map_elem_t mp_lv_grad_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_grad_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_gradient_color_calculate), MP_ROM_PTR(&mp_lv_gradient_color_calculate_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_get), MP_ROM_PTR(&mp_lv_gradient_get_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_grad_dsc_t_locals_dict, mp_lv_grad_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_gradient_stop_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_gradient_stop_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_gradient_stop_t_locals_dict, mp_lv_gradient_stop_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static int32_t lv_font_get_line_height(const lv_font_t *font)
 */

STATIC mp_obj_t mp_lv_font_get_line_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_font_t *))lv_func_ptr)(font);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_line_height_mpobj, 1, mp_lv_font_get_line_height, lv_font_get_line_height);
    
/* Reusing funcptr_get_glyph_dsc for lv_font_get_glyph_dsc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_mpobj, 4, mp_funcptr_get_glyph_dsc, lv_font_get_glyph_dsc);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_font_get_glyph_width(const lv_font_t *font, uint32_t letter, uint32_t letter_next)
 */

STATIC mp_obj_t mp_lv_font_get_glyph_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[0]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint16_t _res = ((uint16_t (*)(const lv_font_t *, uint32_t, uint32_t))lv_func_ptr)(font, letter, letter_next);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_width_mpobj, 3, mp_lv_font_get_glyph_width, lv_font_get_glyph_width);
    

/*
 * lvgl extension definition for:
 * void lv_font_set_kerning(lv_font_t *font, lv_font_kerning_t kerning)
 */

STATIC mp_obj_t mp_lv_font_set_kerning(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    lv_font_kerning_t kerning = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_font_t *, lv_font_kerning_t))lv_func_ptr)(font, kerning);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_set_kerning_mpobj, 2, mp_lv_font_set_kerning, lv_font_set_kerning);
    
/* Reusing funcptr_get_glyph_dsc for lv_font_get_glyph_dsc_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_fmt_txt_mpobj, 4, mp_funcptr_get_glyph_dsc, lv_font_get_glyph_dsc_fmt_txt);
    

STATIC const mp_rom_map_elem_t mp_lv_font_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_line_height), MP_ROM_PTR(&mp_lv_font_get_line_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_width), MP_ROM_PTR(&mp_lv_font_get_glyph_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_kerning), MP_ROM_PTR(&mp_lv_font_set_kerning_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_fmt_txt_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_t_locals_dict, mp_lv_font_t_locals_dict_table);
        
/* Reusing funcptr_get_glyph_bitmap for lv_font_get_glyph_bitmap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_bitmap_mpobj, 3, mp_funcptr_get_glyph_bitmap, lv_font_get_glyph_bitmap);
    
/* Reusing funcptr_get_glyph_bitmap for lv_font_get_bitmap_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_bitmap_fmt_txt_mpobj, 3, mp_funcptr_get_glyph_bitmap, lv_font_get_bitmap_fmt_txt);
    

STATIC const mp_rom_map_elem_t mp_lv_font_glyph_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_glyph_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_bitmap), MP_ROM_PTR(&mp_lv_font_get_glyph_bitmap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_bitmap_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_bitmap_fmt_txt_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_glyph_dsc_t_locals_dict, mp_lv_font_glyph_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * int32_t lv_cache_entry_get_ref(lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_ref(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_cache_entry_t *))lv_func_ptr)(entry);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_get_ref_mpobj, 1, mp_lv_cache_entry_get_ref, lv_cache_entry_get_ref);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_cache_entry_get_node_size(lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_node_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_cache_entry_t *))lv_func_ptr)(entry);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_get_node_size_mpobj, 1, mp_lv_cache_entry_get_node_size, lv_cache_entry_get_node_size);
    

/*
 * lvgl extension definition for:
 * bool lv_cache_entry_is_invalid(lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_is_invalid(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    bool _res = ((bool (*)(lv_cache_entry_t *))lv_func_ptr)(entry);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_is_invalid_mpobj, 1, mp_lv_cache_entry_is_invalid, lv_cache_entry_is_invalid);
    

/*
 * lvgl extension definition for:
 * void *lv_cache_entry_get_data(lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    void * _res = ((void *(*)(lv_cache_entry_t *))lv_func_ptr)(entry);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_get_data_mpobj, 1, mp_lv_cache_entry_get_data, lv_cache_entry_get_data);
    

/*
 * lvgl extension definition for:
 * const lv_cache_t *lv_cache_entry_get_cache(const lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_cache(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_cache_entry_t *entry = (const lv_cache_entry_t *)mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    const lv_cache_t * _res = ((const lv_cache_t *(*)(const lv_cache_entry_t *))lv_func_ptr)(entry);
    return mp_read_ptr_lv_cache_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_get_cache_mpobj, 1, mp_lv_cache_entry_get_cache, lv_cache_entry_get_cache);
    

/*
 * lvgl extension definition for:
 * void lv_cache_entry_init(lv_cache_entry_t *entry, const lv_cache_t *cache, const uint32_t node_size)
 */

STATIC mp_obj_t mp_lv_cache_entry_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    const lv_cache_t *cache = (const lv_cache_t *)mp_write_ptr_lv_cache_t(mp_args[1]);
    const uint32_t node_size = (const uint32_t)(uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_cache_entry_t *, const lv_cache_t *, const uint32_t))lv_func_ptr)(entry, cache, node_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_init_mpobj, 3, mp_lv_cache_entry_init, lv_cache_entry_init);
    

/*
 * lvgl extension definition for:
 * void lv_cache_entry_delete(lv_cache_entry_t *entry)
 */

STATIC mp_obj_t mp_lv_cache_entry_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_cache_entry_t *entry = mp_write_ptr_lv_cache_entry_t(mp_args[0]);
    ((void (*)(lv_cache_entry_t *))lv_func_ptr)(entry);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_entry_delete_mpobj, 1, mp_lv_cache_entry_delete, lv_cache_entry_delete);
    

STATIC const mp_rom_map_elem_t mp_lv_cache_entry_t_locals_dict_table[] = {
    
    { MP_ROM_QSTR(MP_QSTR_get_ref), MP_ROM_PTR(&mp_lv_cache_entry_get_ref_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_node_size), MP_ROM_PTR(&mp_lv_cache_entry_get_node_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_invalid), MP_ROM_PTR(&mp_lv_cache_entry_is_invalid_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_data), MP_ROM_PTR(&mp_lv_cache_entry_get_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cache), MP_ROM_PTR(&mp_lv_cache_entry_get_cache_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_cache_entry_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_cache_entry_delete_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_cache_entry_t_locals_dict, mp_lv_cache_entry_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static bool lv_draw_buf_has_flag(lv_draw_buf_t *draw_buf, lv_image_flags_t flag)
 */

STATIC mp_obj_t mp_lv_draw_buf_has_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    lv_image_flags_t flag = (int)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_draw_buf_t *, lv_image_flags_t))lv_func_ptr)(draw_buf, flag);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_has_flag_mpobj, 2, mp_lv_draw_buf_has_flag, lv_draw_buf_has_flag);
    

/*
 * lvgl extension definition for:
 * inline static void lv_draw_buf_from_image(lv_draw_buf_t *buf, const lv_image_dsc_t *img)
 */

STATIC mp_obj_t mp_lv_draw_buf_from_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    const lv_image_dsc_t *img = (const lv_image_dsc_t *)mp_write_ptr_lv_image_dsc_t(mp_args[1]);
    ((void (*)(lv_draw_buf_t *, const lv_image_dsc_t *))lv_func_ptr)(buf, img);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_from_image_mpobj, 2, mp_lv_draw_buf_from_image, lv_draw_buf_from_image);
    

/*
 * lvgl extension definition for:
 * inline static void lv_draw_buf_to_image(const lv_draw_buf_t *buf, lv_image_dsc_t *img)
 */

STATIC mp_obj_t mp_lv_draw_buf_to_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_draw_buf_t *buf = (const lv_draw_buf_t *)mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    lv_image_dsc_t *img = mp_write_ptr_lv_image_dsc_t(mp_args[1]);
    ((void (*)(const lv_draw_buf_t *, lv_image_dsc_t *))lv_func_ptr)(buf, img);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_to_image_mpobj, 2, mp_lv_draw_buf_to_image, lv_draw_buf_to_image);
    

/*
 * lvgl extension definition for:
 * void lv_draw_buf_clear(lv_draw_buf_t *draw_buf, const lv_area_t *a)
 */

STATIC mp_obj_t mp_lv_draw_buf_clear(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    const lv_area_t *a = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(lv_draw_buf_t *, const lv_area_t *))lv_func_ptr)(draw_buf, a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_clear_mpobj, 2, mp_lv_draw_buf_clear, lv_draw_buf_clear);
    

/*
 * lvgl extension definition for:
 * void lv_draw_buf_copy(lv_draw_buf_t *dest, const lv_area_t *dest_area, const lv_draw_buf_t *src, const lv_area_t *src_area)
 */

STATIC mp_obj_t mp_lv_draw_buf_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *dest = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    const lv_area_t *dest_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_draw_buf_t *src = (const lv_draw_buf_t *)mp_write_ptr_lv_draw_buf_t(mp_args[2]);
    const lv_area_t *src_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[3]);
    ((void (*)(lv_draw_buf_t *, const lv_area_t *, const lv_draw_buf_t *, const lv_area_t *))lv_func_ptr)(dest, dest_area, src, src_area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_copy_mpobj, 4, mp_lv_draw_buf_copy, lv_draw_buf_copy);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_draw_buf_init(lv_draw_buf_t *draw_buf, uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride, void *data, uint32_t data_size)
 */

STATIC mp_obj_t mp_lv_draw_buf_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    uint32_t w = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t h = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[3]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[4]);
    void *data = mp_to_ptr(mp_args[5]);
    uint32_t data_size = (uint32_t)mp_obj_get_int(mp_args[6]);
    lv_result_t _res = ((lv_result_t (*)(lv_draw_buf_t *, uint32_t, uint32_t, lv_color_format_t, uint32_t, void *, uint32_t))lv_func_ptr)(draw_buf, w, h, cf, stride, data, data_size);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_init_mpobj, 7, mp_lv_draw_buf_init, lv_draw_buf_init);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_draw_buf_dup(const lv_draw_buf_t *draw_buf)
 */

STATIC mp_obj_t mp_lv_draw_buf_dup(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_draw_buf_t *draw_buf = (const lv_draw_buf_t *)mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(const lv_draw_buf_t *))lv_func_ptr)(draw_buf);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_dup_mpobj, 1, mp_lv_draw_buf_dup, lv_draw_buf_dup);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_draw_buf_reshape(lv_draw_buf_t *draw_buf, lv_color_format_t cf, uint32_t w, uint32_t h, uint32_t stride)
 */

STATIC mp_obj_t mp_lv_draw_buf_reshape(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint32_t w = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t h = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(lv_draw_buf_t *, lv_color_format_t, uint32_t, uint32_t, uint32_t))lv_func_ptr)(draw_buf, cf, w, h, stride);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_reshape_mpobj, 5, mp_lv_draw_buf_reshape, lv_draw_buf_reshape);
    

/*
 * lvgl extension definition for:
 * void lv_draw_buf_destroy(lv_draw_buf_t *buf)
 */

STATIC mp_obj_t mp_lv_draw_buf_destroy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    ((void (*)(lv_draw_buf_t *))lv_func_ptr)(buf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_destroy_mpobj, 1, mp_lv_draw_buf_destroy, lv_draw_buf_destroy);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_buf_goto_xy(const lv_draw_buf_t *buf, uint32_t x, uint32_t y)
 */

STATIC mp_obj_t mp_lv_draw_buf_goto_xy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_draw_buf_t *buf = (const lv_draw_buf_t *)mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    uint32_t x = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t y = (uint32_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(const lv_draw_buf_t *, uint32_t, uint32_t))lv_func_ptr)(buf, x, y);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_goto_xy_mpobj, 3, mp_lv_draw_buf_goto_xy, lv_draw_buf_goto_xy);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_draw_buf_adjust_stride(const lv_draw_buf_t *src, uint32_t stride)
 */

STATIC mp_obj_t mp_lv_draw_buf_adjust_stride(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_draw_buf_t *src = (const lv_draw_buf_t *)mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(const lv_draw_buf_t *, uint32_t))lv_func_ptr)(src, stride);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_adjust_stride_mpobj, 2, mp_lv_draw_buf_adjust_stride, lv_draw_buf_adjust_stride);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_draw_buf_premultiply(lv_draw_buf_t *draw_buf)
 */

STATIC mp_obj_t mp_lv_draw_buf_premultiply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_buf_t *draw_buf = mp_write_ptr_lv_draw_buf_t(mp_args[0]);
    lv_result_t _res = ((lv_result_t (*)(lv_draw_buf_t *))lv_func_ptr)(draw_buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_buf_premultiply_mpobj, 1, mp_lv_draw_buf_premultiply, lv_draw_buf_premultiply);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_buf_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_buf_t))) },
    { MP_ROM_QSTR(MP_QSTR_has_flag), MP_ROM_PTR(&mp_lv_draw_buf_has_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_from_image), MP_ROM_PTR(&mp_lv_draw_buf_from_image_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_to_image), MP_ROM_PTR(&mp_lv_draw_buf_to_image_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&mp_lv_draw_buf_clear_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_draw_buf_copy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_buf_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_dup), MP_ROM_PTR(&mp_lv_draw_buf_dup_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_reshape), MP_ROM_PTR(&mp_lv_draw_buf_reshape_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_destroy), MP_ROM_PTR(&mp_lv_draw_buf_destroy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_goto_xy), MP_ROM_PTR(&mp_lv_draw_buf_goto_xy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_adjust_stride), MP_ROM_PTR(&mp_lv_draw_buf_adjust_stride_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_premultiply), MP_ROM_PTR(&mp_lv_draw_buf_premultiply_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_buf_t_locals_dict, mp_lv_draw_buf_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_image_header_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_image_header_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_image_header_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_image_header_t_locals_dict, mp_lv_image_header_t_locals_dict_table);
        

/*
 * Callback function lv_color_filter_dsc_t_cb
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */

GENMPY_UNUSED STATIC lv_color_t lv_color_filter_dsc_t_cb_callback(const struct _lv_color_filter_dsc_t *arg0, lv_color_t arg1, lv_opa_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_color_filter_dsc_t((void*)arg0);
    mp_args[1] = mp_read_lv_color_t(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_color_filter_dsc_t_cb)) , 3, 0, mp_args);
    _nesting--;
    return mp_write_lv_color_t(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_color_filter_dsc_init(lv_color_filter_dsc_t *dsc, lv_color_filter_cb_t cb)
 */

STATIC mp_obj_t mp_lv_color_filter_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_filter_dsc_t *dsc = mp_write_ptr_lv_color_filter_dsc_t(mp_args[0]);
    void *cb = mp_lv_callback(mp_args[1], &lv_color_filter_dsc_t_cb_callback, MP_QSTR_lv_color_filter_dsc_t_cb, &dsc->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_color_filter_dsc_t *, lv_color_filter_cb_t))lv_func_ptr)(dsc, cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_filter_dsc_init_mpobj, 2, mp_lv_color_filter_dsc_init, lv_color_filter_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_color_filter_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_filter_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_color_filter_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_filter_dsc_t_locals_dict, mp_lv_color_filter_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_var(lv_anim_t *a, void *var)
 */

STATIC mp_obj_t mp_lv_anim_set_var(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *var = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, void *))lv_func_ptr)(a, var);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_var_mpobj, 2, mp_lv_anim_set_var, lv_anim_set_var);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_exec_cb(lv_anim_t *a, lv_anim_exec_xcb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, lv_anim_exec_xcb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_exec_cb_mpobj, 2, mp_lv_anim_set_exec_cb, lv_anim_set_exec_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_duration(lv_anim_t *a, uint32_t duration)
 */

STATIC mp_obj_t mp_lv_anim_set_duration(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint32_t duration = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint32_t))lv_func_ptr)(a, duration);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_duration_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_duration);
    
/* Reusing lv_anim_set_duration for lv_anim_set_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_time_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_time);
    
/* Reusing lv_anim_set_duration for lv_anim_set_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_delay_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_values(lv_anim_t *a, int32_t start, int32_t end)
 */

STATIC mp_obj_t mp_lv_anim_set_values(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    int32_t start = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t end = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_anim_t *, int32_t, int32_t))lv_func_ptr)(a, start, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_values_mpobj, 3, mp_lv_anim_set_values, lv_anim_set_values);
    

/*
 * Callback function lv_anim_t_exec_cb
 * void lv_anim_custom_exec_cb_t(lv_anim_t *, int32_t)
 */

GENMPY_UNUSED STATIC void lv_anim_t_exec_cb_callback(lv_anim_t *arg0, int32_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_args[1] = mp_obj_new_int(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_exec_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_custom_exec_cb(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_custom_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_custom_exec_cb_mpobj, 2, mp_lv_anim_set_custom_exec_cb, lv_anim_set_custom_exec_cb);
    

/*
 * Callback function lv_anim_t_path_cb
 * int32_t lv_anim_path_cb_t(const lv_anim_t *)
 */

GENMPY_UNUSED STATIC int32_t lv_anim_t_path_cb_callback(const lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_path_cb)) , 1, 0, mp_args);
    _nesting--;
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_path_cb(lv_anim_t *a, lv_anim_path_cb_t path_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_path_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *path_cb = mp_lv_callback(mp_args[1], &lv_anim_t_path_cb_callback, MP_QSTR_lv_anim_t_path_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_path_cb_t))lv_func_ptr)(a, path_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_path_cb_mpobj, 2, mp_lv_anim_set_path_cb, lv_anim_set_path_cb);
    

/*
 * Callback function lv_anim_t_start_cb
 * void lv_anim_start_cb_t(lv_anim_t *)
 */

GENMPY_UNUSED STATIC void lv_anim_t_start_cb_callback(lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_start_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_start_cb(lv_anim_t *a, lv_anim_start_cb_t start_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_start_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *start_cb = mp_lv_callback(mp_args[1], &lv_anim_t_start_cb_callback, MP_QSTR_lv_anim_t_start_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_start_cb_t))lv_func_ptr)(a, start_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_start_cb_mpobj, 2, mp_lv_anim_set_start_cb, lv_anim_set_start_cb);
    

/*
 * Callback function lv_anim_t_get_value_cb
 * int32_t lv_anim_get_value_cb_t(lv_anim_t *)
 */

GENMPY_UNUSED STATIC int32_t lv_anim_t_get_value_cb_callback(lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_get_value_cb)) , 1, 0, mp_args);
    _nesting--;
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_get_value_cb(lv_anim_t *a, lv_anim_get_value_cb_t get_value_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_get_value_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *get_value_cb = mp_lv_callback(mp_args[1], &lv_anim_t_get_value_cb_callback, MP_QSTR_lv_anim_t_get_value_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_get_value_cb_t))lv_func_ptr)(a, get_value_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_get_value_cb_mpobj, 2, mp_lv_anim_set_get_value_cb, lv_anim_set_get_value_cb);
    

/*
 * Callback function lv_anim_t_completed_cb
 * void lv_anim_completed_cb_t(lv_anim_t *)
 */

GENMPY_UNUSED STATIC void lv_anim_t_completed_cb_callback(lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_completed_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_completed_cb(lv_anim_t *a, lv_anim_completed_cb_t completed_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_completed_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *completed_cb = mp_lv_callback(mp_args[1], &lv_anim_t_completed_cb_callback, MP_QSTR_lv_anim_t_completed_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_completed_cb_t))lv_func_ptr)(a, completed_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_completed_cb_mpobj, 2, mp_lv_anim_set_completed_cb, lv_anim_set_completed_cb);
    

/*
 * Callback function lv_anim_t_deleted_cb
 * void lv_anim_deleted_cb_t(lv_anim_t *)
 */

GENMPY_UNUSED STATIC void lv_anim_t_deleted_cb_callback(lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_deleted_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_deleted_cb(lv_anim_t *a, lv_anim_deleted_cb_t deleted_cb)
 */

STATIC mp_obj_t mp_lv_anim_set_deleted_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *deleted_cb = mp_lv_callback(mp_args[1], &lv_anim_t_deleted_cb_callback, MP_QSTR_lv_anim_t_deleted_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_anim_t *, lv_anim_deleted_cb_t))lv_func_ptr)(a, deleted_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_deleted_cb_mpobj, 2, mp_lv_anim_set_deleted_cb, lv_anim_set_deleted_cb);
    
/* Reusing lv_anim_set_duration for lv_anim_set_playback_duration */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_duration_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_playback_duration);
    
/* Reusing lv_anim_set_duration for lv_anim_set_playback_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_time_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_playback_time);
    
/* Reusing lv_anim_set_duration for lv_anim_set_playback_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_delay_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_playback_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_repeat_count(lv_anim_t *a, uint16_t cnt)
 */

STATIC mp_obj_t mp_lv_anim_set_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint16_t cnt = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint16_t))lv_func_ptr)(a, cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_count_mpobj, 2, mp_lv_anim_set_repeat_count, lv_anim_set_repeat_count);
    
/* Reusing lv_anim_set_duration for lv_anim_set_repeat_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_delay_mpobj, 2, mp_lv_anim_set_duration, lv_anim_set_repeat_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_early_apply(lv_anim_t *a, bool en)
 */

STATIC mp_obj_t mp_lv_anim_set_early_apply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_anim_t *, bool))lv_func_ptr)(a, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_early_apply_mpobj, 2, mp_lv_anim_set_early_apply, lv_anim_set_early_apply);
    
/* Reusing lv_anim_set_var for lv_anim_set_user_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_user_data_mpobj, 2, mp_lv_anim_set_var, lv_anim_set_user_data);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_bezier3_param(lv_anim_t *a, int16_t x1, int16_t y1, int16_t x2, int16_t y2)
 */

STATIC mp_obj_t mp_lv_anim_set_bezier3_param(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    int16_t x1 = (int16_t)mp_obj_get_int(mp_args[1]);
    int16_t y1 = (int16_t)mp_obj_get_int(mp_args[2]);
    int16_t x2 = (int16_t)mp_obj_get_int(mp_args[3]);
    int16_t y2 = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_anim_t *, int16_t, int16_t, int16_t, int16_t))lv_func_ptr)(a, x1, y1, x2, y2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_bezier3_param_mpobj, 5, mp_lv_anim_set_bezier3_param, lv_anim_set_bezier3_param);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_anim_get_delay(const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_get_delay(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_delay_mpobj, 1, mp_lv_anim_get_delay, lv_anim_get_delay);
    
/* Reusing lv_anim_get_delay for lv_anim_get_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_time_mpobj, 1, mp_lv_anim_get_delay, lv_anim_get_time);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_anim_get_repeat_count(const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_get_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_repeat_count_mpobj, 1, mp_lv_anim_get_repeat_count, lv_anim_get_repeat_count);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_anim_get_user_data(const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[0]);
    void * _res = ((void *(*)(const lv_anim_t *))lv_func_ptr)(a);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_user_data_mpobj, 1, mp_lv_anim_get_user_data, lv_anim_get_user_data);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_anim_custom_delete(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_custom_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    bool _res = ((bool (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_custom_delete_mpobj, 2, mp_lv_anim_custom_delete, lv_anim_custom_delete);
    

/*
 * lvgl extension definition for:
 * inline static lv_anim_t *lv_anim_custom_get(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_custom_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_anim_t * _res = ((lv_anim_t *(*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_custom_get_mpobj, 2, mp_lv_anim_custom_get, lv_anim_custom_get);
    
/* Reusing funcptr_lv_anim_start_cb_t for lv_anim_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_init_mpobj, 1, mp_funcptr_lv_anim_start_cb_t, lv_anim_init);
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_anim_start(const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_t * _res = ((lv_anim_t *(*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_start_mpobj, 1, mp_lv_anim_start, lv_anim_start);
    
/* Reusing lv_anim_get_delay for lv_anim_get_playtime */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_playtime_mpobj, 1, mp_lv_anim_get_delay, lv_anim_get_playtime);
    

/*
 * lvgl extension definition for:
 * int32_t lv_anim_path_linear(const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_path_linear(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_linear_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_linear);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_in);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_out_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_out_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_in_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_overshoot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_overshoot_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_overshoot);
    
/* Reusing lv_anim_path_linear for lv_anim_path_bounce */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_bounce_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_bounce);
    
/* Reusing lv_anim_path_linear for lv_anim_path_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_step_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_step);
    
/* Reusing lv_anim_path_linear for lv_anim_path_custom_bezier3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_custom_bezier3_mpobj, 1, mp_lv_anim_path_linear, lv_anim_path_custom_bezier3);
    

STATIC const mp_rom_map_elem_t mp_lv_anim_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_t))) },
    { MP_ROM_QSTR(MP_QSTR_set_var), MP_ROM_PTR(&mp_lv_anim_set_var_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_exec_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_duration), MP_ROM_PTR(&mp_lv_anim_set_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_time), MP_ROM_PTR(&mp_lv_anim_set_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_delay), MP_ROM_PTR(&mp_lv_anim_set_delay_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_values), MP_ROM_PTR(&mp_lv_anim_set_values_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_custom_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_custom_exec_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_path_cb), MP_ROM_PTR(&mp_lv_anim_set_path_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_cb), MP_ROM_PTR(&mp_lv_anim_set_start_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_get_value_cb), MP_ROM_PTR(&mp_lv_anim_set_get_value_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_completed_cb), MP_ROM_PTR(&mp_lv_anim_set_completed_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_deleted_cb), MP_ROM_PTR(&mp_lv_anim_set_deleted_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_duration), MP_ROM_PTR(&mp_lv_anim_set_playback_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_time), MP_ROM_PTR(&mp_lv_anim_set_playback_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_delay), MP_ROM_PTR(&mp_lv_anim_set_playback_delay_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_anim_set_repeat_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_delay), MP_ROM_PTR(&mp_lv_anim_set_repeat_delay_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_early_apply), MP_ROM_PTR(&mp_lv_anim_set_early_apply_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_anim_set_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bezier3_param), MP_ROM_PTR(&mp_lv_anim_set_bezier3_param_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_delay), MP_ROM_PTR(&mp_lv_anim_get_delay_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_time), MP_ROM_PTR(&mp_lv_anim_get_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_repeat_count), MP_ROM_PTR(&mp_lv_anim_get_repeat_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_anim_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_custom_delete), MP_ROM_PTR(&mp_lv_anim_custom_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_custom_get), MP_ROM_PTR(&mp_lv_anim_custom_get_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_anim_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_anim_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_playtime), MP_ROM_PTR(&mp_lv_anim_get_playtime_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_linear), MP_ROM_PTR(&mp_lv_anim_path_linear_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_in), MP_ROM_PTR(&mp_lv_anim_path_ease_in_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_out), MP_ROM_PTR(&mp_lv_anim_path_ease_out_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_in_out), MP_ROM_PTR(&mp_lv_anim_path_ease_in_out_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_overshoot), MP_ROM_PTR(&mp_lv_anim_path_overshoot_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_bounce), MP_ROM_PTR(&mp_lv_anim_path_bounce_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_step), MP_ROM_PTR(&mp_lv_anim_path_step_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_path_custom_bezier3), MP_ROM_PTR(&mp_lv_anim_path_custom_bezier3_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_t_locals_dict, mp_lv_anim_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_anim_parameter_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_parameter_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_parameter_t_locals_dict, mp_lv_anim_parameter_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_anim_bezier3_para_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_bezier3_para_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_bezier3_para_t_locals_dict, mp_lv_anim_bezier3_para_t_locals_dict_table);
        

/*
 * Array convertors for lv_style_prop_t []
 */

GENMPY_UNUSED STATIC lv_style_prop_t *mp_arr_to_lv_style_prop_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_style_prop_t *lv_arr = (lv_style_prop_t*)m_malloc(len * sizeof(lv_style_prop_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint8_t)mp_obj_get_int(item);
    }
    return (lv_style_prop_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_style_prop_t_____(const lv_style_prop_t *arr)
{
    return mp_array_from_u8ptr((void*)arr);
}


/*
 * Callback function lv_style_transition_dsc_init_path_cb
 * int32_t lv_anim_path_cb_t(const lv_anim_t *)
 */

GENMPY_UNUSED STATIC int32_t lv_style_transition_dsc_init_path_cb_callback(const lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_style_transition_dsc_init_path_cb)) , 1, 0, mp_args);
    _nesting--;
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_style_transition_dsc_init(lv_style_transition_dsc_t *tr, const lv_style_prop_t props[], lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void *user_data)
 */

STATIC mp_obj_t mp_lv_style_transition_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[5]);
    const lv_style_prop_t *props = (const lv_style_prop_t *)mp_arr_to_lv_style_prop_t_____(mp_args[1]);
    void *path_cb = mp_lv_callback(mp_args[2], &lv_style_transition_dsc_init_path_cb_callback, MP_QSTR_lv_style_transition_dsc_init_path_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_style_transition_dsc_t *tr = mp_write_ptr_lv_style_transition_dsc_t(mp_args[0]);
    ((void (*)(lv_style_transition_dsc_t *, const lv_style_prop_t [], lv_anim_path_cb_t, uint32_t, uint32_t, void *))lv_func_ptr)(tr, props, path_cb, time, delay, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_transition_dsc_init_mpobj, 6, mp_lv_style_transition_dsc_init, lv_style_transition_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_style_transition_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_transition_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_transition_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_transition_dsc_t_locals_dict, mp_lv_style_transition_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static int32_t lv_display_dpx(const lv_display_t *disp, int32_t n)
 */

STATIC mp_obj_t mp_lv_display_dpx(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_display_t *disp = (const lv_display_t *)mp_write_ptr_lv_display_t(mp_args[0]);
    int32_t n = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(const lv_display_t *, int32_t))lv_func_ptr)(disp, n);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_dpx_mpobj, 2, mp_lv_display_dpx, lv_display_dpx);
    

/*
 * lvgl extension definition for:
 * bool lv_draw_dispatch_layer(lv_display_t *disp, lv_layer_t *layer)
 */

STATIC mp_obj_t mp_lv_draw_dispatch_layer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[1]);
    bool _res = ((bool (*)(lv_display_t *, lv_layer_t *))lv_func_ptr)(disp, layer);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_dispatch_layer_mpobj, 2, mp_lv_draw_dispatch_layer, lv_draw_dispatch_layer);
    

/*
 * lvgl extension definition for:
 * void lv_display_delete(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    ((void (*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_delete_mpobj, 1, mp_lv_display_delete, lv_display_delete);
    
/* Reusing lv_display_delete for lv_display_set_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_default_mpobj, 1, mp_lv_display_delete, lv_display_set_default);
    

/*
 * lvgl extension definition for:
 * lv_display_t *lv_display_get_next(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_display_t * _res = ((lv_display_t *(*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_display_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_next_mpobj, 1, mp_lv_display_get_next, lv_display_get_next);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_resolution(lv_display_t *disp, int32_t hor_res, int32_t ver_res)
 */

STATIC mp_obj_t mp_lv_display_set_resolution(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    int32_t hor_res = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t ver_res = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_display_t *, int32_t, int32_t))lv_func_ptr)(disp, hor_res, ver_res);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_resolution_mpobj, 3, mp_lv_display_set_resolution, lv_display_set_resolution);
    
/* Reusing lv_display_set_resolution for lv_display_set_physical_resolution */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_physical_resolution_mpobj, 3, mp_lv_display_set_resolution, lv_display_set_physical_resolution);
    
/* Reusing lv_display_set_resolution for lv_display_set_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_offset_mpobj, 3, mp_lv_display_set_resolution, lv_display_set_offset);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_rotation(lv_display_t *disp, lv_display_rotation_t rotation)
 */

STATIC mp_obj_t mp_lv_display_set_rotation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_display_rotation_t rotation = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_display_t *, lv_display_rotation_t))lv_func_ptr)(disp, rotation);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_rotation_mpobj, 2, mp_lv_display_set_rotation, lv_display_set_rotation);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_dpi(lv_display_t *disp, int32_t dpi)
 */

STATIC mp_obj_t mp_lv_display_set_dpi(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    int32_t dpi = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_display_t *, int32_t))lv_func_ptr)(disp, dpi);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_dpi_mpobj, 2, mp_lv_display_set_dpi, lv_display_set_dpi);
    

/*
 * lvgl extension definition for:
 * int32_t lv_display_get_horizontal_resolution(const lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_horizontal_resolution(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_display_t *disp = (const lv_display_t *)mp_write_ptr_lv_display_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_display_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_horizontal_resolution_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_horizontal_resolution);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_vertical_resolution */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_vertical_resolution_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_vertical_resolution);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_physical_horizontal_resolution */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_physical_horizontal_resolution_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_physical_horizontal_resolution);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_physical_vertical_resolution */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_physical_vertical_resolution_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_physical_vertical_resolution);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_offset_x_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_offset_x);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_offset_y_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_offset_y);
    

/*
 * lvgl extension definition for:
 * lv_display_rotation_t lv_display_get_rotation(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_rotation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_display_rotation_t _res = ((lv_display_rotation_t (*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_rotation_mpobj, 1, mp_lv_display_get_rotation, lv_display_get_rotation);
    
/* Reusing lv_display_get_horizontal_resolution for lv_display_get_dpi */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_dpi_mpobj, 1, mp_lv_display_get_horizontal_resolution, lv_display_get_dpi);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_buffers(lv_display_t *disp, void *buf1, void *buf2, uint32_t buf_size, lv_display_render_mode_t render_mode)
 */

STATIC mp_obj_t mp_lv_display_set_buffers(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    void *buf1 = mp_to_ptr(mp_args[1]);
    void *buf2 = mp_to_ptr(mp_args[2]);
    uint32_t buf_size = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_display_render_mode_t render_mode = (int)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_display_t *, void *, void *, uint32_t, lv_display_render_mode_t))lv_func_ptr)(disp, buf1, buf2, buf_size, render_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_buffers_mpobj, 5, mp_lv_display_set_buffers, lv_display_set_buffers);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_draw_buffers(lv_display_t *disp, lv_draw_buf_t *buf1, lv_draw_buf_t *buf2)
 */

STATIC mp_obj_t mp_lv_display_set_draw_buffers(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_draw_buf_t *buf1 = mp_write_ptr_lv_draw_buf_t(mp_args[1]);
    lv_draw_buf_t *buf2 = mp_write_ptr_lv_draw_buf_t(mp_args[2]);
    ((void (*)(lv_display_t *, lv_draw_buf_t *, lv_draw_buf_t *))lv_func_ptr)(disp, buf1, buf2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_draw_buffers_mpobj, 3, mp_lv_display_set_draw_buffers, lv_display_set_draw_buffers);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_render_mode(lv_display_t *disp, lv_display_render_mode_t render_mode)
 */

STATIC mp_obj_t mp_lv_display_set_render_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_display_render_mode_t render_mode = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_display_t *, lv_display_render_mode_t))lv_func_ptr)(disp, render_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_render_mode_mpobj, 2, mp_lv_display_set_render_mode, lv_display_set_render_mode);
    

/*
 * Callback function lv_display_t_flush_cb
 * void lv_display_flush_cb_t(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map)
 */

GENMPY_UNUSED STATIC void lv_display_t_flush_cb_callback(lv_display_t *arg0, const lv_area_t *arg1, uint8_t *arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_display_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_args[2] = mp_array_from_u8ptr((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(lv_display_get_user_data(arg0));
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_display_t_flush_cb)) , 3, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_display_set_flush_cb(lv_display_t *disp, lv_display_flush_cb_t flush_cb)
 */

STATIC mp_obj_t mp_lv_display_set_flush_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    void *flush_cb = mp_lv_callback(mp_args[1], &lv_display_t_flush_cb_callback, MP_QSTR_lv_display_t_flush_cb, NULL, disp, (mp_lv_get_user_data)lv_display_get_user_data, (mp_lv_set_user_data)lv_display_set_user_data);
    ((void (*)(lv_display_t *, lv_display_flush_cb_t))lv_func_ptr)(disp, flush_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_flush_cb_mpobj, 2, mp_lv_display_set_flush_cb, lv_display_set_flush_cb);
    

/*
 * Callback function lv_display_t_wait_cb
 * void lv_display_flush_wait_cb_t(lv_display_t *disp)
 */

GENMPY_UNUSED STATIC void lv_display_t_wait_cb_callback(lv_display_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_display_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(lv_display_get_user_data(arg0));
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_display_t_wait_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_display_set_flush_wait_cb(lv_display_t *disp, lv_display_flush_wait_cb_t wait_cb)
 */

STATIC mp_obj_t mp_lv_display_set_flush_wait_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    void *wait_cb = mp_lv_callback(mp_args[1], &lv_display_t_wait_cb_callback, MP_QSTR_lv_display_t_wait_cb, NULL, disp, (mp_lv_get_user_data)lv_display_get_user_data, (mp_lv_set_user_data)lv_display_set_user_data);
    ((void (*)(lv_display_t *, lv_display_flush_wait_cb_t))lv_func_ptr)(disp, wait_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_flush_wait_cb_mpobj, 2, mp_lv_display_set_flush_wait_cb, lv_display_set_flush_wait_cb);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_color_format(lv_display_t *disp, lv_color_format_t color_format)
 */

STATIC mp_obj_t mp_lv_display_set_color_format(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_display_t *, lv_color_format_t))lv_func_ptr)(disp, color_format);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_color_format_mpobj, 2, mp_lv_display_set_color_format, lv_display_set_color_format);
    

/*
 * lvgl extension definition for:
 * lv_color_format_t lv_display_get_color_format(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_color_format(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_color_format_t _res = ((lv_color_format_t (*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_color_format_mpobj, 1, mp_lv_display_get_color_format, lv_display_get_color_format);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_antialiasing(lv_display_t *disp, bool en)
 */

STATIC mp_obj_t mp_lv_display_set_antialiasing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_display_t *, bool))lv_func_ptr)(disp, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_antialiasing_mpobj, 2, mp_lv_display_set_antialiasing, lv_display_set_antialiasing);
    

/*
 * lvgl extension definition for:
 * bool lv_display_get_antialiasing(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_antialiasing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    bool _res = ((bool (*)(lv_display_t *))lv_func_ptr)(disp);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_antialiasing_mpobj, 1, mp_lv_display_get_antialiasing, lv_display_get_antialiasing);
    
/* Reusing lv_display_delete for lv_display_flush_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_flush_ready_mpobj, 1, mp_lv_display_delete, lv_display_flush_ready);
    
/* Reusing lv_display_get_antialiasing for lv_display_flush_is_last */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_flush_is_last_mpobj, 1, mp_lv_display_get_antialiasing, lv_display_flush_is_last);
    
/* Reusing lv_display_get_antialiasing for lv_display_is_double_buffered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_is_double_buffered_mpobj, 1, mp_lv_display_get_antialiasing, lv_display_is_double_buffered);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_display_get_screen_active(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_screen_active(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_display_t *))lv_func_ptr)(disp);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_screen_active_mpobj, 1, mp_lv_display_get_screen_active, lv_display_get_screen_active);
    
/* Reusing lv_display_get_screen_active for lv_display_get_screen_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_screen_prev_mpobj, 1, mp_lv_display_get_screen_active, lv_display_get_screen_prev);
    
/* Reusing lv_display_get_screen_active for lv_display_get_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_layer_top_mpobj, 1, mp_lv_display_get_screen_active, lv_display_get_layer_top);
    
/* Reusing lv_display_get_screen_active for lv_display_get_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_layer_sys_mpobj, 1, mp_lv_display_get_screen_active, lv_display_get_layer_sys);
    
/* Reusing lv_display_get_screen_active for lv_display_get_layer_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_layer_bottom_mpobj, 1, mp_lv_display_get_screen_active, lv_display_get_layer_bottom);
    

/*
 * Callback function lv_display_add_event_cb_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_display_add_event_cb_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_display_add_event_cb_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_display_add_event_cb(lv_display_t *disp, lv_event_cb_t event_cb, lv_event_code_t filter, void *user_data)
 */

STATIC mp_obj_t mp_lv_display_add_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_display_add_event_cb_event_cb_callback, MP_QSTR_lv_display_add_event_cb_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_event_code_t filter = (int)mp_obj_get_int(mp_args[2]);
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    ((void (*)(lv_display_t *, lv_event_cb_t, lv_event_code_t, void *))lv_func_ptr)(disp, event_cb, filter, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_add_event_cb_mpobj, 4, mp_lv_display_add_event_cb, lv_display_add_event_cb);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_display_get_event_count(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_event_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_event_count_mpobj, 1, mp_lv_display_get_event_count, lv_display_get_event_count);
    

/*
 * lvgl extension definition for:
 * lv_event_dsc_t *lv_display_get_event_dsc(lv_display_t *disp, uint32_t index)
 */

STATIC mp_obj_t mp_lv_display_get_event_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_event_dsc_t * _res = ((lv_event_dsc_t *(*)(lv_display_t *, uint32_t))lv_func_ptr)(disp, index);
    return mp_read_ptr_lv_event_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_event_dsc_mpobj, 2, mp_lv_display_get_event_dsc, lv_display_get_event_dsc);
    

/*
 * lvgl extension definition for:
 * bool lv_display_delete_event(lv_display_t *disp, uint32_t index)
 */

STATIC mp_obj_t mp_lv_display_delete_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_display_t *, uint32_t))lv_func_ptr)(disp, index);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_delete_event_mpobj, 2, mp_lv_display_delete_event, lv_display_delete_event);
    

/*
 * Callback function lv_display_remove_event_cb_with_user_data_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_display_remove_event_cb_with_user_data_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_display_remove_event_cb_with_user_data_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * uint32_t lv_display_remove_event_cb_with_user_data(lv_display_t *disp, lv_event_cb_t event_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_display_remove_event_cb_with_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_display_remove_event_cb_with_user_data_event_cb_callback, MP_QSTR_lv_display_remove_event_cb_with_user_data_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_display_t *, lv_event_cb_t, void *))lv_func_ptr)(disp, event_cb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_remove_event_cb_with_user_data_mpobj, 3, mp_lv_display_remove_event_cb_with_user_data, lv_display_remove_event_cb_with_user_data);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_display_send_event(lv_display_t *disp, lv_event_code_t code, void *param)
 */

STATIC mp_obj_t mp_lv_display_send_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_event_code_t code = (int)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_display_t *, lv_event_code_t, void *))lv_func_ptr)(disp, code, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_send_event_mpobj, 3, mp_lv_display_send_event, lv_display_send_event);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_theme(lv_display_t *disp, lv_theme_t *th)
 */

STATIC mp_obj_t mp_lv_display_set_theme(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_theme_t *th = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_display_t *, lv_theme_t *))lv_func_ptr)(disp, th);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_theme_mpobj, 2, mp_lv_display_set_theme, lv_display_set_theme);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_display_get_theme(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_theme(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_theme_mpobj, 1, mp_lv_display_get_theme, lv_display_get_theme);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_display_get_inactive_time(const lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_inactive_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_display_t *disp = (const lv_display_t *)mp_write_ptr_lv_display_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_display_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_inactive_time_mpobj, 1, mp_lv_display_get_inactive_time, lv_display_get_inactive_time);
    
/* Reusing lv_display_delete for lv_display_trigger_activity */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_trigger_activity_mpobj, 1, mp_lv_display_delete, lv_display_trigger_activity);
    
/* Reusing lv_display_set_antialiasing for lv_display_enable_invalidation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_enable_invalidation_mpobj, 2, mp_lv_display_set_antialiasing, lv_display_enable_invalidation);
    
/* Reusing lv_display_get_antialiasing for lv_display_is_invalidation_enabled */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_is_invalidation_enabled_mpobj, 1, mp_lv_display_get_antialiasing, lv_display_is_invalidation_enabled);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_display_get_refr_timer(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_refr_timer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_display_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_refr_timer_mpobj, 1, mp_lv_display_get_refr_timer, lv_display_get_refr_timer);
    
/* Reusing lv_display_delete for lv_display_delete_refr_timer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_delete_refr_timer_mpobj, 1, mp_lv_display_delete, lv_display_delete_refr_timer);
    

/*
 * lvgl extension definition for:
 * void lv_display_set_user_data(lv_display_t *disp, void *user_data)
 */

STATIC mp_obj_t mp_lv_display_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    ((void (*)(lv_display_t *, void *))lv_func_ptr)(disp, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_user_data_mpobj, 2, mp_lv_display_set_user_data, lv_display_set_user_data);
    
/* Reusing lv_display_set_user_data for lv_display_set_driver_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_set_driver_data_mpobj, 2, mp_lv_display_set_user_data, lv_display_set_driver_data);
    

/*
 * lvgl extension definition for:
 * void *lv_display_get_user_data(lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_display_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    void * _res = ((void *(*)(lv_display_t *))lv_func_ptr)(disp);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_user_data_mpobj, 1, mp_lv_display_get_user_data, lv_display_get_user_data);
    
/* Reusing lv_display_get_user_data for lv_display_get_driver_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_display_get_driver_data_mpobj, 1, mp_lv_display_get_user_data, lv_display_get_driver_data);
    

STATIC const mp_rom_map_elem_t mp_lv_display_t_locals_dict_table[] = {
    
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_display_dpx_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_dispatch_layer), MP_ROM_PTR(&mp_lv_draw_dispatch_layer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_display_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_default), MP_ROM_PTR(&mp_lv_display_set_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_display_get_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_resolution), MP_ROM_PTR(&mp_lv_display_set_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_physical_resolution), MP_ROM_PTR(&mp_lv_display_set_physical_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset), MP_ROM_PTR(&mp_lv_display_set_offset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_display_set_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_dpi), MP_ROM_PTR(&mp_lv_display_set_dpi_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_horizontal_resolution), MP_ROM_PTR(&mp_lv_display_get_horizontal_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_vertical_resolution), MP_ROM_PTR(&mp_lv_display_get_vertical_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_physical_horizontal_resolution), MP_ROM_PTR(&mp_lv_display_get_physical_horizontal_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_physical_vertical_resolution), MP_ROM_PTR(&mp_lv_display_get_physical_vertical_resolution_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_x), MP_ROM_PTR(&mp_lv_display_get_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_y), MP_ROM_PTR(&mp_lv_display_get_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_rotation), MP_ROM_PTR(&mp_lv_display_get_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_dpi), MP_ROM_PTR(&mp_lv_display_get_dpi_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_buffers), MP_ROM_PTR(&mp_lv_display_set_buffers_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_draw_buffers), MP_ROM_PTR(&mp_lv_display_set_draw_buffers_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_render_mode), MP_ROM_PTR(&mp_lv_display_set_render_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flush_cb), MP_ROM_PTR(&mp_lv_display_set_flush_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flush_wait_cb), MP_ROM_PTR(&mp_lv_display_set_flush_wait_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_format), MP_ROM_PTR(&mp_lv_display_set_color_format_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_color_format), MP_ROM_PTR(&mp_lv_display_get_color_format_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_antialiasing), MP_ROM_PTR(&mp_lv_display_set_antialiasing_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialiasing), MP_ROM_PTR(&mp_lv_display_get_antialiasing_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_flush_ready), MP_ROM_PTR(&mp_lv_display_flush_ready_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_flush_is_last), MP_ROM_PTR(&mp_lv_display_flush_is_last_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_double_buffered), MP_ROM_PTR(&mp_lv_display_is_double_buffered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_screen_active), MP_ROM_PTR(&mp_lv_display_get_screen_active_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_screen_prev), MP_ROM_PTR(&mp_lv_display_get_screen_prev_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_top), MP_ROM_PTR(&mp_lv_display_get_layer_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_sys), MP_ROM_PTR(&mp_lv_display_get_layer_sys_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_bottom), MP_ROM_PTR(&mp_lv_display_get_layer_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_event_cb), MP_ROM_PTR(&mp_lv_display_add_event_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_count), MP_ROM_PTR(&mp_lv_display_get_event_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_dsc), MP_ROM_PTR(&mp_lv_display_get_event_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_event), MP_ROM_PTR(&mp_lv_display_delete_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb_with_user_data), MP_ROM_PTR(&mp_lv_display_remove_event_cb_with_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_send_event), MP_ROM_PTR(&mp_lv_display_send_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_theme), MP_ROM_PTR(&mp_lv_display_set_theme_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_theme), MP_ROM_PTR(&mp_lv_display_get_theme_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_inactive_time), MP_ROM_PTR(&mp_lv_display_get_inactive_time_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_trigger_activity), MP_ROM_PTR(&mp_lv_display_trigger_activity_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_enable_invalidation), MP_ROM_PTR(&mp_lv_display_enable_invalidation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_invalidation_enabled), MP_ROM_PTR(&mp_lv_display_is_invalidation_enabled_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_refr_timer), MP_ROM_PTR(&mp_lv_display_get_refr_timer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete_refr_timer), MP_ROM_PTR(&mp_lv_display_delete_refr_timer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_display_set_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_driver_data), MP_ROM_PTR(&mp_lv_display_set_driver_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_display_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_driver_data), MP_ROM_PTR(&mp_lv_display_get_driver_data_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_display_t_locals_dict, mp_lv_display_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_obj_class_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_obj_class_t))) },
    { MP_ROM_QSTR(MP_QSTR_create_obj), MP_ROM_PTR(&mp_lv_obj_class_create_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_base), MP_ROM_PTR(&mp_lv_obj_event_base_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_obj_class_t_locals_dict, mp_lv_obj_class_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void *lv_event_get_target(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_target(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    void * _res = ((void *(*)(lv_event_t *))lv_func_ptr)(e);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_target_mpobj, 1, mp_lv_event_get_target, lv_event_get_target);
    
/* Reusing lv_event_get_target for lv_event_get_current_target */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_current_target_mpobj, 1, mp_lv_event_get_target, lv_event_get_current_target);
    

/*
 * lvgl extension definition for:
 * lv_event_code_t lv_event_get_code(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_code(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_event_code_t _res = ((lv_event_code_t (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_code_mpobj, 1, mp_lv_event_get_code, lv_event_get_code);
    
/* Reusing lv_event_get_target for lv_event_get_param */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_param_mpobj, 1, mp_lv_event_get_target, lv_event_get_param);
    
/* Reusing lv_event_get_target for lv_event_get_user_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_user_data_mpobj, 1, mp_lv_event_get_target, lv_event_get_user_data);
    
/* Reusing funcptr_lv_event_cb_t for lv_event_stop_bubbling */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_stop_bubbling_mpobj, 1, mp_funcptr_lv_event_cb_t, lv_event_stop_bubbling);
    
/* Reusing funcptr_lv_event_cb_t for lv_event_stop_processing */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_stop_processing_mpobj, 1, mp_funcptr_lv_event_cb_t, lv_event_stop_processing);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_event_get_current_target_obj(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_current_target_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_current_target_obj_mpobj, 1, mp_lv_event_get_current_target_obj, lv_event_get_current_target_obj);
    
/* Reusing lv_event_get_current_target_obj for lv_event_get_target_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_target_obj_mpobj, 1, mp_lv_event_get_current_target_obj, lv_event_get_target_obj);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_event_get_indev(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_indev(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_indev_mpobj, 1, mp_lv_event_get_indev, lv_event_get_indev);
    

/*
 * lvgl extension definition for:
 * lv_layer_t *lv_event_get_layer(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_layer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_layer_t * _res = ((lv_layer_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_layer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_layer_mpobj, 1, mp_lv_event_get_layer, lv_event_get_layer);
    

/*
 * lvgl extension definition for:
 * const lv_area_t *lv_event_get_old_size(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_old_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    const lv_area_t * _res = ((const lv_area_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_area_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_old_size_mpobj, 1, mp_lv_event_get_old_size, lv_event_get_old_size);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_event_get_key(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_key_mpobj, 1, mp_lv_event_get_key, lv_event_get_key);
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_event_get_scroll_anim(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_scroll_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_anim_t * _res = ((lv_anim_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_scroll_anim_mpobj, 1, mp_lv_event_get_scroll_anim, lv_event_get_scroll_anim);
    

/*
 * lvgl extension definition for:
 * void lv_event_set_ext_draw_size(lv_event_t *e, int32_t size)
 */

STATIC mp_obj_t mp_lv_event_set_ext_draw_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    int32_t size = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_event_t *, int32_t))lv_func_ptr)(e, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_set_ext_draw_size_mpobj, 2, mp_lv_event_set_ext_draw_size, lv_event_set_ext_draw_size);
    

/*
 * lvgl extension definition for:
 * lv_point_t *lv_event_get_self_size_info(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_self_size_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_point_t * _res = ((lv_point_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_point_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_self_size_info_mpobj, 1, mp_lv_event_get_self_size_info, lv_event_get_self_size_info);
    

/*
 * Struct lv_hit_test_info_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_hit_test_info_t_type();

STATIC inline void* mp_write_ptr_lv_hit_test_info_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_hit_test_info_t_type()));
    return (lv_hit_test_info_t*)self->data;
}

#define mp_write_lv_hit_test_info_t(struct_obj) *((lv_hit_test_info_t*)mp_write_ptr_lv_hit_test_info_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_hit_test_info_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_hit_test_info_t_type(), field);
}

#define mp_read_lv_hit_test_info_t(field) mp_read_ptr_lv_hit_test_info_t(copy_buffer(&field, sizeof(lv_hit_test_info_t)))
#define mp_read_byref_lv_hit_test_info_t(field) mp_read_ptr_lv_hit_test_info_t(&field)

STATIC void mp_lv_hit_test_info_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_hit_test_info_t *data = (lv_hit_test_info_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_ptr_lv_point_t((void*)data->point); break; // converting from lv_point_t *;
            case MP_QSTR_res: dest[0] = convert_to_bool(data->res); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                case MP_QSTR_res: data->res = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_hit_test_info_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_hit_test_info_t");
}

STATIC const mp_obj_dict_t mp_lv_hit_test_info_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_hit_test_info_t_type,
    MP_QSTR_lv_hit_test_info_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_hit_test_info_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_hit_test_info_t_attr,
    locals_dict, &mp_lv_hit_test_info_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_hit_test_info_t_type()
{
    return &mp_lv_hit_test_info_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_hit_test_info_t *lv_event_get_hit_test_info(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_hit_test_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_hit_test_info_t * _res = ((lv_hit_test_info_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_hit_test_info_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_hit_test_info_mpobj, 1, mp_lv_event_get_hit_test_info, lv_event_get_hit_test_info);
    
/* Reusing lv_event_get_old_size for lv_event_get_cover_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_cover_area_mpobj, 1, mp_lv_event_get_old_size, lv_event_get_cover_area);
    

/*
 * lvgl extension definition for:
 * void lv_event_set_cover_res(lv_event_t *e, lv_cover_res_t res)
 */

STATIC mp_obj_t mp_lv_event_set_cover_res(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_cover_res_t res = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_event_t *, lv_cover_res_t))lv_func_ptr)(e, res);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_set_cover_res_mpobj, 2, mp_lv_event_set_cover_res, lv_event_set_cover_res);
    

/*
 * lvgl extension definition for:
 * lv_draw_task_t *lv_event_get_draw_task(lv_event_t *e)
 */

STATIC mp_obj_t mp_lv_event_get_draw_task(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_draw_task_t * _res = ((lv_draw_task_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_draw_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_draw_task_mpobj, 1, mp_lv_event_get_draw_task, lv_event_get_draw_task);
    

STATIC const mp_rom_map_elem_t mp_lv_event_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_event_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_target), MP_ROM_PTR(&mp_lv_event_get_target_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_current_target), MP_ROM_PTR(&mp_lv_event_get_current_target_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_code), MP_ROM_PTR(&mp_lv_event_get_code_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_param), MP_ROM_PTR(&mp_lv_event_get_param_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_event_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_stop_bubbling), MP_ROM_PTR(&mp_lv_event_stop_bubbling_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_stop_processing), MP_ROM_PTR(&mp_lv_event_stop_processing_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_current_target_obj), MP_ROM_PTR(&mp_lv_event_get_current_target_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_target_obj), MP_ROM_PTR(&mp_lv_event_get_target_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_indev), MP_ROM_PTR(&mp_lv_event_get_indev_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer), MP_ROM_PTR(&mp_lv_event_get_layer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_old_size), MP_ROM_PTR(&mp_lv_event_get_old_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_key), MP_ROM_PTR(&mp_lv_event_get_key_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_anim), MP_ROM_PTR(&mp_lv_event_get_scroll_anim_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_draw_size), MP_ROM_PTR(&mp_lv_event_set_ext_draw_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_size_info), MP_ROM_PTR(&mp_lv_event_get_self_size_info_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_hit_test_info), MP_ROM_PTR(&mp_lv_event_get_hit_test_info_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_cover_area), MP_ROM_PTR(&mp_lv_event_get_cover_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cover_res), MP_ROM_PTR(&mp_lv_event_set_cover_res_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_task), MP_ROM_PTR(&mp_lv_event_get_draw_task_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_event_t_locals_dict, mp_lv_event_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_area_copy(lv_area_t *dest, const lv_area_t *src)
 */

STATIC mp_obj_t mp_lv_area_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *dest = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *src = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(lv_area_t *, const lv_area_t *))lv_func_ptr)(dest, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_copy_mpobj, 2, mp_lv_area_copy, lv_area_copy);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_area_get_width(const lv_area_t *area_p)
 */

STATIC mp_obj_t mp_lv_area_get_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_width_mpobj, 1, mp_lv_area_get_width, lv_area_get_width);
    
/* Reusing lv_area_get_width for lv_area_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_height_mpobj, 1, mp_lv_area_get_width, lv_area_get_height);
    

/*
 * lvgl extension definition for:
 * void lv_area_set(lv_area_t *area_p, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
 */

STATIC mp_obj_t mp_lv_area_set(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    int32_t x1 = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y1 = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t x2 = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t y2 = (int32_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_area_t *, int32_t, int32_t, int32_t, int32_t))lv_func_ptr)(area_p, x1, y1, x2, y2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_mpobj, 5, mp_lv_area_set, lv_area_set);
    

/*
 * lvgl extension definition for:
 * void lv_area_set_width(lv_area_t *area_p, int32_t w)
 */

STATIC mp_obj_t mp_lv_area_set_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    int32_t w = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_area_t *, int32_t))lv_func_ptr)(area_p, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_width_mpobj, 2, mp_lv_area_set_width, lv_area_set_width);
    
/* Reusing lv_area_set_width for lv_area_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_height_mpobj, 2, mp_lv_area_set_width, lv_area_set_height);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_area_get_size(const lv_area_t *area_p)
 */

STATIC mp_obj_t mp_lv_area_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_size_mpobj, 1, mp_lv_area_get_size, lv_area_get_size);
    

/*
 * lvgl extension definition for:
 * void lv_area_increase(lv_area_t *area, int32_t w_extra, int32_t h_extra)
 */

STATIC mp_obj_t mp_lv_area_increase(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[0]);
    int32_t w_extra = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t h_extra = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_area_t *, int32_t, int32_t))lv_func_ptr)(area, w_extra, h_extra);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_increase_mpobj, 3, mp_lv_area_increase, lv_area_increase);
    
/* Reusing lv_area_increase for lv_area_move */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_move_mpobj, 3, mp_lv_area_increase, lv_area_move);
    

/*
 * lvgl extension definition for:
 * void lv_area_align(const lv_area_t *base, lv_area_t *to_align, lv_align_t align, int32_t ofs_x, int32_t ofs_y)
 */

STATIC mp_obj_t mp_lv_area_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *base = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[0]);
    lv_area_t *to_align = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    int32_t ofs_x = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t ofs_y = (int32_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(const lv_area_t *, lv_area_t *, lv_align_t, int32_t, int32_t))lv_func_ptr)(base, to_align, align, ofs_x, ofs_y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_align_mpobj, 5, mp_lv_area_align, lv_area_align);
    

STATIC const mp_rom_map_elem_t mp_lv_area_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_area_t))) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_area_copy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_area_get_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_area_get_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_lv_area_set_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_area_set_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_area_set_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_size), MP_ROM_PTR(&mp_lv_area_get_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_increase), MP_ROM_PTR(&mp_lv_area_increase_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_move), MP_ROM_PTR(&mp_lv_area_move_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_align), MP_ROM_PTR(&mp_lv_area_align_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_area_t_locals_dict, mp_lv_area_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_point_precise_t lv_point_to_precise(const lv_point_t *p)
 */

STATIC mp_obj_t mp_lv_point_to_precise(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_t *p = (const lv_point_t *)mp_write_ptr_lv_point_t(mp_args[0]);
    lv_point_precise_t _res = ((lv_point_precise_t (*)(const lv_point_t *))lv_func_ptr)(p);
    return mp_read_lv_point_precise_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_to_precise_mpobj, 1, mp_lv_point_to_precise, lv_point_to_precise);
    

/*
 * lvgl extension definition for:
 * inline static void lv_point_set(lv_point_t *p, int32_t x, int32_t y)
 */

STATIC mp_obj_t mp_lv_point_set(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *p = mp_write_ptr_lv_point_t(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_point_t *, int32_t, int32_t))lv_func_ptr)(p, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_set_mpobj, 3, mp_lv_point_set, lv_point_set);
    

/*
 * lvgl extension definition for:
 * inline static void lv_point_swap(lv_point_t *p1, lv_point_t *p2)
 */

STATIC mp_obj_t mp_lv_point_swap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *p1 = mp_write_ptr_lv_point_t(mp_args[0]);
    lv_point_t *p2 = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(lv_point_t *, lv_point_t *))lv_func_ptr)(p1, p2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_swap_mpobj, 2, mp_lv_point_swap, lv_point_swap);
    

/*
 * lvgl extension definition for:
 * void lv_point_transform(lv_point_t *p, int32_t angle, int32_t scale_x, int32_t scale_y, const lv_point_t *pivot, bool zoom_first)
 */

STATIC mp_obj_t mp_lv_point_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *p = mp_write_ptr_lv_point_t(mp_args[0]);
    int32_t angle = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t scale_x = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t scale_y = (int32_t)mp_obj_get_int(mp_args[3]);
    const lv_point_t *pivot = (const lv_point_t *)mp_write_ptr_lv_point_t(mp_args[4]);
    bool zoom_first = mp_obj_is_true(mp_args[5]);
    ((void (*)(lv_point_t *, int32_t, int32_t, int32_t, const lv_point_t *, bool))lv_func_ptr)(p, angle, scale_x, scale_y, pivot, zoom_first);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_transform_mpobj, 6, mp_lv_point_transform, lv_point_transform);
    

STATIC const mp_rom_map_elem_t mp_lv_point_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_point_t))) },
    { MP_ROM_QSTR(MP_QSTR_to_precise), MP_ROM_PTR(&mp_lv_point_to_precise_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_lv_point_set_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_swap), MP_ROM_PTR(&mp_lv_point_swap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_transform), MP_ROM_PTR(&mp_lv_point_transform_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_point_t_locals_dict, mp_lv_point_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static bool lv_style_is_const(const lv_style_t *style)
 */

STATIC mp_obj_t mp_lv_style_is_const(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_t *style = (const lv_style_t *)mp_write_ptr_lv_style_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_style_t *))lv_func_ptr)(style);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_is_const_mpobj, 1, mp_lv_style_is_const, lv_style_is_const);
    

/*
 * lvgl extension definition for:
 * inline static lv_style_res_t lv_style_get_prop_inlined(const lv_style_t *style, lv_style_prop_t prop, lv_style_value_t *value)
 */

STATIC mp_obj_t mp_lv_style_get_prop_inlined(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_t *style = (const lv_style_t *)mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_value_t *value = mp_write_ptr_lv_style_value_t(mp_args[2]);
    lv_style_res_t _res = ((lv_style_res_t (*)(const lv_style_t *, lv_style_prop_t, lv_style_value_t *))lv_func_ptr)(style, prop, value);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_get_prop_inlined_mpobj, 3, mp_lv_style_get_prop_inlined, lv_style_get_prop_inlined);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_size(lv_style_t *style, int32_t width, int32_t height)
 */

STATIC mp_obj_t mp_lv_style_set_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    int32_t width = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t height = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, int32_t, int32_t))lv_func_ptr)(style, width, height);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_size_mpobj, 3, mp_lv_style_set_size, lv_style_set_size);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_pad_all(lv_style_t *style, int32_t value)
 */

STATIC mp_obj_t mp_lv_style_set_pad_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, int32_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_all_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_all);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_hor_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_hor);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_ver_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_ver);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_gap_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_gap);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_scale */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_scale_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_scale);
    
/* Reusing lv_obj_report_style_change for lv_style_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_init_mpobj, 1, mp_lv_obj_report_style_change, lv_style_init);
    
/* Reusing lv_obj_report_style_change for lv_style_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_reset_mpobj, 1, mp_lv_obj_report_style_change, lv_style_reset);
    

/*
 * lvgl extension definition for:
 * bool lv_style_remove_prop(lv_style_t *style, lv_style_prop_t prop)
 */

STATIC mp_obj_t mp_lv_style_remove_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_style_t *, lv_style_prop_t))lv_func_ptr)(style, prop);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_remove_prop_mpobj, 2, mp_lv_style_remove_prop, lv_style_remove_prop);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_prop(lv_style_t *style, lv_style_prop_t prop, lv_style_value_t value)
 */

STATIC mp_obj_t mp_lv_style_set_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_value_t value = mp_write_lv_style_value_t(mp_args[2]);
    ((void (*)(lv_style_t *, lv_style_prop_t, lv_style_value_t))lv_func_ptr)(style, prop, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_prop_mpobj, 3, mp_lv_style_set_prop, lv_style_set_prop);
    
/* Reusing lv_style_get_prop_inlined for lv_style_get_prop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_get_prop_mpobj, 3, mp_lv_style_get_prop_inlined, lv_style_get_prop);
    
/* Reusing lv_style_is_const for lv_style_is_empty */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_is_empty_mpobj, 1, mp_lv_style_is_const, lv_style_is_empty);
    
/* Reusing lv_style_set_pad_all for lv_style_set_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_min_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_min_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_max_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_max_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_height_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_height);
    
/* Reusing lv_style_set_pad_all for lv_style_set_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_min_height_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_min_height);
    
/* Reusing lv_style_set_pad_all for lv_style_set_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_max_height_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_max_height);
    
/* Reusing lv_style_set_pad_all for lv_style_set_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_length_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_length);
    
/* Reusing lv_style_set_pad_all for lv_style_set_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_y);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_align(lv_style_t *style, lv_align_t value)
 */

STATIC mp_obj_t mp_lv_style_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_align_mpobj, 2, mp_lv_style_set_align, lv_style_set_align);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_height_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_height);
    
/* Reusing lv_style_set_pad_all for lv_style_set_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_translate_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_translate_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_translate_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_translate_y);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_scale_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_scale_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_scale_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_scale_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_scale_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_scale_y);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_rotation_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_rotation);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_pivot_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_pivot_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_pivot_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_pivot_y);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_skew_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_skew_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_skew_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_transform_skew_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_skew_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_transform_skew_y);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_top_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_top);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_bottom_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_bottom);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_left_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_left);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_right_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_right);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_row_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_row);
    
/* Reusing lv_style_set_pad_all for lv_style_set_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_column_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_pad_column);
    
/* Reusing lv_style_set_pad_all for lv_style_set_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_top_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_margin_top);
    
/* Reusing lv_style_set_pad_all for lv_style_set_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_bottom_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_margin_bottom);
    
/* Reusing lv_style_set_pad_all for lv_style_set_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_left_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_margin_left);
    
/* Reusing lv_style_set_pad_all for lv_style_set_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_right_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_margin_right);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_color(lv_style_t *style, lv_color_t value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_color_t value = mp_write_lv_color_t(mp_args[1]);
    ((void (*)(lv_style_t *, lv_color_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_opa(lv_style_t *style, lv_opa_t value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_opa_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_grad_color);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_grad_dir(lv_style_t *style, lv_grad_dir_t value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_grad_dir_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_dir_mpobj, 2, mp_lv_style_set_bg_grad_dir, lv_style_set_bg_grad_dir);
    
/* Reusing lv_style_set_pad_all for lv_style_set_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_main_stop_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_bg_main_stop);
    
/* Reusing lv_style_set_pad_all for lv_style_set_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_stop_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_bg_grad_stop);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_main_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_main_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_main_opa);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_grad_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_grad_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_grad(lv_style_t *style, const lv_grad_dsc_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_grad_dsc_t *value = (const lv_grad_dsc_t *)mp_write_ptr_lv_grad_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_grad_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_mpobj, 2, mp_lv_style_set_bg_grad, lv_style_set_bg_grad);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_image_src(lv_style_t *style, const void *value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_image_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const void *value = (const void *)mp_to_ptr(mp_args[1]);
    ((void (*)(lv_style_t *, const void *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_image_src_mpobj, 2, mp_lv_style_set_bg_image_src, lv_style_set_bg_image_src);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_image_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_image_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_bg_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_image_recolor_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_image_recolor);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_image_recolor_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_image_recolor_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_image_tiled(lv_style_t *style, bool value)
 */

STATIC mp_obj_t mp_lv_style_set_bg_image_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    bool value = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_style_t *, bool))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_image_tiled_mpobj, 2, mp_lv_style_set_bg_image_tiled, lv_style_set_bg_image_tiled);
    
/* Reusing lv_style_set_bg_color for lv_style_set_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_border_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_border_opa);
    
/* Reusing lv_style_set_pad_all for lv_style_set_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_border_width);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_border_side(lv_style_t *style, lv_border_side_t value)
 */

STATIC mp_obj_t mp_lv_style_set_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_border_side_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_side_mpobj, 2, mp_lv_style_set_border_side, lv_style_set_border_side);
    
/* Reusing lv_style_set_bg_image_tiled for lv_style_set_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_post_mpobj, 2, mp_lv_style_set_bg_image_tiled, lv_style_set_border_post);
    
/* Reusing lv_style_set_pad_all for lv_style_set_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_outline_width);
    
/* Reusing lv_style_set_bg_color for lv_style_set_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_outline_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_outline_opa);
    
/* Reusing lv_style_set_pad_all for lv_style_set_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_pad_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_outline_pad);
    
/* Reusing lv_style_set_pad_all for lv_style_set_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_shadow_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_shadow_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_offset_x_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_shadow_offset_x);
    
/* Reusing lv_style_set_pad_all for lv_style_set_shadow_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_offset_y_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_shadow_offset_y);
    
/* Reusing lv_style_set_pad_all for lv_style_set_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_spread_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_shadow_spread);
    
/* Reusing lv_style_set_bg_color for lv_style_set_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_shadow_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_shadow_opa);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_image_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_recolor_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_image_recolor);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_recolor_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_image_recolor_opa);
    
/* Reusing lv_style_set_pad_all for lv_style_set_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_line_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_line_dash_width);
    
/* Reusing lv_style_set_pad_all for lv_style_set_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_gap_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_line_dash_gap);
    
/* Reusing lv_style_set_bg_image_tiled for lv_style_set_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_rounded_mpobj, 2, mp_lv_style_set_bg_image_tiled, lv_style_set_line_rounded);
    
/* Reusing lv_style_set_bg_color for lv_style_set_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_line_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_line_opa);
    
/* Reusing lv_style_set_pad_all for lv_style_set_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_width_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_arc_width);
    
/* Reusing lv_style_set_bg_image_tiled for lv_style_set_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_rounded_mpobj, 2, mp_lv_style_set_bg_image_tiled, lv_style_set_arc_rounded);
    
/* Reusing lv_style_set_bg_color for lv_style_set_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_arc_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_arc_opa);
    
/* Reusing lv_style_set_bg_image_src for lv_style_set_arc_image_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_image_src_mpobj, 2, mp_lv_style_set_bg_image_src, lv_style_set_arc_image_src);
    
/* Reusing lv_style_set_bg_color for lv_style_set_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_color_mpobj, 2, mp_lv_style_set_bg_color, lv_style_set_text_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_text_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_font(lv_style_t *style, const lv_font_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_font_t *value = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_font_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_font_mpobj, 2, mp_lv_style_set_text_font, lv_style_set_text_font);
    
/* Reusing lv_style_set_pad_all for lv_style_set_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_letter_space_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_text_letter_space);
    
/* Reusing lv_style_set_pad_all for lv_style_set_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_line_space_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_text_line_space);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_decor(lv_style_t *style, lv_text_decor_t value)
 */

STATIC mp_obj_t mp_lv_style_set_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_text_decor_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_decor_mpobj, 2, mp_lv_style_set_text_decor, lv_style_set_text_decor);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_align(lv_style_t *style, lv_text_align_t value)
 */

STATIC mp_obj_t mp_lv_style_set_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_text_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_text_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_align_mpobj, 2, mp_lv_style_set_text_align, lv_style_set_text_align);
    
/* Reusing lv_style_set_pad_all for lv_style_set_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_radius_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_radius);
    
/* Reusing lv_style_set_bg_image_tiled for lv_style_set_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_clip_corner_mpobj, 2, mp_lv_style_set_bg_image_tiled, lv_style_set_clip_corner);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_opa);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_opa_layered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_opa_layered_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_opa_layered);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_color_filter_dsc(lv_style_t *style, const lv_color_filter_dsc_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_color_filter_dsc_t *value = (const lv_color_filter_dsc_t *)mp_write_ptr_lv_color_filter_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_color_filter_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_color_filter_dsc_mpobj, 2, mp_lv_style_set_color_filter_dsc, lv_style_set_color_filter_dsc);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_color_filter_opa_mpobj, 2, mp_lv_style_set_bg_opa, lv_style_set_color_filter_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_anim(lv_style_t *style, const lv_anim_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_anim_t *value = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_anim_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_anim_mpobj, 2, mp_lv_style_set_anim, lv_style_set_anim);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_anim_duration(lv_style_t *style, uint32_t value)
 */

STATIC mp_obj_t mp_lv_style_set_anim_duration(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint32_t value = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint32_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_anim_duration_mpobj, 2, mp_lv_style_set_anim_duration, lv_style_set_anim_duration);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_transition(lv_style_t *style, const lv_style_transition_dsc_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_style_transition_dsc_t *value = (const lv_style_transition_dsc_t *)mp_write_ptr_lv_style_transition_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_style_transition_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_mpobj, 2, mp_lv_style_set_transition, lv_style_set_transition);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_blend_mode(lv_style_t *style, lv_blend_mode_t value)
 */

STATIC mp_obj_t mp_lv_style_set_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_blend_mode_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_blend_mode_mpobj, 2, mp_lv_style_set_blend_mode, lv_style_set_blend_mode);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_layout(lv_style_t *style, uint16_t value)
 */

STATIC mp_obj_t mp_lv_style_set_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint16_t value = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint16_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_layout_mpobj, 2, mp_lv_style_set_layout, lv_style_set_layout);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_base_dir(lv_style_t *style, lv_base_dir_t value)
 */

STATIC mp_obj_t mp_lv_style_set_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_base_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_base_dir_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_base_dir_mpobj, 2, mp_lv_style_set_base_dir, lv_style_set_base_dir);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_flow(lv_style_t *style, lv_flex_flow_t value)
 */

STATIC mp_obj_t mp_lv_style_set_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_flex_flow_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_flex_flow_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_flow_mpobj, 2, mp_lv_style_set_flex_flow, lv_style_set_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_main_place(lv_style_t *style, lv_flex_align_t value)
 */

STATIC mp_obj_t mp_lv_style_set_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_flex_align_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_flex_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_main_place_mpobj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_main_place);
    
/* Reusing lv_style_set_flex_main_place for lv_style_set_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_cross_place_mpobj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_cross_place);
    
/* Reusing lv_style_set_flex_main_place for lv_style_set_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_track_place_mpobj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_track_place);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_grow(lv_style_t *style, uint8_t value)
 */

STATIC mp_obj_t mp_lv_style_set_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint8_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint8_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_grow_mpobj, 2, mp_lv_style_set_flex_grow, lv_style_set_flex_grow);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_grid_column_dsc_array(lv_style_t *style, const int32_t *value)
 */

STATIC mp_obj_t mp_lv_style_set_grid_column_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const int32_t *value = (const int32_t *)mp_array_to_i32ptr(mp_args[1]);
    ((void (*)(lv_style_t *, const int32_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_column_dsc_array_mpobj, 2, mp_lv_style_set_grid_column_dsc_array, lv_style_set_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_grid_column_align(lv_style_t *style, lv_grid_align_t value)
 */

STATIC mp_obj_t mp_lv_style_set_grid_column_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_grid_align_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_grid_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_column_align_mpobj, 2, mp_lv_style_set_grid_column_align, lv_style_set_grid_column_align);
    
/* Reusing lv_style_set_grid_column_dsc_array for lv_style_set_grid_row_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_row_dsc_array_mpobj, 2, mp_lv_style_set_grid_column_dsc_array, lv_style_set_grid_row_dsc_array);
    
/* Reusing lv_style_set_grid_column_align for lv_style_set_grid_row_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_row_align_mpobj, 2, mp_lv_style_set_grid_column_align, lv_style_set_grid_row_align);
    
/* Reusing lv_style_set_pad_all for lv_style_set_grid_cell_column_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_column_pos_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_grid_cell_column_pos);
    
/* Reusing lv_style_set_grid_column_align for lv_style_set_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_x_align_mpobj, 2, mp_lv_style_set_grid_column_align, lv_style_set_grid_cell_x_align);
    
/* Reusing lv_style_set_pad_all for lv_style_set_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_column_span_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_grid_cell_column_span);
    
/* Reusing lv_style_set_pad_all for lv_style_set_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_row_pos_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_grid_cell_row_pos);
    
/* Reusing lv_style_set_grid_column_align for lv_style_set_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_y_align_mpobj, 2, mp_lv_style_set_grid_column_align, lv_style_set_grid_cell_y_align);
    
/* Reusing lv_style_set_pad_all for lv_style_set_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_row_span_mpobj, 2, mp_lv_style_set_pad_all, lv_style_set_grid_cell_row_span);
    

STATIC const mp_rom_map_elem_t mp_lv_style_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_t))) },
    { MP_ROM_QSTR(MP_QSTR_is_const), MP_ROM_PTR(&mp_lv_style_is_const_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_prop_inlined), MP_ROM_PTR(&mp_lv_style_get_prop_inlined_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_style_set_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_all), MP_ROM_PTR(&mp_lv_style_set_pad_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_hor), MP_ROM_PTR(&mp_lv_style_set_pad_hor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_ver), MP_ROM_PTR(&mp_lv_style_set_pad_ver_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_gap), MP_ROM_PTR(&mp_lv_style_set_pad_gap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_scale), MP_ROM_PTR(&mp_lv_style_set_transform_scale_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_style_reset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_prop), MP_ROM_PTR(&mp_lv_style_remove_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_prop), MP_ROM_PTR(&mp_lv_style_set_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_prop), MP_ROM_PTR(&mp_lv_style_get_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_empty), MP_ROM_PTR(&mp_lv_style_is_empty_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_style_set_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_min_width), MP_ROM_PTR(&mp_lv_style_set_min_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_width), MP_ROM_PTR(&mp_lv_style_set_max_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_style_set_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_min_height), MP_ROM_PTR(&mp_lv_style_set_min_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_height), MP_ROM_PTR(&mp_lv_style_set_max_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_length), MP_ROM_PTR(&mp_lv_style_set_length_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_x), MP_ROM_PTR(&mp_lv_style_set_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_y), MP_ROM_PTR(&mp_lv_style_set_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_style_set_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_width), MP_ROM_PTR(&mp_lv_style_set_transform_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_height), MP_ROM_PTR(&mp_lv_style_set_transform_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_translate_x), MP_ROM_PTR(&mp_lv_style_set_translate_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_translate_y), MP_ROM_PTR(&mp_lv_style_set_translate_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_scale_x), MP_ROM_PTR(&mp_lv_style_set_transform_scale_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_scale_y), MP_ROM_PTR(&mp_lv_style_set_transform_scale_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_rotation), MP_ROM_PTR(&mp_lv_style_set_transform_rotation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_pivot_x), MP_ROM_PTR(&mp_lv_style_set_transform_pivot_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_pivot_y), MP_ROM_PTR(&mp_lv_style_set_transform_pivot_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_skew_x), MP_ROM_PTR(&mp_lv_style_set_transform_skew_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_skew_y), MP_ROM_PTR(&mp_lv_style_set_transform_skew_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_top), MP_ROM_PTR(&mp_lv_style_set_pad_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_bottom), MP_ROM_PTR(&mp_lv_style_set_pad_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_left), MP_ROM_PTR(&mp_lv_style_set_pad_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_right), MP_ROM_PTR(&mp_lv_style_set_pad_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_row), MP_ROM_PTR(&mp_lv_style_set_pad_row_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_column), MP_ROM_PTR(&mp_lv_style_set_pad_column_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_top), MP_ROM_PTR(&mp_lv_style_set_margin_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_bottom), MP_ROM_PTR(&mp_lv_style_set_margin_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_left), MP_ROM_PTR(&mp_lv_style_set_margin_left_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_right), MP_ROM_PTR(&mp_lv_style_set_margin_right_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_color), MP_ROM_PTR(&mp_lv_style_set_bg_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_opa), MP_ROM_PTR(&mp_lv_style_set_bg_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_color), MP_ROM_PTR(&mp_lv_style_set_bg_grad_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_dir), MP_ROM_PTR(&mp_lv_style_set_bg_grad_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_main_stop), MP_ROM_PTR(&mp_lv_style_set_bg_main_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_stop), MP_ROM_PTR(&mp_lv_style_set_bg_grad_stop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_main_opa), MP_ROM_PTR(&mp_lv_style_set_bg_main_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_opa), MP_ROM_PTR(&mp_lv_style_set_bg_grad_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad), MP_ROM_PTR(&mp_lv_style_set_bg_grad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image_src), MP_ROM_PTR(&mp_lv_style_set_bg_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image_opa), MP_ROM_PTR(&mp_lv_style_set_bg_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image_recolor), MP_ROM_PTR(&mp_lv_style_set_bg_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_bg_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image_tiled), MP_ROM_PTR(&mp_lv_style_set_bg_image_tiled_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_color), MP_ROM_PTR(&mp_lv_style_set_border_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_opa), MP_ROM_PTR(&mp_lv_style_set_border_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_width), MP_ROM_PTR(&mp_lv_style_set_border_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_side), MP_ROM_PTR(&mp_lv_style_set_border_side_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_post), MP_ROM_PTR(&mp_lv_style_set_border_post_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_width), MP_ROM_PTR(&mp_lv_style_set_outline_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_color), MP_ROM_PTR(&mp_lv_style_set_outline_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_opa), MP_ROM_PTR(&mp_lv_style_set_outline_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_pad), MP_ROM_PTR(&mp_lv_style_set_outline_pad_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_width), MP_ROM_PTR(&mp_lv_style_set_shadow_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_offset_x), MP_ROM_PTR(&mp_lv_style_set_shadow_offset_x_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_offset_y), MP_ROM_PTR(&mp_lv_style_set_shadow_offset_y_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_spread), MP_ROM_PTR(&mp_lv_style_set_shadow_spread_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_color), MP_ROM_PTR(&mp_lv_style_set_shadow_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_opa), MP_ROM_PTR(&mp_lv_style_set_shadow_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_opa), MP_ROM_PTR(&mp_lv_style_set_image_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_recolor), MP_ROM_PTR(&mp_lv_style_set_image_recolor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_image_recolor_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_width), MP_ROM_PTR(&mp_lv_style_set_line_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_width), MP_ROM_PTR(&mp_lv_style_set_line_dash_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_gap), MP_ROM_PTR(&mp_lv_style_set_line_dash_gap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_rounded), MP_ROM_PTR(&mp_lv_style_set_line_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_color), MP_ROM_PTR(&mp_lv_style_set_line_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_opa), MP_ROM_PTR(&mp_lv_style_set_line_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_width), MP_ROM_PTR(&mp_lv_style_set_arc_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_rounded), MP_ROM_PTR(&mp_lv_style_set_arc_rounded_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_color), MP_ROM_PTR(&mp_lv_style_set_arc_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_opa), MP_ROM_PTR(&mp_lv_style_set_arc_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_image_src), MP_ROM_PTR(&mp_lv_style_set_arc_image_src_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_color), MP_ROM_PTR(&mp_lv_style_set_text_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_opa), MP_ROM_PTR(&mp_lv_style_set_text_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_font), MP_ROM_PTR(&mp_lv_style_set_text_font_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_letter_space), MP_ROM_PTR(&mp_lv_style_set_text_letter_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_line_space), MP_ROM_PTR(&mp_lv_style_set_text_line_space_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_decor), MP_ROM_PTR(&mp_lv_style_set_text_decor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_align), MP_ROM_PTR(&mp_lv_style_set_text_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_radius), MP_ROM_PTR(&mp_lv_style_set_radius_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_clip_corner), MP_ROM_PTR(&mp_lv_style_set_clip_corner_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_opa), MP_ROM_PTR(&mp_lv_style_set_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_opa_layered), MP_ROM_PTR(&mp_lv_style_set_opa_layered_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_filter_dsc), MP_ROM_PTR(&mp_lv_style_set_color_filter_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_filter_opa), MP_ROM_PTR(&mp_lv_style_set_color_filter_opa_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim), MP_ROM_PTR(&mp_lv_style_set_anim_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_duration), MP_ROM_PTR(&mp_lv_style_set_anim_duration_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition), MP_ROM_PTR(&mp_lv_style_set_transition_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_blend_mode), MP_ROM_PTR(&mp_lv_style_set_blend_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_style_set_layout_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_base_dir), MP_ROM_PTR(&mp_lv_style_set_base_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_flow), MP_ROM_PTR(&mp_lv_style_set_flex_flow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_main_place), MP_ROM_PTR(&mp_lv_style_set_flex_main_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_cross_place), MP_ROM_PTR(&mp_lv_style_set_flex_cross_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_track_place), MP_ROM_PTR(&mp_lv_style_set_flex_track_place_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_grow), MP_ROM_PTR(&mp_lv_style_set_flex_grow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_style_set_grid_column_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_column_align), MP_ROM_PTR(&mp_lv_style_set_grid_column_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_style_set_grid_row_dsc_array_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_row_align), MP_ROM_PTR(&mp_lv_style_set_grid_row_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_style_set_grid_cell_column_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_x_align), MP_ROM_PTR(&mp_lv_style_set_grid_cell_x_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_column_span), MP_ROM_PTR(&mp_lv_style_set_grid_cell_column_span_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_style_set_grid_cell_row_pos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_y_align), MP_ROM_PTR(&mp_lv_style_set_grid_cell_y_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_row_span), MP_ROM_PTR(&mp_lv_style_set_grid_cell_row_span_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_t_locals_dict, mp_lv_style_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_style_value_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_value_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_value_t_locals_dict, mp_lv_style_value_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_rect_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_rect_dsc_t *dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_rect_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_rect_dsc_init_mpobj, 1, mp_lv_draw_rect_dsc_init, lv_draw_rect_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_rect_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_rect_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_rect_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_rect_dsc_t_locals_dict, mp_lv_draw_rect_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_dsc_base_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_dsc_base_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_dsc_base_t_locals_dict, mp_lv_draw_dsc_base_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_layer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_layer_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_layer_t_locals_dict, mp_lv_layer_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * uint32_t lv_draw_get_dependent_count(lv_draw_task_t *t_check)
 */

STATIC mp_obj_t mp_lv_draw_get_dependent_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_task_t *t_check = mp_write_ptr_lv_draw_task_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_draw_task_t *))lv_func_ptr)(t_check);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_get_dependent_count_mpobj, 1, mp_lv_draw_get_dependent_count, lv_draw_get_dependent_count);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_task_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_task_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_dependent_count), MP_ROM_PTR(&mp_lv_draw_get_dependent_count_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_task_t_locals_dict, mp_lv_draw_task_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_label_dsc_init(lv_draw_label_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_label_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_label_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_label_dsc_init_mpobj, 1, mp_lv_draw_label_dsc_init, lv_draw_label_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_label_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_label_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_dsc_t_locals_dict, mp_lv_draw_label_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_label_hint_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_hint_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_hint_t_locals_dict, mp_lv_draw_label_hint_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_image_dsc_init(lv_draw_image_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_image_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_image_dsc_t *dsc = mp_write_ptr_lv_draw_image_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_image_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_image_dsc_init_mpobj, 1, mp_lv_draw_image_dsc_init, lv_draw_image_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_image_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_image_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_image_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_image_dsc_t_locals_dict, mp_lv_draw_image_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_image_sup_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_image_sup_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_image_sup_t_locals_dict, mp_lv_draw_image_sup_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static bool lv_color32_eq(lv_color32_t c1, lv_color32_t c2)
 */

STATIC mp_obj_t mp_lv_color32_eq(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color32_t c1 = mp_write_lv_color32_t(mp_args[0]);
    lv_color32_t c2 = mp_write_lv_color32_t(mp_args[1]);
    bool _res = ((bool (*)(lv_color32_t, lv_color32_t))lv_func_ptr)(c1, c2);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color32_eq_mpobj, 2, mp_lv_color32_eq, lv_color32_eq);
    

/*
 * lvgl extension definition for:
 * inline static void lv_color_premultiply(lv_color32_t *c)
 */

STATIC mp_obj_t mp_lv_color_premultiply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color32_t *c = mp_write_ptr_lv_color32_t(mp_args[0]);
    ((void (*)(lv_color32_t *))lv_func_ptr)(c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_premultiply_mpobj, 1, mp_lv_color_premultiply, lv_color_premultiply);
    

/*
 * lvgl extension definition for:
 * inline static lv_color32_t lv_color_mix32(lv_color32_t fg, lv_color32_t bg)
 */

STATIC mp_obj_t mp_lv_color_mix32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color32_t fg = mp_write_lv_color32_t(mp_args[0]);
    lv_color32_t bg = mp_write_lv_color32_t(mp_args[1]);
    lv_color32_t _res = ((lv_color32_t (*)(lv_color32_t, lv_color32_t))lv_func_ptr)(fg, bg);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix32_mpobj, 2, mp_lv_color_mix32, lv_color_mix32);
    

STATIC const mp_rom_map_elem_t mp_lv_color32_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color32_t))) },
    { MP_ROM_QSTR(MP_QSTR_eq), MP_ROM_PTR(&mp_lv_color32_eq_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_premultiply), MP_ROM_PTR(&mp_lv_color_premultiply_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix32), MP_ROM_PTR(&mp_lv_color_mix32_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color32_t_locals_dict, mp_lv_color32_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_line_dsc_init(lv_draw_line_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_line_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_line_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_line_dsc_init_mpobj, 1, mp_lv_draw_line_dsc_init, lv_draw_line_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_line_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_line_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_line_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_line_dsc_t_locals_dict, mp_lv_draw_line_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_point_t lv_point_from_precise(const lv_point_precise_t *p)
 */

STATIC mp_obj_t mp_lv_point_from_precise(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_precise_t *p = (const lv_point_precise_t *)mp_write_ptr_lv_point_precise_t(mp_args[0]);
    lv_point_t _res = ((lv_point_t (*)(const lv_point_precise_t *))lv_func_ptr)(p);
    return mp_read_lv_point_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_from_precise_mpobj, 1, mp_lv_point_from_precise, lv_point_from_precise);
    

/*
 * lvgl extension definition for:
 * inline static void lv_point_precise_set(lv_point_precise_t *p, lv_value_precise_t x, lv_value_precise_t y)
 */

STATIC mp_obj_t mp_lv_point_precise_set(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_precise_t *p = mp_write_ptr_lv_point_precise_t(mp_args[0]);
    lv_value_precise_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_value_precise_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_point_precise_t *, lv_value_precise_t, lv_value_precise_t))lv_func_ptr)(p, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_precise_set_mpobj, 3, mp_lv_point_precise_set, lv_point_precise_set);
    

/*
 * lvgl extension definition for:
 * inline static void lv_point_precise_swap(lv_point_precise_t *p1, lv_point_precise_t *p2)
 */

STATIC mp_obj_t mp_lv_point_precise_swap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_precise_t *p1 = mp_write_ptr_lv_point_precise_t(mp_args[0]);
    lv_point_precise_t *p2 = mp_write_ptr_lv_point_precise_t(mp_args[1]);
    ((void (*)(lv_point_precise_t *, lv_point_precise_t *))lv_func_ptr)(p1, p2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_precise_swap_mpobj, 2, mp_lv_point_precise_swap, lv_point_precise_swap);
    

STATIC const mp_rom_map_elem_t mp_lv_point_precise_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_point_precise_t))) },
    { MP_ROM_QSTR(MP_QSTR_from_precise), MP_ROM_PTR(&mp_lv_point_from_precise_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_lv_point_precise_set_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_swap), MP_ROM_PTR(&mp_lv_point_precise_swap_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_point_precise_t_locals_dict, mp_lv_point_precise_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_arc_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_arc_dsc_t *dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_arc_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_arc_dsc_init_mpobj, 1, mp_lv_draw_arc_dsc_init, lv_draw_arc_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_arc_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_arc_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_arc_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_arc_dsc_t_locals_dict, mp_lv_draw_arc_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_event_cb_t lv_event_dsc_get_cb(lv_event_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_event_dsc_get_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_dsc_t *dsc = mp_write_ptr_lv_event_dsc_t(mp_args[0]);
    lv_event_cb_t _res = ((lv_event_cb_t (*)(lv_event_dsc_t *))lv_func_ptr)(dsc);
    return mp_lv_funcptr_lv_event_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_dsc_get_cb_mpobj, 1, mp_lv_event_dsc_get_cb, lv_event_dsc_get_cb);
    

/*
 * lvgl extension definition for:
 * void *lv_event_dsc_get_user_data(lv_event_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_event_dsc_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_dsc_t *dsc = mp_write_ptr_lv_event_dsc_t(mp_args[0]);
    void * _res = ((void *(*)(lv_event_dsc_t *))lv_func_ptr)(dsc);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_dsc_get_user_data_mpobj, 1, mp_lv_event_dsc_get_user_data, lv_event_dsc_get_user_data);
    

STATIC const mp_rom_map_elem_t mp_lv_event_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_event_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_cb), MP_ROM_PTR(&mp_lv_event_dsc_get_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_event_dsc_get_user_data_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_event_dsc_t_locals_dict, mp_lv_event_dsc_t_locals_dict_table);
        
/* Reusing funcptr_lv_group_focus_cb_t for lv_group_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_delete_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, lv_group_delete);
    
/* Reusing funcptr_lv_group_focus_cb_t for lv_group_set_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_default_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, lv_group_set_default);
    

/*
 * lvgl extension definition for:
 * void lv_group_add_obj(lv_group_t *group, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_group_add_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_group_t *, lv_obj_t *))lv_func_ptr)(group, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_add_obj_mpobj, 2, mp_lv_group_add_obj, lv_group_add_obj);
    
/* Reusing funcptr_lv_group_focus_cb_t for lv_group_remove_all_objs */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_all_objs_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, lv_group_remove_all_objs);
    
/* Reusing funcptr_lv_group_focus_cb_t for lv_group_focus_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_next_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, lv_group_focus_next);
    
/* Reusing funcptr_lv_group_focus_cb_t for lv_group_focus_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_prev_mpobj, 1, mp_funcptr_lv_group_focus_cb_t, lv_group_focus_prev);
    
/* Reusing funcptr_lv_group_edge_cb_t for lv_group_focus_freeze */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_freeze_mpobj, 2, mp_funcptr_lv_group_edge_cb_t, lv_group_focus_freeze);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_group_send_data(lv_group_t *group, uint32_t c)
 */

STATIC mp_obj_t mp_lv_group_send_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_group_t *, uint32_t))lv_func_ptr)(group, c);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_send_data_mpobj, 2, mp_lv_group_send_data, lv_group_send_data);
    

/*
 * Callback function lv_group_t_focus_cb
 * void lv_group_focus_cb_t(lv_group_t *)
 */

GENMPY_UNUSED STATIC void lv_group_t_focus_cb_callback(lv_group_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_group_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_group_t_focus_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_group_set_focus_cb(lv_group_t *group, lv_group_focus_cb_t focus_cb)
 */

STATIC mp_obj_t mp_lv_group_set_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    void *focus_cb = mp_lv_callback(mp_args[1], &lv_group_t_focus_cb_callback, MP_QSTR_lv_group_t_focus_cb, &group->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_group_t *, lv_group_focus_cb_t))lv_func_ptr)(group, focus_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_focus_cb_mpobj, 2, mp_lv_group_set_focus_cb, lv_group_set_focus_cb);
    

/*
 * Callback function lv_group_t_edge_cb
 * void lv_group_edge_cb_t(lv_group_t *, bool)
 */

GENMPY_UNUSED STATIC void lv_group_t_edge_cb_callback(lv_group_t *arg0, bool arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_group_t((void*)arg0);
    mp_args[1] = convert_to_bool(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_group_t_edge_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_group_set_edge_cb(lv_group_t *group, lv_group_edge_cb_t edge_cb)
 */

STATIC mp_obj_t mp_lv_group_set_edge_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    void *edge_cb = mp_lv_callback(mp_args[1], &lv_group_t_edge_cb_callback, MP_QSTR_lv_group_t_edge_cb, &group->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_group_t *, lv_group_edge_cb_t))lv_func_ptr)(group, edge_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_edge_cb_mpobj, 2, mp_lv_group_set_edge_cb, lv_group_set_edge_cb);
    

/*
 * lvgl extension definition for:
 * void lv_group_set_refocus_policy(lv_group_t *group, lv_group_refocus_policy_t policy)
 */

STATIC mp_obj_t mp_lv_group_set_refocus_policy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_refocus_policy_t policy = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_group_t *, lv_group_refocus_policy_t))lv_func_ptr)(group, policy);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_refocus_policy_mpobj, 2, mp_lv_group_set_refocus_policy, lv_group_set_refocus_policy);
    
/* Reusing funcptr_lv_group_edge_cb_t for lv_group_set_editing */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_editing_mpobj, 2, mp_funcptr_lv_group_edge_cb_t, lv_group_set_editing);
    
/* Reusing funcptr_lv_group_edge_cb_t for lv_group_set_wrap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_wrap_mpobj, 2, mp_funcptr_lv_group_edge_cb_t, lv_group_set_wrap);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_group_get_focused(const lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_focused(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = (const lv_group_t *)mp_write_ptr_lv_group_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_group_t *))lv_func_ptr)(group);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focused_mpobj, 1, mp_lv_group_get_focused, lv_group_get_focused);
    

/*
 * lvgl extension definition for:
 * lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = (const lv_group_t *)mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_focus_cb_t _res = ((lv_group_focus_cb_t (*)(const lv_group_t *))lv_func_ptr)(group);
    return mp_lv_funcptr_lv_group_focus_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focus_cb_mpobj, 1, mp_lv_group_get_focus_cb, lv_group_get_focus_cb);
    

/*
 * lvgl extension definition for:
 * lv_group_edge_cb_t lv_group_get_edge_cb(const lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_edge_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = (const lv_group_t *)mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_edge_cb_t _res = ((lv_group_edge_cb_t (*)(const lv_group_t *))lv_func_ptr)(group);
    return mp_lv_funcptr_lv_group_edge_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_edge_cb_mpobj, 1, mp_lv_group_get_edge_cb, lv_group_get_edge_cb);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_editing(const lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_editing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = (const lv_group_t *)mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_editing_mpobj, 1, mp_lv_group_get_editing, lv_group_get_editing);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_wrap(lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_wrap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_wrap_mpobj, 1, mp_lv_group_get_wrap, lv_group_get_wrap);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_group_get_obj_count(lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_group_get_obj_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_group_t *))lv_func_ptr)(group);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_obj_count_mpobj, 1, mp_lv_group_get_obj_count, lv_group_get_obj_count);
    

STATIC const mp_rom_map_elem_t mp_lv_group_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_group_t))) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_group_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_default), MP_ROM_PTR(&mp_lv_group_set_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_obj), MP_ROM_PTR(&mp_lv_group_add_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_all_objs), MP_ROM_PTR(&mp_lv_group_remove_all_objs_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_focus_next), MP_ROM_PTR(&mp_lv_group_focus_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_focus_prev), MP_ROM_PTR(&mp_lv_group_focus_prev_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_focus_freeze), MP_ROM_PTR(&mp_lv_group_focus_freeze_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_send_data), MP_ROM_PTR(&mp_lv_group_send_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_focus_cb), MP_ROM_PTR(&mp_lv_group_set_focus_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_edge_cb), MP_ROM_PTR(&mp_lv_group_set_edge_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_refocus_policy), MP_ROM_PTR(&mp_lv_group_set_refocus_policy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_editing), MP_ROM_PTR(&mp_lv_group_set_editing_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_wrap), MP_ROM_PTR(&mp_lv_group_set_wrap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_focused), MP_ROM_PTR(&mp_lv_group_get_focused_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_focus_cb), MP_ROM_PTR(&mp_lv_group_get_focus_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_cb), MP_ROM_PTR(&mp_lv_group_get_edge_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_editing), MP_ROM_PTR(&mp_lv_group_get_editing_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_wrap), MP_ROM_PTR(&mp_lv_group_get_wrap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_obj_count), MP_ROM_PTR(&mp_lv_group_get_obj_count_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_group_t_locals_dict, mp_lv_group_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_ll_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ll_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ll_t_locals_dict, mp_lv_ll_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_obj_t *lv_observer_get_target_obj(lv_observer_t *observer)
 */

STATIC mp_obj_t mp_lv_observer_get_target_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_observer_t *observer = mp_write_ptr_lv_observer_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_observer_t *))lv_func_ptr)(observer);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_observer_get_target_obj_mpobj, 1, mp_lv_observer_get_target_obj, lv_observer_get_target_obj);
    

/*
 * lvgl extension definition for:
 * void lv_observer_remove(lv_observer_t *observer)
 */

STATIC mp_obj_t mp_lv_observer_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_observer_t *observer = mp_write_ptr_lv_observer_t(mp_args[0]);
    ((void (*)(lv_observer_t *))lv_func_ptr)(observer);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_observer_remove_mpobj, 1, mp_lv_observer_remove, lv_observer_remove);
    

/*
 * lvgl extension definition for:
 * void *lv_observer_get_target(lv_observer_t *observer)
 */

STATIC mp_obj_t mp_lv_observer_get_target(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_observer_t *observer = mp_write_ptr_lv_observer_t(mp_args[0]);
    void * _res = ((void *(*)(lv_observer_t *))lv_func_ptr)(observer);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_observer_get_target_mpobj, 1, mp_lv_observer_get_target, lv_observer_get_target);
    

STATIC const mp_rom_map_elem_t mp_lv_observer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_observer_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_target_obj), MP_ROM_PTR(&mp_lv_observer_get_target_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_observer_remove_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_target), MP_ROM_PTR(&mp_lv_observer_get_target_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_observer_t_locals_dict, mp_lv_observer_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_subject_init_int(lv_subject_t *subject, int32_t value)
 */

STATIC mp_obj_t mp_lv_subject_init_int(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_subject_t *, int32_t))lv_func_ptr)(subject, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_init_int_mpobj, 2, mp_lv_subject_init_int, lv_subject_init_int);
    
/* Reusing lv_subject_init_int for lv_subject_set_int */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_set_int_mpobj, 2, mp_lv_subject_init_int, lv_subject_set_int);
    

/*
 * lvgl extension definition for:
 * int32_t lv_subject_get_int(lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_subject_get_int(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_subject_t *))lv_func_ptr)(subject);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_int_mpobj, 1, mp_lv_subject_get_int, lv_subject_get_int);
    
/* Reusing lv_subject_get_int for lv_subject_get_previous_int */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_previous_int_mpobj, 1, mp_lv_subject_get_int, lv_subject_get_previous_int);
    

/*
 * lvgl extension definition for:
 * void lv_subject_init_string(lv_subject_t *subject, char *buf, char *prev_buf, size_t size, const char *value)
 */

STATIC mp_obj_t mp_lv_subject_init_string(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    char *buf = (char*)convert_from_str(mp_args[1]);
    char *prev_buf = (char*)convert_from_str(mp_args[2]);
    size_t size = (size_t)mp_obj_get_int(mp_args[3]);
    const char *value = (const char *)(char*)convert_from_str(mp_args[4]);
    ((void (*)(lv_subject_t *, char *, char *, size_t, const char *))lv_func_ptr)(subject, buf, prev_buf, size, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_init_string_mpobj, 5, mp_lv_subject_init_string, lv_subject_init_string);
    

/*
 * lvgl extension definition for:
 * void lv_subject_copy_string(lv_subject_t *subject, const char *buf)
 */

STATIC mp_obj_t mp_lv_subject_copy_string(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    const char *buf = (const char *)(char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_subject_t *, const char *))lv_func_ptr)(subject, buf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_copy_string_mpobj, 2, mp_lv_subject_copy_string, lv_subject_copy_string);
    

/*
 * lvgl extension definition for:
 * const char *lv_subject_get_string(lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_subject_get_string(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    const char * _res = ((const char *(*)(lv_subject_t *))lv_func_ptr)(subject);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_string_mpobj, 1, mp_lv_subject_get_string, lv_subject_get_string);
    
/* Reusing lv_subject_get_string for lv_subject_get_previous_string */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_previous_string_mpobj, 1, mp_lv_subject_get_string, lv_subject_get_previous_string);
    

/*
 * lvgl extension definition for:
 * void lv_subject_init_pointer(lv_subject_t *subject, void *value)
 */

STATIC mp_obj_t mp_lv_subject_init_pointer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    void *value = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_subject_t *, void *))lv_func_ptr)(subject, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_init_pointer_mpobj, 2, mp_lv_subject_init_pointer, lv_subject_init_pointer);
    
/* Reusing lv_subject_init_pointer for lv_subject_set_pointer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_set_pointer_mpobj, 2, mp_lv_subject_init_pointer, lv_subject_set_pointer);
    

/*
 * lvgl extension definition for:
 * const void *lv_subject_get_pointer(lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_subject_get_pointer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    const void * _res = ((const void *(*)(lv_subject_t *))lv_func_ptr)(subject);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_pointer_mpobj, 1, mp_lv_subject_get_pointer, lv_subject_get_pointer);
    
/* Reusing lv_subject_get_pointer for lv_subject_get_previous_pointer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_previous_pointer_mpobj, 1, mp_lv_subject_get_pointer, lv_subject_get_previous_pointer);
    

/*
 * lvgl extension definition for:
 * void lv_subject_init_color(lv_subject_t *subject, lv_color_t color)
 */

STATIC mp_obj_t mp_lv_subject_init_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_color_t color = mp_write_lv_color_t(mp_args[1]);
    ((void (*)(lv_subject_t *, lv_color_t))lv_func_ptr)(subject, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_init_color_mpobj, 2, mp_lv_subject_init_color, lv_subject_init_color);
    
/* Reusing lv_subject_init_color for lv_subject_set_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_set_color_mpobj, 2, mp_lv_subject_init_color, lv_subject_set_color);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_subject_get_color(lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_subject_get_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_subject_t *))lv_func_ptr)(subject);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_color_mpobj, 1, mp_lv_subject_get_color, lv_subject_get_color);
    
/* Reusing lv_subject_get_color for lv_subject_get_previous_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_previous_color_mpobj, 1, mp_lv_subject_get_color, lv_subject_get_previous_color);
    

/*
 * Array convertors for lv_subject_t *[]
 */

GENMPY_UNUSED STATIC lv_subject_t * *mp_arr_to_lv_subject_t_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_subject_t * *lv_arr = (lv_subject_t **)m_malloc(len * sizeof(lv_subject_t *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_ptr_lv_subject_t(item);
    }
    return (lv_subject_t * *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_subject_t_ptr____(lv_subject_t * *arr)
{
    return ptr_to_mp((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_subject_init_group(lv_subject_t *subject, lv_subject_t *list[], uint32_t list_len)
 */

STATIC mp_obj_t mp_lv_subject_init_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_subject_t **list = mp_arr_to_lv_subject_t_ptr____(mp_args[1]);
    uint32_t list_len = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_subject_t *, lv_subject_t *[], uint32_t))lv_func_ptr)(subject, list, list_len);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_init_group_mpobj, 3, mp_lv_subject_init_group, lv_subject_init_group);
    

/*
 * lvgl extension definition for:
 * lv_subject_t *lv_subject_get_group_element(lv_subject_t *subject, int32_t index)
 */

STATIC mp_obj_t mp_lv_subject_get_group_element(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    int32_t index = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_subject_t * _res = ((lv_subject_t *(*)(lv_subject_t *, int32_t))lv_func_ptr)(subject, index);
    return mp_read_ptr_lv_subject_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_get_group_element_mpobj, 2, mp_lv_subject_get_group_element, lv_subject_get_group_element);
    

/*
 * Callback function lv_subject_add_observer_observer_cb
 * void lv_observer_cb_t(lv_observer_t *observer, lv_subject_t *subject)
 */

GENMPY_UNUSED STATIC void lv_subject_add_observer_observer_cb_callback(lv_observer_t *arg0, lv_subject_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_observer_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_subject_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_subject_add_observer_observer_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_observer_t *lv_subject_add_observer(lv_subject_t *subject, lv_observer_cb_t observer_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_subject_add_observer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *observer_cb = mp_lv_callback(mp_args[1], &lv_subject_add_observer_observer_cb_callback, MP_QSTR_lv_subject_add_observer_observer_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_subject_t *, lv_observer_cb_t, void *))lv_func_ptr)(subject, observer_cb, user_data);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_add_observer_mpobj, 3, mp_lv_subject_add_observer, lv_subject_add_observer);
    

/*
 * Callback function lv_subject_add_observer_obj_observer_cb
 * void lv_observer_cb_t(lv_observer_t *observer, lv_subject_t *subject)
 */

GENMPY_UNUSED STATIC void lv_subject_add_observer_obj_observer_cb_callback(lv_observer_t *arg0, lv_subject_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_observer_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_subject_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_subject_add_observer_obj_observer_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_observer_t *lv_subject_add_observer_obj(lv_subject_t *subject, lv_observer_cb_t observer_cb, lv_obj_t *obj, void *user_data)
 */

STATIC mp_obj_t mp_lv_subject_add_observer_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *observer_cb = mp_lv_callback(mp_args[1], &lv_subject_add_observer_obj_observer_cb_callback, MP_QSTR_lv_subject_add_observer_obj_observer_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_obj_t *obj = mp_to_lv(mp_args[2]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_subject_t *, lv_observer_cb_t, lv_obj_t *, void *))lv_func_ptr)(subject, observer_cb, obj, user_data);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_add_observer_obj_mpobj, 4, mp_lv_subject_add_observer_obj, lv_subject_add_observer_obj);
    

/*
 * Callback function lv_subject_add_observer_with_target_cb
 * void lv_observer_cb_t(lv_observer_t *observer, lv_subject_t *subject)
 */

GENMPY_UNUSED STATIC void lv_subject_add_observer_with_target_cb_callback(lv_observer_t *arg0, lv_subject_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_observer_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_subject_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_subject_add_observer_with_target_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_observer_t *lv_subject_add_observer_with_target(lv_subject_t *subject, lv_observer_cb_t cb, void *target, void *user_data)
 */

STATIC mp_obj_t mp_lv_subject_add_observer_with_target(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *cb = mp_lv_callback(mp_args[1], &lv_subject_add_observer_with_target_cb_callback, MP_QSTR_lv_subject_add_observer_with_target_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    void *target = mp_to_ptr(mp_args[2]);
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_observer_t * _res = ((lv_observer_t *(*)(lv_subject_t *, lv_observer_cb_t, void *, void *))lv_func_ptr)(subject, cb, target, user_data);
    return mp_read_ptr_lv_observer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_add_observer_with_target_mpobj, 4, mp_lv_subject_add_observer_with_target, lv_subject_add_observer_with_target);
    

/*
 * lvgl extension definition for:
 * void lv_subject_remove_all_obj(lv_subject_t *subject, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_subject_remove_all_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_subject_t *, lv_obj_t *))lv_func_ptr)(subject, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_remove_all_obj_mpobj, 2, mp_lv_subject_remove_all_obj, lv_subject_remove_all_obj);
    

/*
 * lvgl extension definition for:
 * void lv_subject_notify(lv_subject_t *subject)
 */

STATIC mp_obj_t mp_lv_subject_notify(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_subject_t *subject = mp_write_ptr_lv_subject_t(mp_args[0]);
    ((void (*)(lv_subject_t *))lv_func_ptr)(subject);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_subject_notify_mpobj, 1, mp_lv_subject_notify, lv_subject_notify);
    

STATIC const mp_rom_map_elem_t mp_lv_subject_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_subject_t))) },
    { MP_ROM_QSTR(MP_QSTR_init_int), MP_ROM_PTR(&mp_lv_subject_init_int_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_int), MP_ROM_PTR(&mp_lv_subject_set_int_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_int), MP_ROM_PTR(&mp_lv_subject_get_int_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_previous_int), MP_ROM_PTR(&mp_lv_subject_get_previous_int_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_string), MP_ROM_PTR(&mp_lv_subject_init_string_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_copy_string), MP_ROM_PTR(&mp_lv_subject_copy_string_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_string), MP_ROM_PTR(&mp_lv_subject_get_string_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_previous_string), MP_ROM_PTR(&mp_lv_subject_get_previous_string_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_pointer), MP_ROM_PTR(&mp_lv_subject_init_pointer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_pointer), MP_ROM_PTR(&mp_lv_subject_set_pointer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_pointer), MP_ROM_PTR(&mp_lv_subject_get_pointer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_previous_pointer), MP_ROM_PTR(&mp_lv_subject_get_previous_pointer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_color), MP_ROM_PTR(&mp_lv_subject_init_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_color), MP_ROM_PTR(&mp_lv_subject_set_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_color), MP_ROM_PTR(&mp_lv_subject_get_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_previous_color), MP_ROM_PTR(&mp_lv_subject_get_previous_color_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init_group), MP_ROM_PTR(&mp_lv_subject_init_group_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_group_element), MP_ROM_PTR(&mp_lv_subject_get_group_element_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_observer), MP_ROM_PTR(&mp_lv_subject_add_observer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_observer_obj), MP_ROM_PTR(&mp_lv_subject_add_observer_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_observer_with_target), MP_ROM_PTR(&mp_lv_subject_add_observer_with_target_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_all_obj), MP_ROM_PTR(&mp_lv_subject_remove_all_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_notify), MP_ROM_PTR(&mp_lv_subject_notify_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_subject_t_locals_dict, mp_lv_subject_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_subject_value_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_subject_value_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_subject_value_t_locals_dict, mp_lv_subject_value_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_image_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_image_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_image_buf_set_palette_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_image_buf_free_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_image_dsc_t_locals_dict, mp_lv_image_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_image_decoder_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_image_decoder_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_image_decoder_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_area), MP_ROM_PTR(&mp_lv_image_decoder_get_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_image_decoder_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_post_process), MP_ROM_PTR(&mp_lv_image_decoder_post_process_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_image_decoder_dsc_t_locals_dict, mp_lv_image_decoder_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_image_decoder_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_image_decoder_t))) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_image_decoder_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_image_decoder_get_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_info_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_info_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_open_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_open_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_get_area_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_get_area_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_close_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_close_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cache_free_cb), MP_ROM_PTR(&mp_lv_image_decoder_set_cache_free_cb_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_image_decoder_t_locals_dict, mp_lv_image_decoder_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_image_decoder_args_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_image_decoder_args_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_image_decoder_args_t_locals_dict, mp_lv_image_decoder_args_t_locals_dict_table);
        
/* Reusing funcptr_lv_cache_destroy_cb_t for lv_cache_destroy */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_destroy_mpobj, 2, mp_funcptr_lv_cache_destroy_cb_t, lv_cache_destroy);
    
/* Reusing funcptr_lv_cache_get_cb_t for lv_cache_acquire */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_acquire_mpobj, 3, mp_funcptr_lv_cache_get_cb_t, lv_cache_acquire);
    
/* Reusing funcptr_lv_cache_get_cb_t for lv_cache_acquire_or_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_acquire_or_create_mpobj, 3, mp_funcptr_lv_cache_get_cb_t, lv_cache_acquire_or_create);
    
/* Reusing funcptr_lv_cache_get_cb_t for lv_cache_add */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_add_mpobj, 3, mp_funcptr_lv_cache_get_cb_t, lv_cache_add);
    
/* Reusing funcptr_lv_cache_remove_cb_t for lv_cache_release */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_release_mpobj, 3, mp_funcptr_lv_cache_remove_cb_t, lv_cache_release);
    
/* Reusing funcptr_lv_cache_drop_cb_t for lv_cache_drop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_drop_mpobj, 3, mp_funcptr_lv_cache_drop_cb_t, lv_cache_drop);
    
/* Reusing funcptr_lv_cache_destroy_cb_t for lv_cache_drop_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_drop_all_mpobj, 2, mp_funcptr_lv_cache_destroy_cb_t, lv_cache_drop_all);
    

/*
 * lvgl extension definition for:
 * void lv_cache_set_max_size(lv_cache_t *cache, size_t max_size, void *user_data)
 */

STATIC mp_obj_t mp_lv_cache_set_max_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    size_t max_size = (size_t)mp_obj_get_int(mp_args[1]);
    lv_cache_t *cache = mp_write_ptr_lv_cache_t(mp_args[0]);
    ((void (*)(lv_cache_t *, size_t, void *))lv_func_ptr)(cache, max_size, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_set_max_size_mpobj, 3, mp_lv_cache_set_max_size, lv_cache_set_max_size);
    

/*
 * lvgl extension definition for:
 * size_t lv_cache_get_max_size(lv_cache_t *cache, void *user_data)
 */

STATIC mp_obj_t mp_lv_cache_get_max_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_cache_t *cache = mp_write_ptr_lv_cache_t(mp_args[0]);
    size_t _res = ((size_t (*)(lv_cache_t *, void *))lv_func_ptr)(cache, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_get_max_size_mpobj, 2, mp_lv_cache_get_max_size, lv_cache_get_max_size);
    
/* Reusing lv_cache_get_max_size for lv_cache_get_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_get_size_mpobj, 2, mp_lv_cache_get_max_size, lv_cache_get_size);
    
/* Reusing lv_cache_get_max_size for lv_cache_get_free_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_get_free_size_mpobj, 2, mp_lv_cache_get_max_size, lv_cache_get_free_size);
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_cache_compare_res_t lv_cache_compare_cb_t(const void *a, const void *b)
 * lv_cache_compare_cb_t compare_cb
 */
    

/*
 * lvgl extension definition for:
 * void lv_cache_set_compare_cb(lv_cache_t *cache, lv_cache_compare_cb_t compare_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_cache_set_compare_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    lv_cache_compare_cb_t compare_cb = mp_to_ptr(mp_args[1]);
    lv_cache_t *cache = mp_write_ptr_lv_cache_t(mp_args[0]);
    ((void (*)(lv_cache_t *, lv_cache_compare_cb_t, void *))lv_func_ptr)(cache, compare_cb, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_set_compare_cb_mpobj, 3, mp_lv_cache_set_compare_cb, lv_cache_set_compare_cb);
    

/*
 * Callback function lv_cache_set_create_cb_alloc_cb
 * bool lv_cache_create_cb_t(void *node, void *user_data)
 */

GENMPY_UNUSED STATIC bool lv_cache_set_create_cb_alloc_cb_callback(void *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg1);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_cache_set_create_cb_alloc_cb)) , 2, 0, mp_args);
    _nesting--;
    return mp_obj_is_true(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_cache_set_create_cb(lv_cache_t *cache, lv_cache_create_cb_t alloc_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_cache_set_create_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *alloc_cb = mp_lv_callback(mp_args[1], &lv_cache_set_create_cb_alloc_cb_callback, MP_QSTR_lv_cache_set_create_cb_alloc_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_cache_t *cache = mp_write_ptr_lv_cache_t(mp_args[0]);
    ((void (*)(lv_cache_t *, lv_cache_create_cb_t, void *))lv_func_ptr)(cache, alloc_cb, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_set_create_cb_mpobj, 3, mp_lv_cache_set_create_cb, lv_cache_set_create_cb);
    

/*
 * Callback function lv_cache_set_free_cb_free_cb
 * void lv_cache_free_cb_t(void *node, void *user_data)
 */

GENMPY_UNUSED STATIC void lv_cache_set_free_cb_free_cb_callback(void *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg1);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_cache_set_free_cb_free_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_cache_set_free_cb(lv_cache_t *cache, lv_cache_free_cb_t free_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_cache_set_free_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *free_cb = mp_lv_callback(mp_args[1], &lv_cache_set_free_cb_free_cb_callback, MP_QSTR_lv_cache_set_free_cb_free_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_cache_t *cache = mp_write_ptr_lv_cache_t(mp_args[0]);
    ((void (*)(lv_cache_t *, lv_cache_free_cb_t, void *))lv_func_ptr)(cache, free_cb, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_set_free_cb_mpobj, 3, mp_lv_cache_set_free_cb, lv_cache_set_free_cb);
    

STATIC const mp_rom_map_elem_t mp_lv_cache_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_cache_t))) },
    { MP_ROM_QSTR(MP_QSTR_destroy), MP_ROM_PTR(&mp_lv_cache_destroy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_acquire), MP_ROM_PTR(&mp_lv_cache_acquire_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_acquire_or_create), MP_ROM_PTR(&mp_lv_cache_acquire_or_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add), MP_ROM_PTR(&mp_lv_cache_add_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_release), MP_ROM_PTR(&mp_lv_cache_release_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_drop), MP_ROM_PTR(&mp_lv_cache_drop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_drop_all), MP_ROM_PTR(&mp_lv_cache_drop_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_size), MP_ROM_PTR(&mp_lv_cache_set_max_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_size), MP_ROM_PTR(&mp_lv_cache_get_max_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_size), MP_ROM_PTR(&mp_lv_cache_get_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_free_size), MP_ROM_PTR(&mp_lv_cache_get_free_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_compare_cb), MP_ROM_PTR(&mp_lv_cache_set_compare_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_create_cb), MP_ROM_PTR(&mp_lv_cache_set_create_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_free_cb), MP_ROM_PTR(&mp_lv_cache_set_free_cb_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_cache_t_locals_dict, mp_lv_cache_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_cache_t *lv_cache_create(const lv_cache_class_t *cache_class, size_t node_size, size_t max_size, lv_cache_ops_t ops)
 */

STATIC mp_obj_t mp_lv_cache_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_cache_class_t *cache_class = (const lv_cache_class_t *)mp_write_ptr_lv_cache_class_t(mp_args[0]);
    size_t node_size = (size_t)mp_obj_get_int(mp_args[1]);
    size_t max_size = (size_t)mp_obj_get_int(mp_args[2]);
    lv_cache_ops_t ops = mp_write_lv_cache_ops_t(mp_args[3]);
    lv_cache_t * _res = ((lv_cache_t *(*)(const lv_cache_class_t *, size_t, size_t, lv_cache_ops_t))lv_func_ptr)(cache_class, node_size, max_size, ops);
    return mp_read_ptr_lv_cache_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cache_create_mpobj, 4, mp_lv_cache_create, lv_cache_create);
    

STATIC const mp_rom_map_elem_t mp_lv_cache_class_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_cache_class_t))) },
    { MP_ROM_QSTR(MP_QSTR_create), MP_ROM_PTR(&mp_lv_cache_create_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_cache_class_t_locals_dict, mp_lv_cache_class_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_cache_ops_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_cache_ops_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_cache_ops_t_locals_dict, mp_lv_cache_ops_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_calendar_date_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_calendar_date_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_calendar_date_t_locals_dict, mp_lv_calendar_date_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_series_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_series_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_series_t_locals_dict, mp_lv_chart_series_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_cursor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_cursor_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_cursor_t_locals_dict, mp_lv_chart_cursor_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_scale_section_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_scale_section_t))) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_scale_section_set_range_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_style), MP_ROM_PTR(&mp_lv_scale_section_set_style_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_scale_section_t_locals_dict, mp_lv_scale_section_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_span_set_text(lv_span_t *span, const char *text)
 */

STATIC mp_obj_t mp_lv_span_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_span_t *span = mp_write_ptr_lv_span_t(mp_args[0]);
    const char *text = (const char *)(char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_span_t *, const char *))lv_func_ptr)(span, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_span_set_text_mpobj, 2, mp_lv_span_set_text, lv_span_set_text);
    
/* Reusing lv_span_set_text for lv_span_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_span_set_text_static_mpobj, 2, mp_lv_span_set_text, lv_span_set_text_static);
    

STATIC const mp_rom_map_elem_t mp_lv_span_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_span_t))) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_span_set_text_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_span_set_text_static_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_span_t_locals_dict, mp_lv_span_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_mp_int_wrapper_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_mp_int_wrapper))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_mp_int_wrapper_locals_dict, mp__lv_mp_int_wrapper_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void *lv_timer_get_user_data(lv_timer_t *timer)
 */

STATIC mp_obj_t mp_lv_timer_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    void * _res = ((void *(*)(lv_timer_t *))lv_func_ptr)(timer);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_get_user_data_mpobj, 1, mp_lv_timer_get_user_data, lv_timer_get_user_data);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_timer_get_paused(lv_timer_t *timer)
 */

STATIC mp_obj_t mp_lv_timer_get_paused(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    bool _res = ((bool (*)(lv_timer_t *))lv_func_ptr)(timer);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_get_paused_mpobj, 1, mp_lv_timer_get_paused, lv_timer_get_paused);
    
/* Reusing funcptr_lv_timer_cb_t for lv_timer_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_delete_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_timer_delete);
    
/* Reusing funcptr_lv_timer_cb_t for lv_timer_pause */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_pause_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_timer_pause);
    
/* Reusing funcptr_lv_timer_cb_t for lv_timer_resume */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_resume_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_timer_resume);
    

/*
 * Callback function lv_timer_t_timer_cb
 * void lv_timer_cb_t(lv_timer_t *)
 */

GENMPY_UNUSED STATIC void lv_timer_t_timer_cb_callback(lv_timer_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_timer_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_timer_t_timer_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_timer_set_cb(lv_timer_t *timer, lv_timer_cb_t timer_cb)
 */

STATIC mp_obj_t mp_lv_timer_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    void *timer_cb = mp_lv_callback(mp_args[1], &lv_timer_t_timer_cb_callback, MP_QSTR_lv_timer_t_timer_cb, &timer->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_timer_t *, lv_timer_cb_t))lv_func_ptr)(timer, timer_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_cb_mpobj, 2, mp_lv_timer_set_cb, lv_timer_set_cb);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_period(lv_timer_t *timer, uint32_t period)
 */

STATIC mp_obj_t mp_lv_timer_set_period(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_timer_t *, uint32_t))lv_func_ptr)(timer, period);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_period_mpobj, 2, mp_lv_timer_set_period, lv_timer_set_period);
    
/* Reusing funcptr_lv_timer_cb_t for lv_timer_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_ready_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_timer_ready);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_repeat_count(lv_timer_t *timer, int32_t repeat_count)
 */

STATIC mp_obj_t mp_lv_timer_set_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    int32_t repeat_count = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_timer_t *, int32_t))lv_func_ptr)(timer, repeat_count);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_repeat_count_mpobj, 2, mp_lv_timer_set_repeat_count, lv_timer_set_repeat_count);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_auto_delete(lv_timer_t *timer, bool auto_delete)
 */

STATIC mp_obj_t mp_lv_timer_set_auto_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    bool auto_delete = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_timer_t *, bool))lv_func_ptr)(timer, auto_delete);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_auto_delete_mpobj, 2, mp_lv_timer_set_auto_delete, lv_timer_set_auto_delete);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_user_data(lv_timer_t *timer, void *user_data)
 */

STATIC mp_obj_t mp_lv_timer_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    ((void (*)(lv_timer_t *, void *))lv_func_ptr)(timer, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_user_data_mpobj, 2, mp_lv_timer_set_user_data, lv_timer_set_user_data);
    
/* Reusing funcptr_lv_timer_cb_t for lv_timer_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_reset_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_timer_reset);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_get_next(lv_timer_t *timer)
 */

STATIC mp_obj_t mp_lv_timer_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_timer_t *))lv_func_ptr)(timer);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_get_next_mpobj, 1, mp_lv_timer_get_next, lv_timer_get_next);
    

STATIC const mp_rom_map_elem_t mp_lv_timer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_timer_t))) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_timer_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_paused), MP_ROM_PTR(&mp_lv_timer_get_paused_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_timer_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&mp_lv_timer_pause_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_resume), MP_ROM_PTR(&mp_lv_timer_resume_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cb), MP_ROM_PTR(&mp_lv_timer_set_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_period), MP_ROM_PTR(&mp_lv_timer_set_period_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_ready), MP_ROM_PTR(&mp_lv_timer_ready_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_timer_set_repeat_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_auto_delete), MP_ROM_PTR(&mp_lv_timer_set_auto_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_timer_set_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_timer_reset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_timer_get_next_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_timer_t_locals_dict, mp_lv_timer_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_array_size(const lv_array_t *array)
 */

STATIC mp_obj_t mp_lv_array_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_array_t *array = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_array_t *))lv_func_ptr)(array);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_size_mpobj, 1, mp_lv_array_size, lv_array_size);
    
/* Reusing lv_array_size for lv_array_capacity */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_capacity_mpobj, 1, mp_lv_array_size, lv_array_capacity);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_array_is_empty(const lv_array_t *array)
 */

STATIC mp_obj_t mp_lv_array_is_empty(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_array_t *array = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_array_t *))lv_func_ptr)(array);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_is_empty_mpobj, 1, mp_lv_array_is_empty, lv_array_is_empty);
    
/* Reusing lv_array_is_empty for lv_array_is_full */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_is_full_mpobj, 1, mp_lv_array_is_empty, lv_array_is_full);
    

/*
 * lvgl extension definition for:
 * inline static void lv_array_clear(lv_array_t *array)
 */

STATIC mp_obj_t mp_lv_array_clear(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    ((void (*)(lv_array_t *))lv_func_ptr)(array);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_clear_mpobj, 1, mp_lv_array_clear, lv_array_clear);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_array_front(const lv_array_t *array)
 */

STATIC mp_obj_t mp_lv_array_front(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_array_t *array = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[0]);
    void * _res = ((void *(*)(const lv_array_t *))lv_func_ptr)(array);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_front_mpobj, 1, mp_lv_array_front, lv_array_front);
    
/* Reusing lv_array_front for lv_array_back */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_back_mpobj, 1, mp_lv_array_front, lv_array_back);
    

/*
 * lvgl extension definition for:
 * void lv_array_init(lv_array_t *array, uint32_t capacity, uint32_t element_size)
 */

STATIC mp_obj_t mp_lv_array_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t capacity = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t element_size = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_array_t *, uint32_t, uint32_t))lv_func_ptr)(array, capacity, element_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_init_mpobj, 3, mp_lv_array_init, lv_array_init);
    

/*
 * lvgl extension definition for:
 * void lv_array_resize(lv_array_t *array, uint32_t new_capacity)
 */

STATIC mp_obj_t mp_lv_array_resize(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t new_capacity = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_array_t *, uint32_t))lv_func_ptr)(array, new_capacity);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_resize_mpobj, 2, mp_lv_array_resize, lv_array_resize);
    
/* Reusing lv_array_clear for lv_array_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_deinit_mpobj, 1, mp_lv_array_clear, lv_array_deinit);
    

/*
 * lvgl extension definition for:
 * void lv_array_copy(lv_array_t *target, const lv_array_t *source)
 */

STATIC mp_obj_t mp_lv_array_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *target = mp_write_ptr_lv_array_t(mp_args[0]);
    const lv_array_t *source = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[1]);
    ((void (*)(lv_array_t *, const lv_array_t *))lv_func_ptr)(target, source);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_copy_mpobj, 2, mp_lv_array_copy, lv_array_copy);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_array_remove(lv_array_t *array, uint32_t index)
 */

STATIC mp_obj_t mp_lv_array_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_array_t *, uint32_t))lv_func_ptr)(array, index);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_remove_mpobj, 2, mp_lv_array_remove, lv_array_remove);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_array_erase(lv_array_t *array, uint32_t start, uint32_t end)
 */

STATIC mp_obj_t mp_lv_array_erase(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t start = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t end = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_array_t *, uint32_t, uint32_t))lv_func_ptr)(array, start, end);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_erase_mpobj, 3, mp_lv_array_erase, lv_array_erase);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_array_concat(lv_array_t *array, const lv_array_t *other)
 */

STATIC mp_obj_t mp_lv_array_concat(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    const lv_array_t *other = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_array_t *, const lv_array_t *))lv_func_ptr)(array, other);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_concat_mpobj, 2, mp_lv_array_concat, lv_array_concat);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_array_push_back(lv_array_t *array, const void *element)
 */

STATIC mp_obj_t mp_lv_array_push_back(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    const void *element = (const void *)mp_to_ptr(mp_args[1]);
    lv_result_t _res = ((lv_result_t (*)(lv_array_t *, const void *))lv_func_ptr)(array, element);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_push_back_mpobj, 2, mp_lv_array_push_back, lv_array_push_back);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_array_assign(lv_array_t *array, uint32_t index, const void *value)
 */

STATIC mp_obj_t mp_lv_array_assign(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_array_t *array = mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    const void *value = (const void *)mp_to_ptr(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_array_t *, uint32_t, const void *))lv_func_ptr)(array, index, value);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_assign_mpobj, 3, mp_lv_array_assign, lv_array_assign);
    

/*
 * lvgl extension definition for:
 * void *lv_array_at(const lv_array_t *array, uint32_t index)
 */

STATIC mp_obj_t mp_lv_array_at(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_array_t *array = (const lv_array_t *)mp_write_ptr_lv_array_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(const lv_array_t *, uint32_t))lv_func_ptr)(array, index);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_array_at_mpobj, 2, mp_lv_array_at, lv_array_at);
    

STATIC const mp_rom_map_elem_t mp_lv_array_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_array_t))) },
    { MP_ROM_QSTR(MP_QSTR_size), MP_ROM_PTR(&mp_lv_array_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_capacity), MP_ROM_PTR(&mp_lv_array_capacity_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_empty), MP_ROM_PTR(&mp_lv_array_is_empty_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_full), MP_ROM_PTR(&mp_lv_array_is_full_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&mp_lv_array_clear_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_front), MP_ROM_PTR(&mp_lv_array_front_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_back), MP_ROM_PTR(&mp_lv_array_back_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_array_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_resize), MP_ROM_PTR(&mp_lv_array_resize_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&mp_lv_array_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_array_copy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_array_remove_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_erase), MP_ROM_PTR(&mp_lv_array_erase_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_concat), MP_ROM_PTR(&mp_lv_array_concat_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_push_back), MP_ROM_PTR(&mp_lv_array_push_back_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_assign), MP_ROM_PTR(&mp_lv_array_assign_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_at), MP_ROM_PTR(&mp_lv_array_at_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_array_t_locals_dict, mp_lv_array_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_color16_premultiply(lv_color16_t *c, lv_opa_t a)
 */

STATIC mp_obj_t mp_lv_color16_premultiply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color16_t *c = mp_write_ptr_lv_color16_t(mp_args[0]);
    lv_opa_t a = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_color16_t *, lv_opa_t))lv_func_ptr)(c, a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color16_premultiply_mpobj, 2, mp_lv_color16_premultiply, lv_color16_premultiply);
    

STATIC const mp_rom_map_elem_t mp_lv_color16_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color16_t))) },
    { MP_ROM_QSTR(MP_QSTR_premultiply), MP_ROM_PTR(&mp_lv_color16_premultiply_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color16_t_locals_dict, mp_lv_color16_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_mem_monitor_core(lv_mem_monitor_t *mon_p)
 */

STATIC mp_obj_t mp_lv_mem_monitor_core(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_mem_monitor_t *mon_p = mp_write_ptr_lv_mem_monitor_t(mp_args[0]);
    ((void (*)(lv_mem_monitor_t *))lv_func_ptr)(mon_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_mem_monitor_core_mpobj, 1, mp_lv_mem_monitor_core, lv_mem_monitor_core);
    
/* Reusing lv_mem_monitor_core for lv_mem_monitor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_mem_monitor_mpobj, 1, mp_lv_mem_monitor_core, lv_mem_monitor);
    

STATIC const mp_rom_map_elem_t mp_lv_mem_monitor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_mem_monitor_t))) },
    { MP_ROM_QSTR(MP_QSTR_core), MP_ROM_PTR(&mp_lv_mem_monitor_core_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_monitor), MP_ROM_PTR(&mp_lv_mem_monitor_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_mem_monitor_t_locals_dict, mp_lv_mem_monitor_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_delete(lv_anim_timeline_t *at)
 */

STATIC mp_obj_t mp_lv_anim_timeline_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    ((void (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_delete_mpobj, 1, mp_lv_anim_timeline_delete, lv_anim_timeline_delete);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_add(lv_anim_timeline_t *at, uint32_t start_time, const lv_anim_t *a)
 */

STATIC mp_obj_t mp_lv_anim_timeline_add(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    uint32_t start_time = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_anim_t *a = (const lv_anim_t *)mp_write_ptr_lv_anim_t(mp_args[2]);
    ((void (*)(lv_anim_timeline_t *, uint32_t, const lv_anim_t *))lv_func_ptr)(at, start_time, a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_add_mpobj, 3, mp_lv_anim_timeline_add, lv_anim_timeline_add);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_anim_timeline_start(lv_anim_timeline_t *at)
 */

STATIC mp_obj_t mp_lv_anim_timeline_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_start_mpobj, 1, mp_lv_anim_timeline_start, lv_anim_timeline_start);
    
/* Reusing lv_anim_timeline_delete for lv_anim_timeline_pause */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_pause_mpobj, 1, mp_lv_anim_timeline_delete, lv_anim_timeline_pause);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_set_reverse(lv_anim_timeline_t *at, bool reverse)
 */

STATIC mp_obj_t mp_lv_anim_timeline_set_reverse(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    bool reverse = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_anim_timeline_t *, bool))lv_func_ptr)(at, reverse);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_set_reverse_mpobj, 2, mp_lv_anim_timeline_set_reverse, lv_anim_timeline_set_reverse);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_set_progress(lv_anim_timeline_t *at, uint16_t progress)
 */

STATIC mp_obj_t mp_lv_anim_timeline_set_progress(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    uint16_t progress = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_timeline_t *, uint16_t))lv_func_ptr)(at, progress);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_set_progress_mpobj, 2, mp_lv_anim_timeline_set_progress, lv_anim_timeline_set_progress);
    
/* Reusing lv_anim_timeline_start for lv_anim_timeline_get_playtime */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_get_playtime_mpobj, 1, mp_lv_anim_timeline_start, lv_anim_timeline_get_playtime);
    

/*
 * lvgl extension definition for:
 * bool lv_anim_timeline_get_reverse(lv_anim_timeline_t *at)
 */

STATIC mp_obj_t mp_lv_anim_timeline_get_reverse(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    bool _res = ((bool (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_get_reverse_mpobj, 1, mp_lv_anim_timeline_get_reverse, lv_anim_timeline_get_reverse);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_anim_timeline_get_progress(lv_anim_timeline_t *at)
 */

STATIC mp_obj_t mp_lv_anim_timeline_get_progress(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_write_ptr_lv_anim_timeline_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_timeline_get_progress_mpobj, 1, mp_lv_anim_timeline_get_progress, lv_anim_timeline_get_progress);
    

STATIC const mp_rom_map_elem_t mp_lv_anim_timeline_t_locals_dict_table[] = {
    
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_anim_timeline_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add), MP_ROM_PTR(&mp_lv_anim_timeline_add_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_anim_timeline_start_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&mp_lv_anim_timeline_pause_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_reverse), MP_ROM_PTR(&mp_lv_anim_timeline_set_reverse_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_progress), MP_ROM_PTR(&mp_lv_anim_timeline_set_progress_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_playtime), MP_ROM_PTR(&mp_lv_anim_timeline_get_playtime_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_reverse), MP_ROM_PTR(&mp_lv_anim_timeline_get_reverse_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_progress), MP_ROM_PTR(&mp_lv_anim_timeline_get_progress_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_timeline_t_locals_dict, mp_lv_anim_timeline_t_locals_dict_table);
        

/*
 * Function NOT generated:
 * Callback function 'lv_rb_compare_t compare' must receive a struct pointer with user_data member as its first argument!
 * lv_rb_compare_t compare
 */
    

/*
 * lvgl extension definition for:
 * bool lv_rb_init(lv_rb_t *tree, lv_rb_compare_t compare, size_t node_size)
 */

STATIC mp_obj_t mp_lv_rb_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    lv_rb_compare_t compare = mp_to_ptr(mp_args[1]);
    size_t node_size = (size_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_rb_t *, lv_rb_compare_t, size_t))lv_func_ptr)(tree, compare, node_size);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_init_mpobj, 3, mp_lv_rb_init, lv_rb_init);
    

/*
 * lvgl extension definition for:
 * lv_rb_node_t *lv_rb_insert(lv_rb_t *tree, void *key)
 */

STATIC mp_obj_t mp_lv_rb_insert(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    void *key = mp_to_ptr(mp_args[1]);
    lv_rb_node_t * _res = ((lv_rb_node_t *(*)(lv_rb_t *, void *))lv_func_ptr)(tree, key);
    return mp_read_ptr_lv_rb_node_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_insert_mpobj, 2, mp_lv_rb_insert, lv_rb_insert);
    

/*
 * lvgl extension definition for:
 * lv_rb_node_t *lv_rb_find(lv_rb_t *tree, const void *key)
 */

STATIC mp_obj_t mp_lv_rb_find(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    const void *key = (const void *)mp_to_ptr(mp_args[1]);
    lv_rb_node_t * _res = ((lv_rb_node_t *(*)(lv_rb_t *, const void *))lv_func_ptr)(tree, key);
    return mp_read_ptr_lv_rb_node_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_find_mpobj, 2, mp_lv_rb_find, lv_rb_find);
    

/*
 * lvgl extension definition for:
 * void *lv_rb_remove_node(lv_rb_t *tree, lv_rb_node_t *node)
 */

STATIC mp_obj_t mp_lv_rb_remove_node(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    lv_rb_node_t *node = mp_write_ptr_lv_rb_node_t(mp_args[1]);
    void * _res = ((void *(*)(lv_rb_t *, lv_rb_node_t *))lv_func_ptr)(tree, node);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_remove_node_mpobj, 2, mp_lv_rb_remove_node, lv_rb_remove_node);
    

/*
 * lvgl extension definition for:
 * void *lv_rb_remove(lv_rb_t *tree, const void *key)
 */

STATIC mp_obj_t mp_lv_rb_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    const void *key = (const void *)mp_to_ptr(mp_args[1]);
    void * _res = ((void *(*)(lv_rb_t *, const void *))lv_func_ptr)(tree, key);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_remove_mpobj, 2, mp_lv_rb_remove, lv_rb_remove);
    

/*
 * lvgl extension definition for:
 * bool lv_rb_drop_node(lv_rb_t *tree, lv_rb_node_t *node)
 */

STATIC mp_obj_t mp_lv_rb_drop_node(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    lv_rb_node_t *node = mp_write_ptr_lv_rb_node_t(mp_args[1]);
    bool _res = ((bool (*)(lv_rb_t *, lv_rb_node_t *))lv_func_ptr)(tree, node);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_drop_node_mpobj, 2, mp_lv_rb_drop_node, lv_rb_drop_node);
    

/*
 * lvgl extension definition for:
 * bool lv_rb_drop(lv_rb_t *tree, const void *key)
 */

STATIC mp_obj_t mp_lv_rb_drop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    const void *key = (const void *)mp_to_ptr(mp_args[1]);
    bool _res = ((bool (*)(lv_rb_t *, const void *))lv_func_ptr)(tree, key);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_drop_mpobj, 2, mp_lv_rb_drop, lv_rb_drop);
    

/*
 * lvgl extension definition for:
 * lv_rb_node_t *lv_rb_minimum(lv_rb_t *node)
 */

STATIC mp_obj_t mp_lv_rb_minimum(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *node = mp_write_ptr_lv_rb_t(mp_args[0]);
    lv_rb_node_t * _res = ((lv_rb_node_t *(*)(lv_rb_t *))lv_func_ptr)(node);
    return mp_read_ptr_lv_rb_node_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_minimum_mpobj, 1, mp_lv_rb_minimum, lv_rb_minimum);
    
/* Reusing lv_rb_minimum for lv_rb_maximum */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_maximum_mpobj, 1, mp_lv_rb_minimum, lv_rb_maximum);
    

/*
 * lvgl extension definition for:
 * void lv_rb_destroy(lv_rb_t *tree)
 */

STATIC mp_obj_t mp_lv_rb_destroy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_t *tree = mp_write_ptr_lv_rb_t(mp_args[0]);
    ((void (*)(lv_rb_t *))lv_func_ptr)(tree);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_destroy_mpobj, 1, mp_lv_rb_destroy, lv_rb_destroy);
    

STATIC const mp_rom_map_elem_t mp_lv_rb_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_rb_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_rb_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_insert), MP_ROM_PTR(&mp_lv_rb_insert_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_find), MP_ROM_PTR(&mp_lv_rb_find_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_node), MP_ROM_PTR(&mp_lv_rb_remove_node_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_rb_remove_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_drop_node), MP_ROM_PTR(&mp_lv_rb_drop_node_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_drop), MP_ROM_PTR(&mp_lv_rb_drop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_minimum), MP_ROM_PTR(&mp_lv_rb_minimum_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_maximum), MP_ROM_PTR(&mp_lv_rb_maximum_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_destroy), MP_ROM_PTR(&mp_lv_rb_destroy_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_rb_t_locals_dict, mp_lv_rb_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_rb_node_t *lv_rb_minimum_from(lv_rb_node_t *node)
 */

STATIC mp_obj_t mp_lv_rb_minimum_from(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_rb_node_t *node = mp_write_ptr_lv_rb_node_t(mp_args[0]);
    lv_rb_node_t * _res = ((lv_rb_node_t *(*)(lv_rb_node_t *))lv_func_ptr)(node);
    return mp_read_ptr_lv_rb_node_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_minimum_from_mpobj, 1, mp_lv_rb_minimum_from, lv_rb_minimum_from);
    
/* Reusing lv_rb_minimum_from for lv_rb_maximum_from */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rb_maximum_from_mpobj, 1, mp_lv_rb_minimum_from, lv_rb_maximum_from);
    

STATIC const mp_rom_map_elem_t mp_lv_rb_node_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_rb_node_t))) },
    { MP_ROM_QSTR(MP_QSTR_minimum_from), MP_ROM_PTR(&mp_lv_rb_minimum_from_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_maximum_from), MP_ROM_PTR(&mp_lv_rb_maximum_from_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_rb_node_t_locals_dict, mp_lv_rb_node_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_fs_drv_init(lv_fs_drv_t *drv)
 */

STATIC mp_obj_t mp_lv_fs_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_write_ptr_lv_fs_drv_t(mp_args[0]);
    ((void (*)(lv_fs_drv_t *))lv_func_ptr)(drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_init_mpobj, 1, mp_lv_fs_drv_init, lv_fs_drv_init);
    
/* Reusing lv_fs_drv_init for lv_fs_drv_register */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_register_mpobj, 1, mp_lv_fs_drv_init, lv_fs_drv_register);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_fs_drv_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_fs_drv_register_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_drv_t_locals_dict, mp_lv_fs_drv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_open(lv_fs_file_t *file_p, const char *path, lv_fs_mode_t mode)
 */

STATIC mp_obj_t mp_lv_fs_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const char *path = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const char *, lv_fs_mode_t))lv_func_ptr)(file_p, path, mode);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_open_mpobj, 3, mp_lv_fs_open, lv_fs_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_close(lv_fs_file_t *file_p)
 */

STATIC mp_obj_t mp_lv_fs_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *))lv_func_ptr)(file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_close_mpobj, 1, mp_lv_fs_close, lv_fs_close);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_read(lv_fs_file_t *file_p, void *buf, uint32_t btr, uint32_t *br)
 */

STATIC mp_obj_t mp_lv_fs_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *br = mp_array_to_u32ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_read_mpobj, 4, mp_lv_fs_read, lv_fs_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_write(lv_fs_file_t *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */

STATIC mp_obj_t mp_lv_fs_write(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const void *buf = (const void *)mp_to_ptr(mp_args[1]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *bw = mp_array_to_u32ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_write_mpobj, 4, mp_lv_fs_write, lv_fs_write);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_seek(lv_fs_file_t *file_p, uint32_t pos, lv_fs_whence_t whence)
 */

STATIC mp_obj_t mp_lv_fs_seek(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_fs_whence_t whence = (int)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t, lv_fs_whence_t))lv_func_ptr)(file_p, pos, whence);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_seek_mpobj, 3, mp_lv_fs_seek, lv_fs_seek);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_tell(lv_fs_file_t *file_p, uint32_t *pos)
 */

STATIC mp_obj_t mp_lv_fs_tell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t *pos = mp_array_to_u32ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t *))lv_func_ptr)(file_p, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_tell_mpobj, 2, mp_lv_fs_tell, lv_fs_tell);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_file_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_file_t))) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_read_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_lv_fs_write_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_lv_fs_seek_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_lv_fs_tell_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_file_t_locals_dict, mp_lv_fs_file_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_fs_file_cache_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_file_cache_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_file_cache_t_locals_dict, mp_lv_fs_file_cache_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_fs_make_path_from_buffer(lv_fs_path_ex_t *path, char letter, const void *buf, uint32_t size)
 */

STATIC mp_obj_t mp_lv_fs_make_path_from_buffer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_path_ex_t *path = mp_write_ptr_lv_fs_path_ex_t(mp_args[0]);
    char letter = (char)mp_obj_get_int(mp_args[1]);
    const void *buf = (const void *)mp_to_ptr(mp_args[2]);
    uint32_t size = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_fs_path_ex_t *, char, const void *, uint32_t))lv_func_ptr)(path, letter, buf, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_make_path_from_buffer_mpobj, 4, mp_lv_fs_make_path_from_buffer, lv_fs_make_path_from_buffer);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_path_ex_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_path_ex_t))) },
    { MP_ROM_QSTR(MP_QSTR_make_path_from_buffer), MP_ROM_PTR(&mp_lv_fs_make_path_from_buffer_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_path_ex_t_locals_dict, mp_lv_fs_path_ex_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t *rddir_p, const char *path)
 */

STATIC mp_obj_t mp_lv_fs_dir_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    const char *path = (const char *)(char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, const char *))lv_func_ptr)(rddir_p, path);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_open_mpobj, 2, mp_lv_fs_dir_open, lv_fs_dir_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t *rddir_p, char *fn, uint32_t fn_len)
 */

STATIC mp_obj_t mp_lv_fs_dir_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    char *fn = (char*)convert_from_str(mp_args[1]);
    uint32_t fn_len = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, char *, uint32_t))lv_func_ptr)(rddir_p, fn, fn_len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_read_mpobj, 3, mp_lv_fs_dir_read, lv_fs_dir_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t *rddir_p)
 */

STATIC mp_obj_t mp_lv_fs_dir_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *))lv_func_ptr)(rddir_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_close_mpobj, 1, mp_lv_fs_dir_close, lv_fs_dir_close);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_dir_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_dir_t))) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_dir_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_dir_read_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_dir_close_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_dir_t_locals_dict, mp_lv_fs_dir_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_gradient_cleanup(lv_grad_t *grad)
 */

STATIC mp_obj_t mp_lv_gradient_cleanup(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_grad_t *grad = mp_write_ptr_lv_grad_t(mp_args[0]);
    ((void (*)(lv_grad_t *))lv_func_ptr)(grad);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_cleanup_mpobj, 1, mp_lv_gradient_cleanup, lv_gradient_cleanup);
    

STATIC const mp_rom_map_elem_t mp_lv_grad_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_grad_t))) },
    { MP_ROM_QSTR(MP_QSTR_gradient_cleanup), MP_ROM_PTR(&mp_lv_gradient_cleanup_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_grad_t_locals_dict, mp_lv_grad_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_fill_dsc_init(lv_draw_fill_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_fill_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_fill_dsc_t *dsc = mp_write_ptr_lv_draw_fill_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_fill_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_fill_dsc_init_mpobj, 1, mp_lv_draw_fill_dsc_init, lv_draw_fill_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_fill_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_fill_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_fill_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_fill_dsc_t_locals_dict, mp_lv_draw_fill_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_border_dsc_init(lv_draw_border_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_border_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_border_dsc_t *dsc = mp_write_ptr_lv_draw_border_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_border_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_border_dsc_init_mpobj, 1, mp_lv_draw_border_dsc_init, lv_draw_border_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_border_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_border_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_border_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_border_dsc_t_locals_dict, mp_lv_draw_border_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_box_shadow_dsc_init(lv_draw_box_shadow_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_box_shadow_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_box_shadow_dsc_t *dsc = mp_write_ptr_lv_draw_box_shadow_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_box_shadow_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_box_shadow_dsc_init_mpobj, 1, mp_lv_draw_box_shadow_dsc_init, lv_draw_box_shadow_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_box_shadow_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_box_shadow_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_box_shadow_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_box_shadow_dsc_t_locals_dict, mp_lv_draw_box_shadow_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_glyph_dsc_init(lv_draw_glyph_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_glyph_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_glyph_dsc_t *dsc = mp_write_ptr_lv_draw_glyph_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_glyph_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_glyph_dsc_init_mpobj, 1, mp_lv_draw_glyph_dsc_init, lv_draw_glyph_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_glyph_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_glyph_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_glyph_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_glyph_dsc_t_locals_dict, mp_lv_draw_glyph_dsc_t_locals_dict_table);
        

/*
 * Function NOT generated:
 * Callback function 'lv_draw_glyph_cb_t cb' must receive a struct pointer with user_data member as its first argument!
 * lv_draw_glyph_cb_t cb
 */
    
#define funcptr_lv_draw_glyph_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_draw_glyph_cb_t(lv_draw_unit_t *draw_unit, lv_draw_glyph_dsc_t *dsc, lv_draw_fill_dsc_t *fill_dsc, const lv_area_t *fill_area)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_glyph_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    lv_draw_glyph_dsc_t *dsc = mp_write_ptr_lv_draw_glyph_dsc_t(mp_args[1]);
    lv_draw_fill_dsc_t *fill_dsc = mp_write_ptr_lv_draw_fill_dsc_t(mp_args[2]);
    const lv_area_t *fill_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[3]);
    ((void (*)(lv_draw_unit_t *, lv_draw_glyph_dsc_t *, lv_draw_fill_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, fill_dsc, fill_area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_glyph_cb_t_mpobj, 4, mp_funcptr_lv_draw_glyph_cb_t, funcptr_lv_draw_glyph_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_glyph_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_glyph_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * lvgl extension definition for:
 * void lv_draw_label_iterate_characters(lv_draw_unit_t *draw_unit, const lv_draw_label_dsc_t *dsc, const lv_area_t *coords, lv_draw_glyph_cb_t cb)
 */

STATIC mp_obj_t mp_lv_draw_label_iterate_characters(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_label_dsc_t *dsc = (const lv_draw_label_dsc_t *)mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    lv_draw_glyph_cb_t cb = mp_to_ptr(mp_args[3]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_label_dsc_t *, const lv_area_t *, lv_draw_glyph_cb_t))lv_func_ptr)(draw_unit, dsc, coords, cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_label_iterate_characters_mpobj, 4, mp_lv_draw_label_iterate_characters, lv_draw_label_iterate_characters);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_fill(lv_draw_unit_t *draw_unit, const lv_draw_fill_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_fill(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_fill_dsc_t *dsc = (const lv_draw_fill_dsc_t *)mp_write_ptr_lv_draw_fill_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_fill_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_fill_mpobj, 3, mp_lv_draw_sw_fill, lv_draw_sw_fill);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_border(lv_draw_unit_t *draw_unit, const lv_draw_border_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_border(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_border_dsc_t *dsc = (const lv_draw_border_dsc_t *)mp_write_ptr_lv_draw_border_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_border_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_border_mpobj, 3, mp_lv_draw_sw_border, lv_draw_sw_border);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_box_shadow(lv_draw_unit_t *draw_unit, const lv_draw_box_shadow_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_box_shadow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_box_shadow_dsc_t *dsc = (const lv_draw_box_shadow_dsc_t *)mp_write_ptr_lv_draw_box_shadow_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_box_shadow_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_box_shadow_mpobj, 3, mp_lv_draw_sw_box_shadow, lv_draw_sw_box_shadow);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_image(lv_draw_unit_t *draw_unit, const lv_draw_image_dsc_t *draw_dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_image_dsc_t *draw_dsc = (const lv_draw_image_dsc_t *)mp_write_ptr_lv_draw_image_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_image_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, draw_dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_image_mpobj, 3, mp_lv_draw_sw_image, lv_draw_sw_image);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_label(lv_draw_unit_t *draw_unit, const lv_draw_label_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_label(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_label_dsc_t *dsc = (const lv_draw_label_dsc_t *)mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_label_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_label_mpobj, 3, mp_lv_draw_sw_label, lv_draw_sw_label);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_arc(lv_draw_unit_t *draw_unit, const lv_draw_arc_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_arc_dsc_t *dsc = (const lv_draw_arc_dsc_t *)mp_write_ptr_lv_draw_arc_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_arc_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_arc_mpobj, 3, mp_lv_draw_sw_arc, lv_draw_sw_arc);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_line(lv_draw_unit_t *draw_unit, const lv_draw_line_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_sw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_line_dsc_t *dsc = (const lv_draw_line_dsc_t *)mp_write_ptr_lv_draw_line_dsc_t(mp_args[1]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_line_dsc_t *))lv_func_ptr)(draw_unit, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_line_mpobj, 2, mp_lv_draw_sw_line, lv_draw_sw_line);
    
/* Reusing lv_draw_sw_image for lv_draw_sw_layer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_layer_mpobj, 3, mp_lv_draw_sw_image, lv_draw_sw_layer);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_triangle(lv_draw_unit_t *draw_unit, const lv_draw_triangle_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_sw_triangle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_triangle_dsc_t *dsc = (const lv_draw_triangle_dsc_t *)mp_write_ptr_lv_draw_triangle_dsc_t(mp_args[1]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_triangle_dsc_t *))lv_func_ptr)(draw_unit, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_triangle_mpobj, 2, mp_lv_draw_sw_triangle, lv_draw_sw_triangle);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_rect(lv_draw_unit_t *draw_unit, const lv_draw_mask_rect_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_mask_rect_dsc_t *dsc = (const lv_draw_mask_rect_dsc_t *)mp_write_ptr_lv_draw_mask_rect_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_mask_rect_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_unit, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_rect_mpobj, 3, mp_lv_draw_sw_mask_rect, lv_draw_sw_mask_rect);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_transform(lv_draw_unit_t *draw_unit, const lv_area_t *dest_area, const void *src_buf, int32_t src_w, int32_t src_h, int32_t src_stride, const lv_draw_image_dsc_t *draw_dsc, const lv_draw_image_sup_t *sup, lv_color_format_t cf, void *dest_buf)
 */

STATIC mp_obj_t mp_lv_draw_sw_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_area_t *dest_area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    const void *src_buf = (const void *)mp_to_ptr(mp_args[2]);
    int32_t src_w = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t src_h = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t src_stride = (int32_t)mp_obj_get_int(mp_args[5]);
    const lv_draw_image_dsc_t *draw_dsc = (const lv_draw_image_dsc_t *)mp_write_ptr_lv_draw_image_dsc_t(mp_args[6]);
    const lv_draw_image_sup_t *sup = (const lv_draw_image_sup_t *)mp_write_ptr_lv_draw_image_sup_t(mp_args[7]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[8]);
    void *dest_buf = mp_to_ptr(mp_args[9]);
    ((void (*)(lv_draw_unit_t *, const lv_area_t *, const void *, int32_t, int32_t, int32_t, const lv_draw_image_dsc_t *, const lv_draw_image_sup_t *, lv_color_format_t, void *))lv_func_ptr)(draw_unit, dest_area, src_buf, src_w, src_h, src_stride, draw_dsc, sup, cf, dest_buf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_transform_mpobj, 10, mp_lv_draw_sw_transform, lv_draw_sw_transform);
    

/*
 * Struct lv_draw_sw_blend_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_blend_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_draw_sw_blend_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_sw_blend_dsc_t_type()));
    return (lv_draw_sw_blend_dsc_t*)self->data;
}

#define mp_write_lv_draw_sw_blend_dsc_t(struct_obj) *((lv_draw_sw_blend_dsc_t*)mp_write_ptr_lv_draw_sw_blend_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_sw_blend_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_sw_blend_dsc_t_type(), field);
}

#define mp_read_lv_draw_sw_blend_dsc_t(field) mp_read_ptr_lv_draw_sw_blend_dsc_t(copy_buffer(&field, sizeof(lv_draw_sw_blend_dsc_t)))
#define mp_read_byref_lv_draw_sw_blend_dsc_t(field) mp_read_ptr_lv_draw_sw_blend_dsc_t(&field)

STATIC void mp_lv_draw_sw_blend_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_sw_blend_dsc_t *data = (lv_draw_sw_blend_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blend_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->blend_area); break; // converting from lv_area_t *;
            case MP_QSTR_src_buf: dest[0] = ptr_to_mp((void*)data->src_buf); break; // converting from void *;
            case MP_QSTR_src_stride: dest[0] = mp_obj_new_int_from_uint(data->src_stride); break; // converting from uint32_t;
            case MP_QSTR_src_color_format: dest[0] = mp_obj_new_int_from_uint(data->src_color_format); break; // converting from lv_color_format_t;
            case MP_QSTR_src_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->src_area); break; // converting from lv_area_t *;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_mask_buf: dest[0] = mp_array_from_u8ptr((void*)data->mask_buf); break; // converting from lv_opa_t *;
            case MP_QSTR_mask_res: dest[0] = mp_obj_new_int_from_uint(data->mask_res); break; // converting from lv_draw_sw_mask_res_t;
            case MP_QSTR_mask_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->mask_area); break; // converting from lv_area_t *;
            case MP_QSTR_mask_stride: dest[0] = mp_obj_new_int(data->mask_stride); break; // converting from int32_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blend_area: data->blend_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_src_buf: data->src_buf = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_src_stride: data->src_stride = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_src_color_format: data->src_color_format = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_color_format_t;
                case MP_QSTR_src_area: data->src_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_color: data->color = mp_write_lv_color_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_mask_buf: data->mask_buf = (void*)mp_array_to_u8ptr(dest[1]); break; // converting to lv_opa_t *;
                case MP_QSTR_mask_res: data->mask_res = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_sw_mask_res_t;
                case MP_QSTR_mask_area: data->mask_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_mask_stride: data->mask_stride = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_sw_blend_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_sw_blend_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_sw_blend_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_sw_blend_dsc_t_type,
    MP_QSTR_lv_draw_sw_blend_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_sw_blend_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_sw_blend_dsc_t_attr,
    locals_dict, &mp_lv_draw_sw_blend_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_sw_blend_dsc_t_type()
{
    return &mp_lv_draw_sw_blend_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_blend(lv_draw_unit_t *draw_unit, const lv_draw_sw_blend_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_sw_blend(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_unit_t *draw_unit = mp_write_ptr_lv_draw_unit_t(mp_args[0]);
    const lv_draw_sw_blend_dsc_t *dsc = (const lv_draw_sw_blend_dsc_t *)mp_write_ptr_lv_draw_sw_blend_dsc_t(mp_args[1]);
    ((void (*)(lv_draw_unit_t *, const lv_draw_sw_blend_dsc_t *))lv_func_ptr)(draw_unit, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_blend_mpobj, 2, mp_lv_draw_sw_blend, lv_draw_sw_blend);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_unit_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_unit_t))) },
    { MP_ROM_QSTR(MP_QSTR_label_iterate_characters), MP_ROM_PTR(&mp_lv_draw_label_iterate_characters_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_fill), MP_ROM_PTR(&mp_lv_draw_sw_fill_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_border), MP_ROM_PTR(&mp_lv_draw_sw_border_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_box_shadow), MP_ROM_PTR(&mp_lv_draw_sw_box_shadow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_image), MP_ROM_PTR(&mp_lv_draw_sw_image_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_label), MP_ROM_PTR(&mp_lv_draw_sw_label_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_arc), MP_ROM_PTR(&mp_lv_draw_sw_arc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_line), MP_ROM_PTR(&mp_lv_draw_sw_line_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_layer), MP_ROM_PTR(&mp_lv_draw_sw_layer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_triangle), MP_ROM_PTR(&mp_lv_draw_sw_triangle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_mask_rect), MP_ROM_PTR(&mp_lv_draw_sw_mask_rect_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_transform), MP_ROM_PTR(&mp_lv_draw_sw_transform_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sw_blend), MP_ROM_PTR(&mp_lv_draw_sw_blend_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_unit_t_locals_dict, mp_lv_draw_unit_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_triangle_dsc_init(lv_draw_triangle_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_draw_triangle_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_triangle_dsc_t *draw_dsc = mp_write_ptr_lv_draw_triangle_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_triangle_dsc_t *))lv_func_ptr)(draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_triangle_dsc_init_mpobj, 1, mp_lv_draw_triangle_dsc_init, lv_draw_triangle_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_triangle_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_triangle_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_triangle_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_triangle_dsc_t_locals_dict, mp_lv_draw_triangle_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_rect_dsc_init(lv_draw_mask_rect_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_mask_rect_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_rect_dsc_t *dsc = mp_write_ptr_lv_draw_mask_rect_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_mask_rect_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_rect_dsc_init_mpobj, 1, mp_lv_draw_mask_rect_dsc_init, lv_draw_mask_rect_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_rect_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_rect_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_rect_dsc_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_rect_dsc_t_locals_dict, mp_lv_draw_mask_rect_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_indev_delete(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    ((void (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_delete_mpobj, 1, mp_lv_indev_delete, lv_indev_delete);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_get_next(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_next_mpobj, 1, mp_lv_indev_get_next, lv_indev_get_next);
    
/* Reusing lv_indev_delete for lv_indev_read */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_read_mpobj, 1, mp_lv_indev_delete, lv_indev_read);
    

/*
 * lvgl extension definition for:
 * void lv_indev_enable(lv_indev_t *indev, bool en)
 */

STATIC mp_obj_t mp_lv_indev_enable(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_indev_t *, bool))lv_func_ptr)(indev, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_enable_mpobj, 2, mp_lv_indev_enable, lv_indev_enable);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_type(lv_indev_t *indev, lv_indev_type_t indev_type)
 */

STATIC mp_obj_t mp_lv_indev_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_type_t indev_type = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_indev_type_t))lv_func_ptr)(indev, indev_type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_type_mpobj, 2, mp_lv_indev_set_type, lv_indev_set_type);
    

/*
 * Struct lv_indev_data_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type();

STATIC inline void* mp_write_ptr_lv_indev_data_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_data_t_type()));
    return (lv_indev_data_t*)self->data;
}

#define mp_write_lv_indev_data_t(struct_obj) *((lv_indev_data_t*)mp_write_ptr_lv_indev_data_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_indev_data_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_data_t_type(), field);
}

#define mp_read_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(copy_buffer(&field, sizeof(lv_indev_data_t)))
#define mp_read_byref_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(&field)

STATIC void mp_lv_indev_data_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_indev_data_t *data = (lv_indev_data_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_byref_lv_point_t(data->point); break; // converting from lv_point_t;
            case MP_QSTR_key: dest[0] = mp_obj_new_int_from_uint(data->key); break; // converting from uint32_t;
            case MP_QSTR_btn_id: dest[0] = mp_obj_new_int_from_uint(data->btn_id); break; // converting from uint32_t;
            case MP_QSTR_enc_diff: dest[0] = mp_obj_new_int(data->enc_diff); break; // converting from int16_t;
            case MP_QSTR_state: dest[0] = mp_obj_new_int(data->state); break; // converting from lv_indev_state_t;
            case MP_QSTR_continue_reading: dest[0] = convert_to_bool(data->continue_reading); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_key: data->key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_btn_id: data->btn_id = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_enc_diff: data->enc_diff = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_state: data->state = (int)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_continue_reading: data->continue_reading = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_data_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_data_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_data_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_indev_data_t_type,
    MP_QSTR_lv_indev_data_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_indev_data_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_indev_data_t_attr,
    locals_dict, &mp_lv_indev_data_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type()
{
    return &mp_lv_indev_data_t_type;
}
    

/*
 * Callback function lv_indev_t_read_cb
 * void lv_indev_read_cb_t(lv_indev_t *indev, lv_indev_data_t *data)
 */

GENMPY_UNUSED STATIC void lv_indev_t_read_cb_callback(lv_indev_t *arg0, lv_indev_data_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_indev_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_indev_data_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(lv_indev_get_user_data(arg0));
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_t_read_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_indev_set_read_cb(lv_indev_t *indev, lv_indev_read_cb_t read_cb)
 */

STATIC mp_obj_t mp_lv_indev_set_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    void *read_cb = mp_lv_callback(mp_args[1], &lv_indev_t_read_cb_callback, MP_QSTR_lv_indev_t_read_cb, NULL, indev, (mp_lv_get_user_data)lv_indev_get_user_data, (mp_lv_set_user_data)lv_indev_set_user_data);
    ((void (*)(lv_indev_t *, lv_indev_read_cb_t))lv_func_ptr)(indev, read_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_read_cb_mpobj, 2, mp_lv_indev_set_read_cb, lv_indev_set_read_cb);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_user_data(lv_indev_t *indev, void *user_data)
 */

STATIC mp_obj_t mp_lv_indev_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    ((void (*)(lv_indev_t *, void *))lv_func_ptr)(indev, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_user_data_mpobj, 2, mp_lv_indev_set_user_data, lv_indev_set_user_data);
    
/* Reusing lv_indev_set_user_data for lv_indev_set_driver_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_driver_data_mpobj, 2, mp_lv_indev_set_user_data, lv_indev_set_driver_data);
    

/*
 * lvgl extension definition for:
 * lv_indev_type_t lv_indev_get_type(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_type_t _res = ((lv_indev_type_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_type_mpobj, 1, mp_lv_indev_get_type, lv_indev_get_type);
    
#define funcptr_lv_indev_read_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_indev_read_cb_t(lv_indev_t *indev, lv_indev_data_t *data)
 */

STATIC mp_obj_t mp_funcptr_lv_indev_read_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_data_t *data = mp_write_ptr_lv_indev_data_t(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_indev_data_t *))lv_func_ptr)(indev, data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_indev_read_cb_t_mpobj, 2, mp_funcptr_lv_indev_read_cb_t, funcptr_lv_indev_read_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_indev_read_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_indev_read_cb_t_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * lvgl extension definition for:
 * lv_indev_read_cb_t lv_indev_get_read_cb(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_read_cb_t _res = ((lv_indev_read_cb_t (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_lv_funcptr_lv_indev_read_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_read_cb_mpobj, 1, mp_lv_indev_get_read_cb, lv_indev_get_read_cb);
    

/*
 * lvgl extension definition for:
 * lv_indev_state_t lv_indev_get_state(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_state_t _res = ((lv_indev_state_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_state_mpobj, 1, mp_lv_indev_get_state, lv_indev_get_state);
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_indev_get_group(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_group_t * _res = ((lv_group_t *(*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_group_mpobj, 1, mp_lv_indev_get_group, lv_indev_get_group);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_display(lv_indev_t *indev, struct _lv_display_t *disp)
 */

STATIC mp_obj_t mp_lv_indev_set_display(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    struct _lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[1]);
    ((void (*)(lv_indev_t *, struct _lv_display_t *))lv_func_ptr)(indev, disp);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_display_mpobj, 2, mp_lv_indev_set_display, lv_indev_set_display);
    

/*
 * lvgl extension definition for:
 * lv_display_t *lv_indev_get_display(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_display(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_display_t * _res = ((lv_display_t *(*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_display_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_display_mpobj, 1, mp_lv_indev_get_display, lv_indev_get_display);
    

/*
 * lvgl extension definition for:
 * void *lv_indev_get_user_data(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    void * _res = ((void *(*)(const lv_indev_t *))lv_func_ptr)(indev);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_user_data_mpobj, 1, mp_lv_indev_get_user_data, lv_indev_get_user_data);
    
/* Reusing lv_indev_get_user_data for lv_indev_get_driver_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_driver_data_mpobj, 1, mp_lv_indev_get_user_data, lv_indev_get_driver_data);
    

/*
 * lvgl extension definition for:
 * void lv_indev_reset(lv_indev_t *indev, lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_indev_reset(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_obj_t *))lv_func_ptr)(indev, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_mpobj, 2, mp_lv_indev_reset, lv_indev_reset);
    
/* Reusing lv_indev_delete for lv_indev_reset_long_press */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_long_press_mpobj, 1, mp_lv_indev_delete, lv_indev_reset_long_press);
    
/* Reusing lv_indev_reset for lv_indev_set_cursor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_cursor_mpobj, 2, mp_lv_indev_reset, lv_indev_set_cursor);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_group(lv_indev_t *indev, lv_group_t *group)
 */

STATIC mp_obj_t mp_lv_indev_set_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_group_t *))lv_func_ptr)(indev, group);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_group_mpobj, 2, mp_lv_indev_set_group, lv_indev_set_group);
    

/*
 * Array convertors for lv_point_t []
 */

GENMPY_UNUSED STATIC lv_point_t *mp_arr_to_lv_point_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_point_t *lv_arr = (lv_point_t*)m_malloc(len * sizeof(lv_point_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_point_t(item);
    }
    return (lv_point_t *)lv_arr;
}

GENMPY_UNUSED STATIC mp_obj_t mp_arr_from_lv_point_t_____(const lv_point_t *arr)
{
    return mp_read_ptr_lv_point_t((void*)arr);
}


/*
 * lvgl extension definition for:
 * void lv_indev_set_button_points(lv_indev_t *indev, const lv_point_t points[])
 */

STATIC mp_obj_t mp_lv_indev_set_button_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    const lv_point_t *points = (const lv_point_t *)mp_arr_to_lv_point_t_____(mp_args[1]);
    ((void (*)(lv_indev_t *, const lv_point_t []))lv_func_ptr)(indev, points);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_button_points_mpobj, 2, mp_lv_indev_set_button_points, lv_indev_set_button_points);
    

/*
 * lvgl extension definition for:
 * void lv_indev_get_point(const lv_indev_t *indev, lv_point_t *point)
 */

STATIC mp_obj_t mp_lv_indev_get_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(const lv_indev_t *, lv_point_t *))lv_func_ptr)(indev, point);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_point_mpobj, 2, mp_lv_indev_get_point, lv_indev_get_point);
    

/*
 * lvgl extension definition for:
 * lv_dir_t lv_indev_get_gesture_dir(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_gesture_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_dir_t _res = ((lv_dir_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_gesture_dir_mpobj, 1, mp_lv_indev_get_gesture_dir, lv_indev_get_gesture_dir);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_indev_get_key(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_key_mpobj, 1, mp_lv_indev_get_key, lv_indev_get_key);
    
/* Reusing lv_indev_get_gesture_dir for lv_indev_get_scroll_dir */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_scroll_dir_mpobj, 1, mp_lv_indev_get_gesture_dir, lv_indev_get_scroll_dir);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_indev_get_scroll_obj(const lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_scroll_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = (const lv_indev_t *)mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_indev_t *))lv_func_ptr)(indev);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_scroll_obj_mpobj, 1, mp_lv_indev_get_scroll_obj, lv_indev_get_scroll_obj);
    
/* Reusing lv_indev_get_point for lv_indev_get_vect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_vect_mpobj, 2, mp_lv_indev_get_point, lv_indev_get_vect);
    
/* Reusing lv_indev_delete for lv_indev_wait_release */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_wait_release_mpobj, 1, mp_lv_indev_delete, lv_indev_wait_release);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_indev_get_read_timer(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_read_timer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_read_timer_mpobj, 1, mp_lv_indev_get_read_timer, lv_indev_get_read_timer);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_mode(lv_indev_t *indev, lv_indev_mode_t mode)
 */

STATIC mp_obj_t mp_lv_indev_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_mode_t mode = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_indev_mode_t))lv_func_ptr)(indev, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_mode_mpobj, 2, mp_lv_indev_set_mode, lv_indev_set_mode);
    

/*
 * lvgl extension definition for:
 * lv_indev_mode_t lv_indev_get_mode(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_mode_t _res = ((lv_indev_mode_t (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_mode_mpobj, 1, mp_lv_indev_get_mode, lv_indev_get_mode);
    

/*
 * Callback function lv_indev_add_event_cb_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_indev_add_event_cb_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_add_event_cb_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_indev_add_event_cb(lv_indev_t *indev, lv_event_cb_t event_cb, lv_event_code_t filter, void *user_data)
 */

STATIC mp_obj_t mp_lv_indev_add_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_indev_add_event_cb_event_cb_callback, MP_QSTR_lv_indev_add_event_cb_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_event_code_t filter = (int)mp_obj_get_int(mp_args[2]);
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    ((void (*)(lv_indev_t *, lv_event_cb_t, lv_event_code_t, void *))lv_func_ptr)(indev, event_cb, filter, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_add_event_cb_mpobj, 4, mp_lv_indev_add_event_cb, lv_indev_add_event_cb);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_indev_get_event_count(lv_indev_t *indev)
 */

STATIC mp_obj_t mp_lv_indev_get_event_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_event_count_mpobj, 1, mp_lv_indev_get_event_count, lv_indev_get_event_count);
    

/*
 * lvgl extension definition for:
 * lv_event_dsc_t *lv_indev_get_event_dsc(lv_indev_t *indev, uint32_t index)
 */

STATIC mp_obj_t mp_lv_indev_get_event_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_event_dsc_t * _res = ((lv_event_dsc_t *(*)(lv_indev_t *, uint32_t))lv_func_ptr)(indev, index);
    return mp_read_ptr_lv_event_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_event_dsc_mpobj, 2, mp_lv_indev_get_event_dsc, lv_indev_get_event_dsc);
    

/*
 * lvgl extension definition for:
 * bool lv_indev_remove_event(lv_indev_t *indev, uint32_t index)
 */

STATIC mp_obj_t mp_lv_indev_remove_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_indev_t *, uint32_t))lv_func_ptr)(indev, index);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_remove_event_mpobj, 2, mp_lv_indev_remove_event, lv_indev_remove_event);
    

/*
 * Callback function lv_indev_remove_event_cb_with_user_data_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_indev_remove_event_cb_with_user_data_event_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_remove_event_cb_with_user_data_event_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * uint32_t lv_indev_remove_event_cb_with_user_data(lv_indev_t *indev, lv_event_cb_t event_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_indev_remove_event_cb_with_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_indev_remove_event_cb_with_user_data_event_cb_callback, MP_QSTR_lv_indev_remove_event_cb_with_user_data_event_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_indev_t *, lv_event_cb_t, void *))lv_func_ptr)(indev, event_cb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_remove_event_cb_with_user_data_mpobj, 3, mp_lv_indev_remove_event_cb_with_user_data, lv_indev_remove_event_cb_with_user_data);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_indev_send_event(lv_indev_t *indev, lv_event_code_t code, void *param)
 */

STATIC mp_obj_t mp_lv_indev_send_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_event_code_t code = (int)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_indev_t *, lv_event_code_t, void *))lv_func_ptr)(indev, code, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_send_event_mpobj, 3, mp_lv_indev_send_event, lv_indev_send_event);
    

STATIC const mp_rom_map_elem_t mp_lv_indev_t_locals_dict_table[] = {
    
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_indev_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_indev_get_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_indev_read_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_enable), MP_ROM_PTR(&mp_lv_indev_enable_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_indev_set_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_read_cb), MP_ROM_PTR(&mp_lv_indev_set_read_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_indev_set_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_driver_data), MP_ROM_PTR(&mp_lv_indev_set_driver_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_indev_get_type_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_read_cb), MP_ROM_PTR(&mp_lv_indev_get_read_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_indev_get_state_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_group), MP_ROM_PTR(&mp_lv_indev_get_group_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_display), MP_ROM_PTR(&mp_lv_indev_set_display_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_display), MP_ROM_PTR(&mp_lv_indev_get_display_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_indev_get_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_driver_data), MP_ROM_PTR(&mp_lv_indev_get_driver_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_indev_reset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_reset_long_press), MP_ROM_PTR(&mp_lv_indev_reset_long_press_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor), MP_ROM_PTR(&mp_lv_indev_set_cursor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_group), MP_ROM_PTR(&mp_lv_indev_set_group_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_points), MP_ROM_PTR(&mp_lv_indev_set_button_points_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_point), MP_ROM_PTR(&mp_lv_indev_get_point_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_gesture_dir), MP_ROM_PTR(&mp_lv_indev_get_gesture_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_key), MP_ROM_PTR(&mp_lv_indev_get_key_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_dir), MP_ROM_PTR(&mp_lv_indev_get_scroll_dir_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_obj), MP_ROM_PTR(&mp_lv_indev_get_scroll_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_vect), MP_ROM_PTR(&mp_lv_indev_get_vect_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_wait_release), MP_ROM_PTR(&mp_lv_indev_wait_release_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_read_timer), MP_ROM_PTR(&mp_lv_indev_get_read_timer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_indev_set_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_indev_get_mode_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_add_event_cb), MP_ROM_PTR(&mp_lv_indev_add_event_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_count), MP_ROM_PTR(&mp_lv_indev_get_event_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_dsc), MP_ROM_PTR(&mp_lv_indev_get_event_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event), MP_ROM_PTR(&mp_lv_indev_remove_event_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb_with_user_data), MP_ROM_PTR(&mp_lv_indev_remove_event_cb_with_user_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_send_event), MP_ROM_PTR(&mp_lv_indev_send_event_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_t_locals_dict, mp_lv_indev_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void gd_render_frame(gd_GIF *gif, uint8_t *buffer)
 */

STATIC mp_obj_t mp_gd_render_frame(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    uint8_t *buffer = mp_array_to_u8ptr(mp_args[1]);
    ((void (*)(gd_GIF *, uint8_t *))lv_func_ptr)(gif, buffer);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_render_frame_mpobj, 2, mp_gd_render_frame, gd_render_frame);
    

/*
 * lvgl extension definition for:
 * int gd_get_frame(gd_GIF *gif)
 */

STATIC mp_obj_t mp_gd_get_frame(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    int _res = ((int (*)(gd_GIF *))lv_func_ptr)(gif);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_get_frame_mpobj, 1, mp_gd_get_frame, gd_get_frame);
    

/*
 * lvgl extension definition for:
 * void gd_rewind(gd_GIF *gif)
 */

STATIC mp_obj_t mp_gd_rewind(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    ((void (*)(gd_GIF *))lv_func_ptr)(gif);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_rewind_mpobj, 1, mp_gd_rewind, gd_rewind);
    
/* Reusing gd_rewind for gd_close_gif */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_close_gif_mpobj, 1, mp_gd_rewind, gd_close_gif);
    

STATIC const mp_rom_map_elem_t mp_gd_GIF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_GIF))) },
    { MP_ROM_QSTR(MP_QSTR_render_frame), MP_ROM_PTR(&mp_gd_render_frame_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_get_frame), MP_ROM_PTR(&mp_gd_get_frame_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_rewind), MP_ROM_PTR(&mp_gd_rewind_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_close_gif), MP_ROM_PTR(&mp_gd_close_gif_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_GIF_locals_dict, mp_gd_GIF_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_gd_GCE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_GCE))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_GCE_locals_dict, mp_gd_GCE_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_gd_Palette_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_Palette))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_Palette_locals_dict, mp_gd_Palette_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_theme_set_parent(lv_theme_t *new_theme, lv_theme_t *parent)
 */

STATIC mp_obj_t mp_lv_theme_set_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *new_theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    lv_theme_t *parent = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_theme_t *, lv_theme_t *))lv_func_ptr)(new_theme, parent);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_parent_mpobj, 2, mp_lv_theme_set_parent, lv_theme_set_parent);
    

/*
 * Callback function lv_theme_t_apply_cb
 * void lv_theme_apply_cb_t(lv_theme_t *, lv_obj_t *)
 */

GENMPY_UNUSED STATIC void lv_theme_t_apply_cb_callback(lv_theme_t *arg0, lv_obj_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_theme_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_theme_t_apply_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_theme_set_apply_cb(lv_theme_t *theme, lv_theme_apply_cb_t apply_cb)
 */

STATIC mp_obj_t mp_lv_theme_set_apply_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    void *apply_cb = mp_lv_callback(mp_args[1], &lv_theme_t_apply_cb_callback, MP_QSTR_lv_theme_t_apply_cb, &theme->user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    ((void (*)(lv_theme_t *, lv_theme_apply_cb_t))lv_func_ptr)(theme, apply_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_apply_cb_mpobj, 2, mp_lv_theme_set_apply_cb, lv_theme_set_apply_cb);
    

STATIC const mp_rom_map_elem_t mp_lv_theme_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_theme_t))) },
    { MP_ROM_QSTR(MP_QSTR_set_parent), MP_ROM_PTR(&mp_lv_theme_set_parent_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_set_apply_cb), MP_ROM_PTR(&mp_lv_theme_set_apply_cb_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_theme_t_locals_dict, mp_lv_theme_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_line_points_init(lv_draw_sw_mask_line_param_t *param, int32_t p1x, int32_t p1y, int32_t p2x, int32_t p2y, lv_draw_sw_mask_line_side_t side)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_line_points_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_line_param_t *param = mp_write_ptr_lv_draw_sw_mask_line_param_t(mp_args[0]);
    int32_t p1x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t p1y = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t p2x = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t p2y = (int32_t)mp_obj_get_int(mp_args[4]);
    lv_draw_sw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_sw_mask_line_param_t *, int32_t, int32_t, int32_t, int32_t, lv_draw_sw_mask_line_side_t))lv_func_ptr)(param, p1x, p1y, p2x, p2y, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_line_points_init_mpobj, 6, mp_lv_draw_sw_mask_line_points_init, lv_draw_sw_mask_line_points_init);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_line_angle_init(lv_draw_sw_mask_line_param_t *param, int32_t p1x, int32_t py, int16_t angle, lv_draw_sw_mask_line_side_t side)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_line_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_line_param_t *param = mp_write_ptr_lv_draw_sw_mask_line_param_t(mp_args[0]);
    int32_t p1x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t py = (int32_t)mp_obj_get_int(mp_args[2]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_sw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_sw_mask_line_param_t *, int32_t, int32_t, int16_t, lv_draw_sw_mask_line_side_t))lv_func_ptr)(param, p1x, py, angle, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_line_angle_init_mpobj, 5, mp_lv_draw_sw_mask_line_angle_init, lv_draw_sw_mask_line_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_line_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_line_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_points_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_line_points_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_angle_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_line_angle_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_line_param_t_locals_dict, mp_lv_draw_sw_mask_line_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_draw_sw_mask_common_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_draw_sw_mask_common_dsc_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_draw_sw_mask_common_dsc_t_locals_dict, mp__lv_draw_sw_mask_common_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_line_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_line_param_cfg_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_line_param_cfg_t_locals_dict, mp_lv_draw_sw_mask_line_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_angle_init(lv_draw_sw_mask_angle_param_t *param, int32_t vertex_x, int32_t vertex_y, int32_t start_angle, int32_t end_angle)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_angle_param_t *param = mp_write_ptr_lv_draw_sw_mask_angle_param_t(mp_args[0]);
    int32_t vertex_x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t vertex_y = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t start_angle = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t end_angle = (int32_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_sw_mask_angle_param_t *, int32_t, int32_t, int32_t, int32_t))lv_func_ptr)(param, vertex_x, vertex_y, start_angle, end_angle);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_angle_init_mpobj, 5, mp_lv_draw_sw_mask_angle_init, lv_draw_sw_mask_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_angle_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_angle_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_angle_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_angle_param_t_locals_dict, mp_lv_draw_sw_mask_angle_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_angle_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_angle_param_cfg_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_angle_param_cfg_t_locals_dict, mp_lv_draw_sw_mask_angle_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_radius_init(lv_draw_sw_mask_radius_param_t *param, const lv_area_t *rect, int32_t radius, bool inv)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_radius_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_radius_param_t *param = mp_write_ptr_lv_draw_sw_mask_radius_param_t(mp_args[0]);
    const lv_area_t *rect = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    int32_t radius = (int32_t)mp_obj_get_int(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_draw_sw_mask_radius_param_t *, const lv_area_t *, int32_t, bool))lv_func_ptr)(param, rect, radius, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_radius_init_mpobj, 4, mp_lv_draw_sw_mask_radius_init, lv_draw_sw_mask_radius_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_radius_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_radius_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_radius_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_radius_param_t_locals_dict, mp_lv_draw_sw_mask_radius_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_radius_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_radius_param_cfg_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_radius_param_cfg_t_locals_dict, mp_lv_draw_sw_mask_radius_param_cfg_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_draw_sw_mask_radius_circle_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_draw_sw_mask_radius_circle_dsc_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_draw_sw_mask_radius_circle_dsc_t_locals_dict, mp__lv_draw_sw_mask_radius_circle_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_fade_init(lv_draw_sw_mask_fade_param_t *param, const lv_area_t *coords, lv_opa_t opa_top, int32_t y_top, lv_opa_t opa_bottom, int32_t y_bottom)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_fade_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_fade_param_t *param = mp_write_ptr_lv_draw_sw_mask_fade_param_t(mp_args[0]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    lv_opa_t opa_top = (uint8_t)mp_obj_get_int(mp_args[2]);
    int32_t y_top = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_opa_t opa_bottom = (uint8_t)mp_obj_get_int(mp_args[4]);
    int32_t y_bottom = (int32_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_sw_mask_fade_param_t *, const lv_area_t *, lv_opa_t, int32_t, lv_opa_t, int32_t))lv_func_ptr)(param, coords, opa_top, y_top, opa_bottom, y_bottom);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_fade_init_mpobj, 6, mp_lv_draw_sw_mask_fade_init, lv_draw_sw_mask_fade_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_fade_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_fade_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_fade_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_fade_param_t_locals_dict, mp_lv_draw_sw_mask_fade_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_fade_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_fade_param_cfg_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_fade_param_cfg_t_locals_dict, mp_lv_draw_sw_mask_fade_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_sw_mask_map_init(lv_draw_sw_mask_map_param_t *param, const lv_area_t *coords, const lv_opa_t *map)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_map_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_sw_mask_map_param_t *param = mp_write_ptr_lv_draw_sw_mask_map_param_t(mp_args[0]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_opa_t *map = (const lv_opa_t *)mp_array_to_u8ptr(mp_args[2]);
    ((void (*)(lv_draw_sw_mask_map_param_t *, const lv_area_t *, const lv_opa_t *))lv_func_ptr)(param, coords, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_sw_mask_map_init_mpobj, 3, mp_lv_draw_sw_mask_map_init, lv_draw_sw_mask_map_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_map_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_map_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_map_init_mpobj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_map_param_t_locals_dict, mp_lv_draw_sw_mask_map_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_mask_map_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_mask_map_param_cfg_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_mask_map_param_cfg_t_locals_dict, mp_lv_draw_sw_mask_map_param_cfg_t_locals_dict_table);
        

/*
 *
 * Global Module Functions
 *
 */


/*
 * lvgl extension definition for:
 * inline static void lv_memzero(void *dst, size_t len)
 */

STATIC mp_obj_t mp_lv_memzero(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    size_t len = (size_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, size_t))lv_func_ptr)(dst, len);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memzero_mpobj, 2, mp_lv_memzero, lv_memzero);
    

STATIC const mp_rom_map_elem_t mp_lv_color_hsv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_hsv_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_hsv_t_locals_dict, mp_lv_color_hsv_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_hit_test_info_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_hit_test_info_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_hit_test_info_t_locals_dict, mp_lv_hit_test_info_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_sw_blend_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_sw_blend_dsc_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_sw_blend_dsc_t_locals_dict, mp_lv_draw_sw_blend_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_data_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_data_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_data_t_locals_dict, mp_lv_indev_data_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_timer_handler_run_in_period(uint32_t period)
 */

STATIC mp_obj_t mp_lv_timer_handler_run_in_period(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(uint32_t))lv_func_ptr)(period);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_handler_run_in_period_mpobj, 1, mp_lv_timer_handler_run_in_period, lv_timer_handler_run_in_period);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_trigo_cos(int16_t angle)
 */

STATIC mp_obj_t mp_lv_trigo_cos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[0]);
    int32_t _res = ((int32_t (*)(int16_t))lv_func_ptr)(angle);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_trigo_cos_mpobj, 1, mp_lv_trigo_cos, lv_trigo_cos);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_bezier3(int32_t t, int32_t u0, uint32_t u1, int32_t u2, int32_t u3)
 */

STATIC mp_obj_t mp_lv_bezier3(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t t = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t u0 = (int32_t)mp_obj_get_int(mp_args[1]);
    uint32_t u1 = (uint32_t)mp_obj_get_int(mp_args[2]);
    int32_t u2 = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t u3 = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t _res = ((int32_t (*)(int32_t, int32_t, uint32_t, int32_t, int32_t))lv_func_ptr)(t, u0, u1, u2, u3);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bezier3_mpobj, 5, mp_lv_bezier3, lv_bezier3);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_pct(int32_t x)
 */

STATIC mp_obj_t mp_lv_pct(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t x = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t _res = ((int32_t (*)(int32_t))lv_func_ptr)(x);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_pct_mpobj, 1, mp_lv_pct, lv_pct);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_pct_to_px(int32_t v, int32_t base)
 */

STATIC mp_obj_t mp_lv_pct_to_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t v = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t base = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(int32_t, int32_t))lv_func_ptr)(v, base);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_pct_to_px_mpobj, 2, mp_lv_pct_to_px, lv_pct_to_px);
    

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_color_format_get_size(lv_color_format_t cf)
 */

STATIC mp_obj_t mp_lv_color_format_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_color_format_t))lv_func_ptr)(cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_format_get_size_mpobj, 1, mp_lv_color_format_get_size, lv_color_format_get_size);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_hex(uint32_t c)
 */

STATIC mp_obj_t mp_lv_color_hex(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(uint32_t))lv_func_ptr)(c);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex_mpobj, 1, mp_lv_color_hex, lv_color_hex);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
 */

STATIC mp_obj_t mp_lv_color_make(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r, g, b);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_make_mpobj, 3, mp_lv_color_make, lv_color_make);
    

/*
 * lvgl extension definition for:
 * inline static lv_color32_t lv_color32_make(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
 */

STATIC mp_obj_t mp_lv_color32_make(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint8_t a = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_color32_t _res = ((lv_color32_t (*)(uint8_t, uint8_t, uint8_t, uint8_t))lv_func_ptr)(r, g, b, a);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color32_make_mpobj, 4, mp_lv_color32_make, lv_color32_make);
    
/* Reusing lv_color_hex for lv_color_hex3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex3_mpobj, 1, mp_lv_color_hex, lv_color_hex3);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_color_16_16_mix(uint16_t c1, uint16_t c2, uint8_t mix)
 */

STATIC mp_obj_t mp_lv_color_16_16_mix(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t c1 = (uint16_t)mp_obj_get_int(mp_args[0]);
    uint16_t c2 = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint16_t _res = ((uint16_t (*)(uint16_t, uint16_t, uint8_t))lv_func_ptr)(c1, c2, mix);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_16_16_mix_mpobj, 3, mp_lv_color_16_16_mix, lv_color_16_16_mix);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_white(void)
 */

STATIC mp_obj_t mp_lv_color_white(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_color_t _res = ((lv_color_t (*)(void))lv_func_ptr)();
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_white_mpobj, 0, mp_lv_color_white, lv_color_white);
    
/* Reusing lv_color_white for lv_color_black */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_black_mpobj, 0, mp_lv_color_white, lv_color_black);
    

/*
 * lvgl extension definition for:
 * inline static const lv_font_t *lv_font_default(void)
 */

STATIC mp_obj_t mp_lv_font_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const lv_font_t * _res = ((const lv_font_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_font_default_mpobj, 0, mp_lv_font_default, lv_font_default);
    

/*
 * lvgl extension definition for:
 * inline static void lv_bidi_calculate_align(lv_text_align_t *align, lv_base_dir_t *base_dir, const char *txt)
 */

STATIC mp_obj_t mp_lv_bidi_calculate_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_text_align_t *align = mp_array_to_u8ptr(mp_args[0]);
    lv_base_dir_t *base_dir = mp_array_to_u8ptr(mp_args[1]);
    const char *txt = (const char *)(char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_text_align_t *, lv_base_dir_t *, const char *))lv_func_ptr)(align, base_dir, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bidi_calculate_align_mpobj, 3, mp_lv_bidi_calculate_align, lv_bidi_calculate_align);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_grid_fr(uint8_t x)
 */

STATIC mp_obj_t mp_lv_grid_fr(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t x = (uint8_t)mp_obj_get_int(mp_args[0]);
    int32_t _res = ((int32_t (*)(uint8_t))lv_func_ptr)(x);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_grid_fr_mpobj, 1, mp_lv_grid_fr, lv_grid_fr);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_style_prop_has_flag(lv_style_prop_t prop, uint8_t flag)
 */

STATIC mp_obj_t mp_lv_style_prop_has_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t flag = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_style_prop_t, uint8_t))lv_func_ptr)(prop, flag);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_prop_has_flag_mpobj, 2, mp_lv_style_prop_has_flag, lv_style_prop_has_flag);
    

/*
 * lvgl extension definition for:
 * inline static lv_obj_t *lv_screen_active(void)
 */

STATIC mp_obj_t mp_lv_screen_active(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_obj_t * _res = ((lv_obj_t *(*)(void))lv_func_ptr)();
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_screen_active_mpobj, 0, mp_lv_screen_active, lv_screen_active);
    
/* Reusing lv_screen_active for lv_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_top_mpobj, 0, mp_lv_screen_active, lv_layer_top);
    
/* Reusing lv_screen_active for lv_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_sys_mpobj, 0, mp_lv_screen_active, lv_layer_sys);
    
/* Reusing lv_screen_active for lv_layer_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_bottom_mpobj, 0, mp_lv_screen_active, lv_layer_bottom);
    
/* Reusing lv_pct for lv_dpx */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_dpx_mpobj, 1, mp_lv_pct, lv_dpx);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_task_handler */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_handler_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_task_handler);
    

/*
 * lvgl extension definition for:
 * inline static int lv_version_major(void)
 */

STATIC mp_obj_t mp_lv_version_major(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    int _res = ((int (*)(void))lv_func_ptr)();
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_major_mpobj, 0, mp_lv_version_major, lv_version_major);
    
/* Reusing lv_version_major for lv_version_minor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_minor_mpobj, 0, mp_lv_version_major, lv_version_minor);
    
/* Reusing lv_version_major for lv_version_patch */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_patch_mpobj, 0, mp_lv_version_major, lv_version_patch);
    

/*
 * lvgl extension definition for:
 * inline static const char *lv_version_info(void)
 */

STATIC mp_obj_t mp_lv_version_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const char * _res = ((const char *(*)(void))lv_func_ptr)();
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_info_mpobj, 0, mp_lv_version_info, lv_version_info);
    

/*
 * lvgl extension definition for:
 * extern void mp_lv_init_gc()
 */

STATIC mp_obj_t mp_mp_lv_init_gc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    ((void (*)())lv_func_ptr)();
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_mp_lv_init_gc_mpobj, 0, mp_mp_lv_init_gc, mp_lv_init_gc);
    

/*
 * lvgl extension definition for:
 * void lv_init(void)
 */

STATIC mp_obj_t mp_lv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    ((void (*)(void))lv_func_ptr)();
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_init_mpobj, 0, mp_lv_init, lv_init);
    
/* Reusing lv_init for lv_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_deinit_mpobj, 0, mp_lv_init, lv_deinit);
    

/*
 * lvgl extension definition for:
 * bool lv_is_initialized(void)
 */

STATIC mp_obj_t mp_lv_is_initialized(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    bool _res = ((bool (*)(void))lv_func_ptr)();
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_is_initialized_mpobj, 0, mp_lv_is_initialized, lv_is_initialized);
    
/* Reusing lv_init for lv_mem_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_init_mpobj, 0, mp_lv_init, lv_mem_init);
    
/* Reusing lv_init for lv_mem_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_deinit_mpobj, 0, mp_lv_init, lv_mem_deinit);
    

/*
 * lvgl extension definition for:
 * lv_mem_pool_t lv_mem_add_pool(void *mem, size_t bytes)
 */

STATIC mp_obj_t mp_lv_mem_add_pool(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *mem = mp_to_ptr(mp_args[0]);
    size_t bytes = (size_t)mp_obj_get_int(mp_args[1]);
    lv_mem_pool_t _res = ((lv_mem_pool_t (*)(void *, size_t))lv_func_ptr)(mem, bytes);
    return ptr_to_mp(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_add_pool_mpobj, 2, mp_lv_mem_add_pool, lv_mem_add_pool);
    

/*
 * lvgl extension definition for:
 * void lv_mem_remove_pool(lv_mem_pool_t pool)
 */

STATIC mp_obj_t mp_lv_mem_remove_pool(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_mem_pool_t pool = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_mem_pool_t))lv_func_ptr)(pool);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_remove_pool_mpobj, 1, mp_lv_mem_remove_pool, lv_mem_remove_pool);
    

/*
 * lvgl extension definition for:
 * void *lv_malloc(size_t size)
 */

STATIC mp_obj_t mp_lv_malloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    size_t size = (size_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(size_t))lv_func_ptr)(size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_malloc_mpobj, 1, mp_lv_malloc, lv_malloc);
    
/* Reusing lv_malloc for lv_malloc_zeroed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_malloc_zeroed_mpobj, 1, mp_lv_malloc, lv_malloc_zeroed);
    
/* Reusing funcptr_lv_timer_handler_resume_cb_t for lv_free */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_free_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, lv_free);
    

/*
 * lvgl extension definition for:
 * void *lv_realloc(void *data_p, size_t new_size)
 */

STATIC mp_obj_t mp_lv_realloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *data_p = mp_to_ptr(mp_args[0]);
    size_t new_size = (size_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(void *, size_t))lv_func_ptr)(data_p, new_size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_realloc_mpobj, 2, mp_lv_realloc, lv_realloc);
    
/* Reusing lv_malloc for lv_malloc_core */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_malloc_core_mpobj, 1, mp_lv_malloc, lv_malloc_core);
    
/* Reusing funcptr_lv_timer_handler_resume_cb_t for lv_free_core */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_free_core_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, lv_free_core);
    
/* Reusing lv_realloc for lv_realloc_core */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_realloc_core_mpobj, 2, mp_lv_realloc, lv_realloc_core);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_mem_test_core(void)
 */

STATIC mp_obj_t mp_lv_mem_test_core(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_result_t _res = ((lv_result_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_test_core_mpobj, 0, mp_lv_mem_test_core, lv_mem_test_core);
    
/* Reusing lv_mem_test_core for lv_mem_test */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_test_mpobj, 0, mp_lv_mem_test_core, lv_mem_test);
    

/*
 * lvgl extension definition for:
 * void *lv_memcpy(void *dst, const void *src, size_t len)
 */

STATIC mp_obj_t mp_lv_memcpy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    const void *src = (const void *)mp_to_ptr(mp_args[1]);
    size_t len = (size_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(void *, const void *, size_t))lv_func_ptr)(dst, src, len);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memcpy_mpobj, 3, mp_lv_memcpy, lv_memcpy);
    

/*
 * lvgl extension definition for:
 * void lv_memset(void *dst, uint8_t v, size_t len)
 */

STATIC mp_obj_t mp_lv_memset(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    uint8_t v = (uint8_t)mp_obj_get_int(mp_args[1]);
    size_t len = (size_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(void *, uint8_t, size_t))lv_func_ptr)(dst, v, len);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memset_mpobj, 3, mp_lv_memset, lv_memset);
    
/* Reusing lv_memcpy for lv_memmove */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memmove_mpobj, 3, mp_lv_memcpy, lv_memmove);
    

/*
 * lvgl extension definition for:
 * size_t lv_strlen(const char *str)
 */

STATIC mp_obj_t mp_lv_strlen(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *str = (const char *)(char*)convert_from_str(mp_args[0]);
    size_t _res = ((size_t (*)(const char *))lv_func_ptr)(str);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_strlen_mpobj, 1, mp_lv_strlen, lv_strlen);
    

/*
 * lvgl extension definition for:
 * char *lv_strncpy(char *dst, const char *src, size_t dest_size)
 */

STATIC mp_obj_t mp_lv_strncpy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *dst = (char*)convert_from_str(mp_args[0]);
    const char *src = (const char *)(char*)convert_from_str(mp_args[1]);
    size_t dest_size = (size_t)mp_obj_get_int(mp_args[2]);
    char * _res = ((char *(*)(char *, const char *, size_t))lv_func_ptr)(dst, src, dest_size);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_strncpy_mpobj, 3, mp_lv_strncpy, lv_strncpy);
    

/*
 * lvgl extension definition for:
 * char *lv_strcpy(char *dst, const char *src)
 */

STATIC mp_obj_t mp_lv_strcpy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *dst = (char*)convert_from_str(mp_args[0]);
    const char *src = (const char *)(char*)convert_from_str(mp_args[1]);
    char * _res = ((char *(*)(char *, const char *))lv_func_ptr)(dst, src);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_strcpy_mpobj, 2, mp_lv_strcpy, lv_strcpy);
    

/*
 * lvgl extension definition for:
 * int32_t lv_strcmp(const char *s1, const char *s2)
 */

STATIC mp_obj_t mp_lv_strcmp(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *s1 = (const char *)(char*)convert_from_str(mp_args[0]);
    const char *s2 = (const char *)(char*)convert_from_str(mp_args[1]);
    int32_t _res = ((int32_t (*)(const char *, const char *))lv_func_ptr)(s1, s2);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_strcmp_mpobj, 2, mp_lv_strcmp, lv_strcmp);
    

/*
 * lvgl extension definition for:
 * char *lv_strdup(const char *src)
 */

STATIC mp_obj_t mp_lv_strdup(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *src = (const char *)(char*)convert_from_str(mp_args[0]);
    char * _res = ((char *(*)(const char *))lv_func_ptr)(src);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_strdup_mpobj, 1, mp_lv_strdup, lv_strdup);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * int lv_snprintf(char *buffer, size_t count, const char *format, ...)
 */
    

/*
 * Function NOT generated:
 * Missing conversion to va_list
 * int lv_vsnprintf(char *buffer, size_t count, const char *format, va_list va)
 */
    
/* Reusing funcptr_lv_delay_cb_t for lv_tick_inc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_inc_mpobj, 1, mp_funcptr_lv_delay_cb_t, lv_tick_inc);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_tick_get */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_get_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_tick_get);
    
/* Reusing lv_timer_handler_run_in_period for lv_tick_elaps */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_elaps_mpobj, 1, mp_lv_timer_handler_run_in_period, lv_tick_elaps);
    
/* Reusing funcptr_lv_delay_cb_t for lv_delay_ms */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_delay_ms_mpobj, 1, mp_funcptr_lv_delay_cb_t, lv_delay_ms);
    

/*
 * Function NOT generated:
 * Callback argument 'lv_tick_get_cb_t cb' cannot be the first argument! We assume the first argument contains the user_data
 * lv_tick_get_cb_t cb
 */
    

/*
 * lvgl extension definition for:
 * void lv_tick_set_cb(lv_tick_get_cb_t cb)
 */

STATIC mp_obj_t mp_lv_tick_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_tick_get_cb_t cb = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_tick_get_cb_t))lv_func_ptr)(cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_set_cb_mpobj, 1, mp_lv_tick_set_cb, lv_tick_set_cb);
    

/*
 * Function NOT generated:
 * Callback argument 'lv_delay_cb_t cb' cannot be the first argument! We assume the first argument contains the user_data
 * lv_delay_cb_t cb
 */
    

/*
 * lvgl extension definition for:
 * void lv_delay_set_cb(lv_delay_cb_t cb)
 */

STATIC mp_obj_t mp_lv_delay_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_delay_cb_t cb = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_delay_cb_t))lv_func_ptr)(cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_delay_set_cb_mpobj, 1, mp_lv_delay_set_cb, lv_delay_set_cb);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_timer_handler */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_handler_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_timer_handler);
    
/* Reusing lv_init for lv_timer_periodic_handler */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_periodic_handler_mpobj, 0, mp_lv_init, lv_timer_periodic_handler);
    

/*
 * Function NOT generated:
 * Callback argument 'lv_timer_handler_resume_cb_t cb' cannot be the first argument! We assume the first argument contains the user_data
 * lv_timer_handler_resume_cb_t cb
 */
    

/*
 * lvgl extension definition for:
 * void lv_timer_handler_set_resume_cb(lv_timer_handler_resume_cb_t cb, void *data)
 */

STATIC mp_obj_t mp_lv_timer_handler_set_resume_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_handler_resume_cb_t cb = mp_to_ptr(mp_args[0]);
    void *data = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_timer_handler_resume_cb_t, void *))lv_func_ptr)(cb, data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_handler_set_resume_cb_mpobj, 2, mp_lv_timer_handler_set_resume_cb, lv_timer_handler_set_resume_cb);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_create_basic(void)
 */

STATIC mp_obj_t mp_lv_timer_create_basic(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_timer_t * _res = ((lv_timer_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_create_basic_mpobj, 0, mp_lv_timer_create_basic, lv_timer_create_basic);
    

/*
 * Callback function lv_timer_create_timer_xcb
 * void lv_timer_cb_t(lv_timer_t *)
 */

GENMPY_UNUSED STATIC void lv_timer_create_timer_xcb_callback(lv_timer_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_timer_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_timer_create_timer_xcb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void *user_data)
 */

STATIC mp_obj_t mp_lv_timer_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    void *timer_xcb = mp_lv_callback(mp_args[0], &lv_timer_create_timer_xcb_callback, MP_QSTR_lv_timer_create_timer_xcb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_timer_cb_t, uint32_t, void *))lv_func_ptr)(timer_xcb, period, user_data);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_create_mpobj, 3, mp_lv_timer_create, lv_timer_create);
    
/* Reusing lv_obj_enable_style_refresh for lv_timer_enable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_enable_mpobj, 1, mp_lv_obj_enable_style_refresh, lv_timer_enable);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_timer_get_idle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_get_idle_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_timer_get_idle);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_timer_get_time_until_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_get_time_until_next_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_timer_get_time_until_next);
    
/* Reusing lv_trigo_cos for lv_trigo_sin */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_trigo_sin_mpobj, 1, mp_lv_trigo_cos, lv_trigo_sin);
    

/*
 * lvgl extension definition for:
 * int32_t lv_cubic_bezier(int32_t x, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
 */

STATIC mp_obj_t mp_lv_cubic_bezier(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t x = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t x1 = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y1 = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t x2 = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t y2 = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t _res = ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))lv_func_ptr)(x, x1, y1, x2, y2);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_cubic_bezier_mpobj, 5, mp_lv_cubic_bezier, lv_cubic_bezier);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_atan2(int x, int y)
 */

STATIC mp_obj_t mp_lv_atan2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int x = (int)mp_obj_get_int(mp_args[0]);
    int y = (int)mp_obj_get_int(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(int, int))lv_func_ptr)(x, y);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_atan2_mpobj, 2, mp_lv_atan2, lv_atan2);
    

/*
 * Struct lv_sqrt_res_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type();

STATIC inline void* mp_write_ptr_lv_sqrt_res_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_sqrt_res_t_type()));
    return (lv_sqrt_res_t*)self->data;
}

#define mp_write_lv_sqrt_res_t(struct_obj) *((lv_sqrt_res_t*)mp_write_ptr_lv_sqrt_res_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_sqrt_res_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_sqrt_res_t_type(), field);
}

#define mp_read_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(copy_buffer(&field, sizeof(lv_sqrt_res_t)))
#define mp_read_byref_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(&field)

STATIC void mp_lv_sqrt_res_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_sqrt_res_t *data = (lv_sqrt_res_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_i: dest[0] = mp_obj_new_int_from_uint(data->i); break; // converting from uint16_t;
            case MP_QSTR_f: dest[0] = mp_obj_new_int_from_uint(data->f); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_i: data->i = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_f: data->f = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_sqrt_res_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_sqrt_res_t");
}

STATIC const mp_obj_dict_t mp_lv_sqrt_res_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_sqrt_res_t_type,
    MP_QSTR_lv_sqrt_res_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_sqrt_res_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_sqrt_res_t_attr,
    locals_dict, &mp_lv_sqrt_res_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type()
{
    return &mp_lv_sqrt_res_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_sqrt(uint32_t x, lv_sqrt_res_t *q, uint32_t mask)
 */

STATIC mp_obj_t mp_lv_sqrt(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t x = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_sqrt_res_t *q = mp_write_ptr_lv_sqrt_res_t(mp_args[1]);
    uint32_t mask = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(uint32_t, lv_sqrt_res_t *, uint32_t))lv_func_ptr)(x, q, mask);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_sqrt_mpobj, 3, mp_lv_sqrt, lv_sqrt);
    

STATIC const mp_rom_map_elem_t mp_lv_sqrt_res_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_sqrt_res_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_sqrt_res_t_locals_dict, mp_lv_sqrt_res_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * int64_t lv_pow(int64_t base, int8_t exp)
 */

STATIC mp_obj_t mp_lv_pow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int64_t base = (int64_t)mp_obj_get_ull(mp_args[0]);
    int8_t exp = (int8_t)mp_obj_get_int(mp_args[1]);
    int64_t _res = ((int64_t (*)(int64_t, int8_t))lv_func_ptr)(base, exp);
    return mp_obj_new_int_from_ll(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_pow_mpobj, 2, mp_lv_pow, lv_pow);
    
/* Reusing lv_cubic_bezier for lv_map */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_map_mpobj, 5, mp_lv_cubic_bezier, lv_map);
    
/* Reusing funcptr_lv_delay_cb_t for lv_rand_set_seed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_rand_set_seed_mpobj, 1, mp_funcptr_lv_delay_cb_t, lv_rand_set_seed);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_rand(uint32_t min, uint32_t max)
 */

STATIC mp_obj_t mp_lv_rand(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t min = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t max = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(uint32_t, uint32_t))lv_func_ptr)(min, max);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_rand_mpobj, 2, mp_lv_rand, lv_rand);
    

/*
 * Callback function lv_async_call_async_xcb
 * void lv_async_cb_t(void *)
 */

GENMPY_UNUSED STATIC void lv_async_call_async_xcb_callback(void *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_async_call_async_xcb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_result_t lv_async_call(lv_async_cb_t async_xcb, void *user_data)
 */

STATIC mp_obj_t mp_lv_async_call(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *async_xcb = mp_lv_callback(mp_args[0], &lv_async_call_async_xcb_callback, MP_QSTR_lv_async_call_async_xcb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_result_t _res = ((lv_result_t (*)(lv_async_cb_t, void *))lv_func_ptr)(async_xcb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_async_call_mpobj, 2, mp_lv_async_call, lv_async_call);
    
/* Reusing lv_async_call for lv_async_call_cancel */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_async_call_cancel_mpobj, 2, mp_lv_async_call, lv_async_call_cancel);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * bool lv_anim_delete(void *var, lv_anim_exec_xcb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    bool _res = ((bool (*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_delete_mpobj, 2, mp_lv_anim_delete, lv_anim_delete);
    
/* Reusing lv_init for lv_anim_delete_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_delete_all_mpobj, 0, mp_lv_init, lv_anim_delete_all);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_anim_get(void *var, lv_anim_exec_xcb_t exec_cb)
 */

STATIC mp_obj_t mp_lv_anim_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    lv_anim_t * _res = ((lv_anim_t *(*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_get_mpobj, 2, mp_lv_anim_get, lv_anim_get);
    
/* Reusing lv_timer_create_basic for lv_anim_get_timer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_get_timer_mpobj, 0, mp_lv_timer_create_basic, lv_anim_get_timer);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_anim_count_running(void)
 */

STATIC mp_obj_t mp_lv_anim_count_running(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint16_t _res = ((uint16_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_count_running_mpobj, 0, mp_lv_anim_count_running, lv_anim_count_running);
    
/* Reusing lv_timer_handler_run_in_period for lv_anim_speed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_speed_mpobj, 1, mp_lv_timer_handler_run_in_period, lv_anim_speed);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_anim_speed_clamped(uint32_t speed, uint32_t min_time, uint32_t max_time)
 */

STATIC mp_obj_t mp_lv_anim_speed_clamped(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t speed = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t min_time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t max_time = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(uint32_t, uint32_t, uint32_t))lv_func_ptr)(speed, min_time, max_time);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_speed_clamped_mpobj, 3, mp_lv_anim_speed_clamped, lv_anim_speed_clamped);
    
/* Reusing lv_init for lv_anim_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_refr_now_mpobj, 0, mp_lv_init, lv_anim_refr_now);
    

/*
 * lvgl extension definition for:
 * lv_anim_timeline_t *lv_anim_timeline_create(void)
 */

STATIC mp_obj_t mp_lv_anim_timeline_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_anim_timeline_t * _res = ((lv_anim_timeline_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_anim_timeline_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_create_mpobj, 0, mp_lv_anim_timeline_create, lv_anim_timeline_create);
    
/* Reusing lv_color_format_get_size for lv_color_format_get_bpp */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_format_get_bpp_mpobj, 1, mp_lv_color_format_get_size, lv_color_format_get_bpp);
    

/*
 * lvgl extension definition for:
 * bool lv_color_format_has_alpha(lv_color_format_t src_cf)
 */

STATIC mp_obj_t mp_lv_color_format_has_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_format_t src_cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(lv_color_format_t))lv_func_ptr)(src_cf);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_format_has_alpha_mpobj, 1, mp_lv_color_format_has_alpha, lv_color_format_has_alpha);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
 */

STATIC mp_obj_t mp_lv_color_hsv_to_rgb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t h = (uint16_t)mp_obj_get_int(mp_args[0]);
    uint8_t s = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t v = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint16_t, uint8_t, uint8_t))lv_func_ptr)(h, s, v);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hsv_to_rgb_mpobj, 3, mp_lv_color_hsv_to_rgb, lv_color_hsv_to_rgb);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)
 */

STATIC mp_obj_t mp_lv_color_rgb_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r8 = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g8 = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b8 = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r8, g8, b8);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_rgb_to_hsv_mpobj, 3, mp_lv_color_rgb_to_hsv, lv_color_rgb_to_hsv);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_palette_main(lv_palette_t p)
 */

STATIC mp_obj_t mp_lv_palette_main(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_palette_t p = (int)mp_obj_get_int(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_palette_t))lv_func_ptr)(p);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_main_mpobj, 1, mp_lv_palette_main, lv_palette_main);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)
 */

STATIC mp_obj_t mp_lv_palette_lighten(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_palette_t p = (int)mp_obj_get_int(mp_args[0]);
    uint8_t lvl = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(lv_palette_t, uint8_t))lv_func_ptr)(p, lvl);
    return mp_read_lv_color_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_lighten_mpobj, 2, mp_lv_palette_lighten, lv_palette_lighten);
    
/* Reusing lv_palette_lighten for lv_palette_darken */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_darken_mpobj, 2, mp_lv_palette_lighten, lv_palette_darken);
    
#define funcptr_lv_draw_buf_malloc_cb NULL


/*
 * lvgl extension definition for:
 * void *lv_draw_buf_malloc_cb(size_t size, lv_color_format_t color_format)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_buf_malloc_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    size_t size = (size_t)mp_obj_get_int(mp_args[0]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(size_t, lv_color_format_t))lv_func_ptr)(size, color_format);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_buf_malloc_cb_mpobj, 2, mp_funcptr_lv_draw_buf_malloc_cb, funcptr_lv_draw_buf_malloc_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_buf_malloc_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_buf_malloc_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_buf_handlers_t_buf_malloc_cb_callback'
 * lv_draw_buf_malloc_cb buf_malloc_cb
 */
    
#define funcptr_lv_draw_buf_free_cb NULL

/* Reusing funcptr_lv_timer_handler_resume_cb_t for funcptr_lv_draw_buf_free_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_buf_free_cb_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, funcptr_lv_draw_buf_free_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_buf_free_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_buf_free_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_buf_handlers_t_buf_free_cb_callback'
 * lv_draw_buf_free_cb buf_free_cb
 */
    
#define funcptr_lv_draw_buf_align_cb NULL


/*
 * lvgl extension definition for:
 * void *lv_draw_buf_align_cb(void *buf, lv_color_format_t color_format)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_buf_align_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *buf = mp_to_ptr(mp_args[0]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(void *, lv_color_format_t))lv_func_ptr)(buf, color_format);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_buf_align_cb_mpobj, 2, mp_funcptr_lv_draw_buf_align_cb, funcptr_lv_draw_buf_align_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_buf_align_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_buf_align_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_buf_handlers_t_align_pointer_cb_callback'
 * lv_draw_buf_align_cb align_pointer_cb
 */
    
#define funcptr_lv_draw_buf_invalidate_cache_cb NULL


/*
 * lvgl extension definition for:
 * void lv_draw_buf_invalidate_cache_cb(void *buf, uint32_t stride, lv_color_format_t color_format, const lv_area_t *area)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_buf_invalidate_cache_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *buf = mp_to_ptr(mp_args[0]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[2]);
    const lv_area_t *area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[3]);
    ((void (*)(void *, uint32_t, lv_color_format_t, const lv_area_t *))lv_func_ptr)(buf, stride, color_format, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_buf_invalidate_cache_cb_mpobj, 4, mp_funcptr_lv_draw_buf_invalidate_cache_cb, funcptr_lv_draw_buf_invalidate_cache_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_buf_invalidate_cache_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_buf_invalidate_cache_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_buf_handlers_t_invalidate_cache_cb_callback'
 * lv_draw_buf_invalidate_cache_cb invalidate_cache_cb
 */
    
#define funcptr_lv_draw_buf_width_to_stride_cb NULL


/*
 * lvgl extension definition for:
 * uint32_t lv_draw_buf_width_to_stride_cb(uint32_t w, lv_color_format_t color_format)
 */

STATIC mp_obj_t mp_funcptr_lv_draw_buf_width_to_stride_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t w = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(uint32_t, lv_color_format_t))lv_func_ptr)(w, color_format);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_buf_width_to_stride_cb_mpobj, 2, mp_funcptr_lv_draw_buf_width_to_stride_cb, funcptr_lv_draw_buf_width_to_stride_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_buf_width_to_stride_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_buf_width_to_stride_cb_mpobj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_buf_handlers_t_width_to_stride_cb_callback'
 * lv_draw_buf_width_to_stride_cb width_to_stride_cb
 */
    

/*
 * Struct lv_draw_buf_handlers_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_buf_handlers_t_type();

STATIC inline void* mp_write_ptr_lv_draw_buf_handlers_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_buf_handlers_t_type()));
    return (lv_draw_buf_handlers_t*)self->data;
}

#define mp_write_lv_draw_buf_handlers_t(struct_obj) *((lv_draw_buf_handlers_t*)mp_write_ptr_lv_draw_buf_handlers_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_buf_handlers_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_buf_handlers_t_type(), field);
}

#define mp_read_lv_draw_buf_handlers_t(field) mp_read_ptr_lv_draw_buf_handlers_t(copy_buffer(&field, sizeof(lv_draw_buf_handlers_t)))
#define mp_read_byref_lv_draw_buf_handlers_t(field) mp_read_ptr_lv_draw_buf_handlers_t(&field)

STATIC void mp_lv_draw_buf_handlers_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_buf_handlers_t *data = (lv_draw_buf_handlers_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf_malloc_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_buf_malloc_cb_mpobj, data->buf_malloc_cb, NULL ,MP_QSTR_lv_draw_buf_handlers_t_buf_malloc_cb, NULL); break; // converting from callback lv_draw_buf_malloc_cb;
            case MP_QSTR_buf_free_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_buf_free_cb_mpobj, data->buf_free_cb, NULL ,MP_QSTR_lv_draw_buf_handlers_t_buf_free_cb, NULL); break; // converting from callback lv_draw_buf_free_cb;
            case MP_QSTR_align_pointer_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_buf_align_cb_mpobj, data->align_pointer_cb, NULL ,MP_QSTR_lv_draw_buf_handlers_t_align_pointer_cb, NULL); break; // converting from callback lv_draw_buf_align_cb;
            case MP_QSTR_invalidate_cache_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_buf_invalidate_cache_cb_mpobj, data->invalidate_cache_cb, NULL ,MP_QSTR_lv_draw_buf_handlers_t_invalidate_cache_cb, NULL); break; // converting from callback lv_draw_buf_invalidate_cache_cb;
            case MP_QSTR_width_to_stride_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_buf_width_to_stride_cb_mpobj, data->width_to_stride_cb, NULL ,MP_QSTR_lv_draw_buf_handlers_t_width_to_stride_cb, NULL); break; // converting from callback lv_draw_buf_width_to_stride_cb;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf_malloc_cb: data->buf_malloc_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_buf_handlers_t_buf_malloc_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_buf_malloc_cb;
                case MP_QSTR_buf_free_cb: data->buf_free_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_buf_handlers_t_buf_free_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_buf_free_cb;
                case MP_QSTR_align_pointer_cb: data->align_pointer_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_buf_handlers_t_align_pointer_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_buf_align_cb;
                case MP_QSTR_invalidate_cache_cb: data->invalidate_cache_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_buf_handlers_t_invalidate_cache_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_buf_invalidate_cache_cb;
                case MP_QSTR_width_to_stride_cb: data->width_to_stride_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_buf_handlers_t_width_to_stride_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_draw_buf_width_to_stride_cb;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_buf_handlers_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_buf_handlers_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_buf_handlers_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_buf_handlers_t_type,
    MP_QSTR_lv_draw_buf_handlers_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_buf_handlers_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_buf_handlers_t_attr,
    locals_dict, &mp_lv_draw_buf_handlers_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_buf_handlers_t_type()
{
    return &mp_lv_draw_buf_handlers_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_handlers_t *lv_draw_buf_get_handlers(void)
 */

STATIC mp_obj_t mp_lv_draw_buf_get_handlers(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_draw_buf_handlers_t * _res = ((lv_draw_buf_handlers_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_draw_buf_handlers_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_buf_get_handlers_mpobj, 0, mp_lv_draw_buf_get_handlers, lv_draw_buf_get_handlers);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_buf_handlers_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___SIZE__), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_buf_handlers_t))) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_buf_handlers_t_locals_dict, mp_lv_draw_buf_handlers_t_locals_dict_table);
        
/* Reusing funcptr_lv_draw_buf_align_cb for lv_draw_buf_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_buf_align_mpobj, 2, mp_funcptr_lv_draw_buf_align_cb, lv_draw_buf_align);
    
/* Reusing funcptr_lv_draw_buf_invalidate_cache_cb for lv_draw_buf_invalidate_cache */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_buf_invalidate_cache_mpobj, 4, mp_funcptr_lv_draw_buf_invalidate_cache_cb, lv_draw_buf_invalidate_cache);
    
/* Reusing funcptr_lv_draw_buf_width_to_stride_cb for lv_draw_buf_width_to_stride */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_buf_width_to_stride_mpobj, 2, mp_funcptr_lv_draw_buf_width_to_stride_cb, lv_draw_buf_width_to_stride);
    

/*
 * lvgl extension definition for:
 * lv_draw_buf_t *lv_draw_buf_create(uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride)
 */

STATIC mp_obj_t mp_lv_draw_buf_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t w = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t h = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint32_t stride = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_draw_buf_t * _res = ((lv_draw_buf_t *(*)(uint32_t, uint32_t, lv_color_format_t, uint32_t))lv_func_ptr)(w, h, cf, stride);
    return mp_read_ptr_lv_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_buf_create_mpobj, 4, mp_lv_draw_buf_create, lv_draw_buf_create);
    

/*
 * Callback function lv_thread_init_callback
 * void callback(void *)
 */

GENMPY_UNUSED STATIC void lv_thread_init_callback_callback(void *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_thread_init_callback)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * lv_result_t lv_thread_init(lv_thread_t *thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size, void *user_data)
 */

STATIC mp_obj_t mp_lv_thread_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[4]);
    lv_thread_prio_t prio = (int)mp_obj_get_int(mp_args[1]);
    void *callback = mp_lv_callback(mp_args[2], &lv_thread_init_callback_callback, MP_QSTR_lv_thread_init_callback, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    size_t stack_size = (size_t)mp_obj_get_int(mp_args[3]);
    lv_thread_t *thread = mp_to_ptr(mp_args[0]);
    lv_result_t _res = ((lv_result_t (*)(lv_thread_t *, lv_thread_prio_t, void (*)(void *), size_t, void *))lv_func_ptr)(thread, prio, callback, stack_size, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_init_mpobj, 5, mp_lv_thread_init, lv_thread_init);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_thread_delete(lv_thread_t *thread)
 */

STATIC mp_obj_t mp_lv_thread_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_thread_t *thread = mp_to_ptr(mp_args[0]);
    lv_result_t _res = ((lv_result_t (*)(lv_thread_t *))lv_func_ptr)(thread);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_delete_mpobj, 1, mp_lv_thread_delete, lv_thread_delete);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_mutex_init(lv_mutex_t *mutex)
 */

STATIC mp_obj_t mp_lv_mutex_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_mutex_t *mutex = mp_array_to_i32ptr(mp_args[0]);
    lv_result_t _res = ((lv_result_t (*)(lv_mutex_t *))lv_func_ptr)(mutex);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mutex_init_mpobj, 1, mp_lv_mutex_init, lv_mutex_init);
    
/* Reusing lv_mutex_init for lv_mutex_lock */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mutex_lock_mpobj, 1, mp_lv_mutex_init, lv_mutex_lock);
    
/* Reusing lv_mutex_init for lv_mutex_lock_isr */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mutex_lock_isr_mpobj, 1, mp_lv_mutex_init, lv_mutex_lock_isr);
    
/* Reusing lv_mutex_init for lv_mutex_unlock */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mutex_unlock_mpobj, 1, mp_lv_mutex_init, lv_mutex_unlock);
    
/* Reusing lv_mutex_init for lv_mutex_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mutex_delete_mpobj, 1, mp_lv_mutex_init, lv_mutex_delete);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_thread_sync_init(lv_thread_sync_t *sync)
 */

STATIC mp_obj_t mp_lv_thread_sync_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_thread_sync_t *sync = mp_to_ptr(mp_args[0]);
    lv_result_t _res = ((lv_result_t (*)(lv_thread_sync_t *))lv_func_ptr)(sync);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_sync_init_mpobj, 1, mp_lv_thread_sync_init, lv_thread_sync_init);
    
/* Reusing lv_thread_sync_init for lv_thread_sync_wait */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_sync_wait_mpobj, 1, mp_lv_thread_sync_init, lv_thread_sync_wait);
    
/* Reusing lv_thread_sync_init for lv_thread_sync_signal */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_sync_signal_mpobj, 1, mp_lv_thread_sync_init, lv_thread_sync_signal);
    
/* Reusing lv_thread_sync_init for lv_thread_sync_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_thread_sync_delete_mpobj, 1, mp_lv_thread_sync_init, lv_thread_sync_delete);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_cache_entry_get_size(const uint32_t node_size)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const uint32_t node_size = (const uint32_t)(uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const uint32_t))lv_func_ptr)(node_size);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_cache_entry_get_size_mpobj, 1, mp_lv_cache_entry_get_size, lv_cache_entry_get_size);
    

/*
 * lvgl extension definition for:
 * lv_cache_entry_t *lv_cache_entry_get_entry(void *data, const uint32_t node_size)
 */

STATIC mp_obj_t mp_lv_cache_entry_get_entry(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *data = mp_to_ptr(mp_args[0]);
    const uint32_t node_size = (const uint32_t)(uint32_t)mp_obj_get_int(mp_args[1]);
    lv_cache_entry_t * _res = ((lv_cache_entry_t *(*)(void *, const uint32_t))lv_func_ptr)(data, node_size);
    return mp_read_ptr_lv_cache_entry_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_cache_entry_get_entry_mpobj, 2, mp_lv_cache_entry_get_entry, lv_cache_entry_get_entry);
    

/*
 * lvgl extension definition for:
 * lv_cache_entry_t *lv_cache_entry_alloc(const uint32_t node_size, const lv_cache_t *cache)
 */

STATIC mp_obj_t mp_lv_cache_entry_alloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const uint32_t node_size = (const uint32_t)(uint32_t)mp_obj_get_int(mp_args[0]);
    const lv_cache_t *cache = (const lv_cache_t *)mp_write_ptr_lv_cache_t(mp_args[1]);
    lv_cache_entry_t * _res = ((lv_cache_entry_t *(*)(const uint32_t, const lv_cache_t *))lv_func_ptr)(node_size, cache);
    return mp_read_ptr_lv_cache_entry_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_cache_entry_alloc_mpobj, 2, mp_lv_cache_entry_alloc, lv_cache_entry_alloc);
    

/*
 * lvgl extension definition for:
 * void lv_text_get_size(lv_point_t *size_res, const char *text, const lv_font_t *font, int32_t letter_space, int32_t line_space, int32_t max_width, lv_text_flag_t flag)
 */

STATIC mp_obj_t mp_lv_text_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *size_res = mp_write_ptr_lv_point_t(mp_args[0]);
    const char *text = (const char *)(char*)convert_from_str(mp_args[1]);
    const lv_font_t *font = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[2]);
    int32_t letter_space = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t line_space = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t max_width = (int32_t)mp_obj_get_int(mp_args[5]);
    lv_text_flag_t flag = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_point_t *, const char *, const lv_font_t *, int32_t, int32_t, int32_t, lv_text_flag_t))lv_func_ptr)(size_res, text, font, letter_space, line_space, max_width, flag);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_text_get_size_mpobj, 7, mp_lv_text_get_size, lv_text_get_size);
    

/*
 * lvgl extension definition for:
 * int32_t lv_text_get_width(const char *txt, uint32_t length, const lv_font_t *font, int32_t letter_space)
 */

STATIC mp_obj_t mp_lv_text_get_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *txt = (const char *)(char*)convert_from_str(mp_args[0]);
    uint32_t length = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t *font = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[2]);
    int32_t letter_space = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t _res = ((int32_t (*)(const char *, uint32_t, const lv_font_t *, int32_t))lv_func_ptr)(txt, length, font, letter_space);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_text_get_width_mpobj, 4, mp_lv_text_get_width, lv_text_get_width);
    

/*
 * Callback function lv_layout_register_cb
 * void lv_layout_update_cb_t(lv_obj_t *, void *user_data)
 */

GENMPY_UNUSED STATIC void lv_layout_register_cb_callback(lv_obj_t *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg1);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_layout_register_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * uint32_t lv_layout_register(lv_layout_update_cb_t cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_layout_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *cb = mp_lv_callback(mp_args[0], &lv_layout_register_cb_callback, MP_QSTR_lv_layout_register_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    uint32_t _res = ((uint32_t (*)(lv_layout_update_cb_t, void *))lv_func_ptr)(cb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layout_register_mpobj, 2, mp_lv_layout_register, lv_layout_register);
    
/* Reusing lv_init for lv_flex_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_flex_init_mpobj, 0, mp_lv_init, lv_flex_init);
    
/* Reusing lv_init for lv_grid_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_grid_init_mpobj, 0, mp_lv_init, lv_grid_init);
    

/*
 * lvgl extension definition for:
 * lv_style_prop_t lv_style_register_prop(uint8_t flag)
 */

STATIC mp_obj_t mp_lv_style_register_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t flag = (uint8_t)mp_obj_get_int(mp_args[0]);
    lv_style_prop_t _res = ((lv_style_prop_t (*)(uint8_t))lv_func_ptr)(flag);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_register_prop_mpobj, 1, mp_lv_style_register_prop, lv_style_register_prop);
    

/*
 * lvgl extension definition for:
 * lv_style_prop_t lv_style_get_num_custom_props(void)
 */

STATIC mp_obj_t mp_lv_style_get_num_custom_props(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_style_prop_t _res = ((lv_style_prop_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_get_num_custom_props_mpobj, 0, mp_lv_style_get_num_custom_props, lv_style_get_num_custom_props);
    

/*
 * lvgl extension definition for:
 * lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)
 */

STATIC mp_obj_t mp_lv_style_prop_get_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_prop_t prop = (uint8_t)mp_obj_get_int(mp_args[0]);
    lv_style_value_t _res = ((lv_style_value_t (*)(lv_style_prop_t))lv_func_ptr)(prop);
    return mp_read_lv_style_value_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_prop_get_default_mpobj, 1, mp_lv_style_prop_get_default, lv_style_prop_get_default);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_event_send(lv_event_list_t *list, lv_event_t *e, bool preprocess)
 */

STATIC mp_obj_t mp_lv_event_send(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[1]);
    bool preprocess = mp_obj_is_true(mp_args[2]);
    lv_result_t _res = ((lv_result_t (*)(lv_event_list_t *, lv_event_t *, bool))lv_func_ptr)(list, e, preprocess);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_send_mpobj, 3, mp_lv_event_send, lv_event_send);
    

/*
 * Callback function lv_event_add_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_event_add_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_event_add_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * lvgl extension definition for:
 * void lv_event_add(lv_event_list_t *list, lv_event_cb_t cb, lv_event_code_t filter, void *user_data)
 */

STATIC mp_obj_t mp_lv_event_add(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *cb = mp_lv_callback(mp_args[1], &lv_event_add_cb_callback, MP_QSTR_lv_event_add_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    lv_event_code_t filter = (int)mp_obj_get_int(mp_args[2]);
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_event_list_t *, lv_event_cb_t, lv_event_code_t, void *))lv_func_ptr)(list, cb, filter, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_add_mpobj, 4, mp_lv_event_add, lv_event_add);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_event_get_count(lv_event_list_t *list)
 */

STATIC mp_obj_t mp_lv_event_get_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_event_list_t *))lv_func_ptr)(list);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_get_count_mpobj, 1, mp_lv_event_get_count, lv_event_get_count);
    

/*
 * lvgl extension definition for:
 * lv_event_dsc_t *lv_event_get_dsc(lv_event_list_t *list, uint32_t index)
 */

STATIC mp_obj_t mp_lv_event_get_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_event_dsc_t * _res = ((lv_event_dsc_t *(*)(lv_event_list_t *, uint32_t))lv_func_ptr)(list, index);
    return mp_read_ptr_lv_event_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_get_dsc_mpobj, 2, mp_lv_event_get_dsc, lv_event_get_dsc);
    

/*
 * lvgl extension definition for:
 * bool lv_event_remove(lv_event_list_t *list, uint32_t index)
 */

STATIC mp_obj_t mp_lv_event_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_event_list_t *, uint32_t))lv_func_ptr)(list, index);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_remove_mpobj, 2, mp_lv_event_remove, lv_event_remove);
    

/*
 * lvgl extension definition for:
 * void lv_event_remove_all(lv_event_list_t *list)
 */

STATIC mp_obj_t mp_lv_event_remove_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_list_t *list = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_event_list_t *))lv_func_ptr)(list);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_remove_all_mpobj, 1, mp_lv_event_remove_all, lv_event_remove_all);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_event_register_id */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_register_id_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_event_register_id);
    

/*
 * lvgl extension definition for:
 * lv_fs_drv_t *lv_fs_get_drv(char letter)
 */

STATIC mp_obj_t mp_lv_fs_get_drv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    lv_fs_drv_t * _res = ((lv_fs_drv_t *(*)(char))lv_func_ptr)(letter);
    return mp_read_ptr_lv_fs_drv_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_drv_mpobj, 1, mp_lv_fs_get_drv, lv_fs_get_drv);
    

/*
 * lvgl extension definition for:
 * bool lv_fs_is_ready(char letter)
 */

STATIC mp_obj_t mp_lv_fs_is_ready(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(char))lv_func_ptr)(letter);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_is_ready_mpobj, 1, mp_lv_fs_is_ready, lv_fs_is_ready);
    

/*
 * lvgl extension definition for:
 * char *lv_fs_get_letters(char *buf)
 */

STATIC mp_obj_t mp_lv_fs_get_letters(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *buf = (char*)convert_from_str(mp_args[0]);
    char * _res = ((char *(*)(char *))lv_func_ptr)(buf);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_letters_mpobj, 1, mp_lv_fs_get_letters, lv_fs_get_letters);
    

/*
 * lvgl extension definition for:
 * const char *lv_fs_get_ext(const char *fn)
 */

STATIC mp_obj_t mp_lv_fs_get_ext(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fn = (const char *)(char*)convert_from_str(mp_args[0]);
    const char * _res = ((const char *(*)(const char *))lv_func_ptr)(fn);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_ext_mpobj, 1, mp_lv_fs_get_ext, lv_fs_get_ext);
    
/* Reusing lv_fs_get_letters for lv_fs_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_up_mpobj, 1, mp_lv_fs_get_letters, lv_fs_up);
    
/* Reusing lv_fs_get_ext for lv_fs_get_last */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_last_mpobj, 1, mp_lv_fs_get_ext, lv_fs_get_last);
    
/* Reusing lv_init for lv_draw_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_init_mpobj, 0, mp_lv_init, lv_draw_init);
    
/* Reusing lv_init for lv_draw_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_deinit_mpobj, 0, mp_lv_init, lv_draw_deinit);
    
/* Reusing lv_malloc for lv_draw_create_unit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_create_unit_mpobj, 1, mp_lv_malloc, lv_draw_create_unit);
    

/*
 * lvgl extension definition for:
 * lv_draw_task_t *lv_draw_add_task(lv_layer_t *layer, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_add_task(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[1]);
    lv_draw_task_t * _res = ((lv_draw_task_t *(*)(lv_layer_t *, const lv_area_t *))lv_func_ptr)(layer, coords);
    return mp_read_ptr_lv_draw_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_add_task_mpobj, 2, mp_lv_draw_add_task, lv_draw_add_task);
    

/*
 * lvgl extension definition for:
 * void lv_draw_finalize_task_creation(lv_layer_t *layer, lv_draw_task_t *t)
 */

STATIC mp_obj_t mp_lv_draw_finalize_task_creation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    lv_draw_task_t *t = mp_write_ptr_lv_draw_task_t(mp_args[1]);
    ((void (*)(lv_layer_t *, lv_draw_task_t *))lv_func_ptr)(layer, t);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_finalize_task_creation_mpobj, 2, mp_lv_draw_finalize_task_creation, lv_draw_finalize_task_creation);
    
/* Reusing lv_init for lv_draw_dispatch */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_dispatch_mpobj, 0, mp_lv_init, lv_draw_dispatch);
    
/* Reusing lv_init for lv_draw_dispatch_wait_for_request */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_dispatch_wait_for_request_mpobj, 0, mp_lv_init, lv_draw_dispatch_wait_for_request);
    
/* Reusing lv_init for lv_draw_dispatch_request */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_dispatch_request_mpobj, 0, mp_lv_init, lv_draw_dispatch_request);
    

/*
 * lvgl extension definition for:
 * lv_draw_task_t *lv_draw_get_next_available_task(lv_layer_t *layer, lv_draw_task_t *t_prev, uint8_t draw_unit_id)
 */

STATIC mp_obj_t mp_lv_draw_get_next_available_task(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    lv_draw_task_t *t_prev = mp_write_ptr_lv_draw_task_t(mp_args[1]);
    uint8_t draw_unit_id = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_draw_task_t * _res = ((lv_draw_task_t *(*)(lv_layer_t *, lv_draw_task_t *, uint8_t))lv_func_ptr)(layer, t_prev, draw_unit_id);
    return mp_read_ptr_lv_draw_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_get_next_available_task_mpobj, 3, mp_lv_draw_get_next_available_task, lv_draw_get_next_available_task);
    

/*
 * lvgl extension definition for:
 * lv_layer_t *lv_draw_layer_create(lv_layer_t *parent_layer, lv_color_format_t color_format, const lv_area_t *area)
 */

STATIC mp_obj_t mp_lv_draw_layer_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *parent_layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[1]);
    const lv_area_t *area = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    lv_layer_t * _res = ((lv_layer_t *(*)(lv_layer_t *, lv_color_format_t, const lv_area_t *))lv_func_ptr)(parent_layer, color_format, area);
    return mp_read_ptr_lv_layer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_layer_create_mpobj, 3, mp_lv_draw_layer_create, lv_draw_layer_create);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_layer_alloc_buf(lv_layer_t *layer)
 */

STATIC mp_obj_t mp_lv_draw_layer_alloc_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    void * _res = ((void *(*)(lv_layer_t *))lv_func_ptr)(layer);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_layer_alloc_buf_mpobj, 1, mp_lv_draw_layer_alloc_buf, lv_draw_layer_alloc_buf);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_layer_go_to_xy(lv_layer_t *layer, int32_t x, int32_t y)
 */

STATIC mp_obj_t mp_lv_draw_layer_go_to_xy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    int32_t x = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(lv_layer_t *, int32_t, int32_t))lv_func_ptr)(layer, x, y);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_layer_go_to_xy_mpobj, 3, mp_lv_draw_layer_go_to_xy, lv_draw_layer_go_to_xy);
    

/*
 * lvgl extension definition for:
 * void lv_draw_rect(lv_layer_t *layer, const lv_draw_rect_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_rect_dsc_t *dsc = (const lv_draw_rect_dsc_t *)mp_write_ptr_lv_draw_rect_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_layer_t *, const lv_draw_rect_dsc_t *, const lv_area_t *))lv_func_ptr)(layer, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_rect_mpobj, 3, mp_lv_draw_rect, lv_draw_rect);
    

/*
 * lvgl extension definition for:
 * void lv_draw_label(lv_layer_t *layer, const lv_draw_label_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_label(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_label_dsc_t *dsc = (const lv_draw_label_dsc_t *)mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_layer_t *, const lv_draw_label_dsc_t *, const lv_area_t *))lv_func_ptr)(layer, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_label_mpobj, 3, mp_lv_draw_label, lv_draw_label);
    

/*
 * lvgl extension definition for:
 * void lv_draw_character(lv_layer_t *layer, lv_draw_label_dsc_t *dsc, const lv_point_t *point, uint32_t unicode_letter)
 */

STATIC mp_obj_t mp_lv_draw_character(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_point_t *point = (const lv_point_t *)mp_write_ptr_lv_point_t(mp_args[2]);
    uint32_t unicode_letter = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_layer_t *, lv_draw_label_dsc_t *, const lv_point_t *, uint32_t))lv_func_ptr)(layer, dsc, point, unicode_letter);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_character_mpobj, 4, mp_lv_draw_character, lv_draw_character);
    

/*
 * lvgl extension definition for:
 * void lv_draw_image(lv_layer_t *layer, const lv_draw_image_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC mp_obj_t mp_lv_draw_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_image_dsc_t *dsc = (const lv_draw_image_dsc_t *)mp_write_ptr_lv_draw_image_dsc_t(mp_args[1]);
    const lv_area_t *coords = (const lv_area_t *)mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(lv_layer_t *, const lv_draw_image_dsc_t *, const lv_area_t *))lv_func_ptr)(layer, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_image_mpobj, 3, mp_lv_draw_image, lv_draw_image);
    
/* Reusing lv_draw_image for lv_draw_layer */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_layer_mpobj, 3, mp_lv_draw_image, lv_draw_layer);
    

/*
 * lvgl extension definition for:
 * void lv_draw_arc(lv_layer_t *layer, const lv_draw_arc_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_arc_dsc_t *dsc = (const lv_draw_arc_dsc_t *)mp_write_ptr_lv_draw_arc_dsc_t(mp_args[1]);
    ((void (*)(lv_layer_t *, const lv_draw_arc_dsc_t *))lv_func_ptr)(layer, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_arc_mpobj, 2, mp_lv_draw_arc, lv_draw_arc);
    

/*
 * lvgl extension definition for:
 * void lv_draw_arc_get_area(int32_t x, int32_t y, uint16_t radius, lv_value_precise_t start_angle, lv_value_precise_t end_angle, int32_t w, bool rounded, lv_area_t *area)
 */

STATIC mp_obj_t mp_lv_draw_arc_get_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t x = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t y = (int32_t)mp_obj_get_int(mp_args[1]);
    uint16_t radius = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_value_precise_t start_angle = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_value_precise_t end_angle = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t w = (int32_t)mp_obj_get_int(mp_args[5]);
    bool rounded = mp_obj_is_true(mp_args[6]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[7]);
    ((void (*)(int32_t, int32_t, uint16_t, lv_value_precise_t, lv_value_precise_t, int32_t, bool, lv_area_t *))lv_func_ptr)(x, y, radius, start_angle, end_angle, w, rounded, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_arc_get_area_mpobj, 8, mp_lv_draw_arc_get_area, lv_draw_arc_get_area);
    

/*
 * lvgl extension definition for:
 * void lv_draw_line(lv_layer_t *layer, const lv_draw_line_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_line_dsc_t *dsc = (const lv_draw_line_dsc_t *)mp_write_ptr_lv_draw_line_dsc_t(mp_args[1]);
    ((void (*)(lv_layer_t *, const lv_draw_line_dsc_t *))lv_func_ptr)(layer, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_line_mpobj, 2, mp_lv_draw_line, lv_draw_line);
    

/*
 * lvgl extension definition for:
 * void lv_draw_triangle(lv_layer_t *layer, const lv_draw_triangle_dsc_t *draw_dsc)
 */

STATIC mp_obj_t mp_lv_draw_triangle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_triangle_dsc_t *draw_dsc = (const lv_draw_triangle_dsc_t *)mp_write_ptr_lv_draw_triangle_dsc_t(mp_args[1]);
    ((void (*)(lv_layer_t *, const lv_draw_triangle_dsc_t *))lv_func_ptr)(layer, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_triangle_mpobj, 2, mp_lv_draw_triangle, lv_draw_triangle);
    

/*
 * lvgl extension definition for:
 * void lv_draw_mask_rect(lv_layer_t *layer, const lv_draw_mask_rect_dsc_t *dsc)
 */

STATIC mp_obj_t mp_lv_draw_mask_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_layer_t *layer = mp_write_ptr_lv_layer_t(mp_args[0]);
    const lv_draw_mask_rect_dsc_t *dsc = (const lv_draw_mask_rect_dsc_t *)mp_write_ptr_lv_draw_mask_rect_dsc_t(mp_args[1]);
    ((void (*)(lv_layer_t *, const lv_draw_mask_rect_dsc_t *))lv_func_ptr)(layer, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_rect_mpobj, 2, mp_lv_draw_mask_rect, lv_draw_mask_rect);
    

/*
 * lvgl extension definition for:
 * lv_display_t *lv_display_create(int32_t hor_res, int32_t ver_res)
 */

STATIC mp_obj_t mp_lv_display_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t hor_res = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t ver_res = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_display_t * _res = ((lv_display_t *(*)(int32_t, int32_t))lv_func_ptr)(hor_res, ver_res);
    return mp_read_ptr_lv_display_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_display_create_mpobj, 2, mp_lv_display_create, lv_display_create);
    

/*
 * lvgl extension definition for:
 * lv_display_t *lv_display_get_default(void)
 */

STATIC mp_obj_t mp_lv_display_get_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_display_t * _res = ((lv_display_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_display_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_display_get_default_mpobj, 0, mp_lv_display_get_default, lv_display_get_default);
    

/*
 * lvgl extension definition for:
 * void lv_screen_load(struct _lv_obj_t *scr)
 */

STATIC mp_obj_t mp_lv_screen_load(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *scr = mp_to_lv(mp_args[0]);
    ((void (*)(struct _lv_obj_t *))lv_func_ptr)(scr);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_screen_load_mpobj, 1, mp_lv_screen_load, lv_screen_load);
    

/*
 * lvgl extension definition for:
 * void lv_screen_load_anim(lv_obj_t *scr, lv_screen_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)
 */

STATIC mp_obj_t mp_lv_screen_load_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *scr = mp_to_lv(mp_args[0]);
    lv_screen_load_anim_t anim_type = (int)mp_obj_get_int(mp_args[1]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool auto_del = mp_obj_is_true(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_screen_load_anim_t, uint32_t, uint32_t, bool))lv_func_ptr)(scr, anim_type, time, delay, auto_del);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_screen_load_anim_mpobj, 5, mp_lv_screen_load_anim, lv_screen_load_anim);
    

/*
 * lvgl extension definition for:
 * int32_t lv_clamp_width(int32_t width, int32_t min_width, int32_t max_width, int32_t ref_width)
 */

STATIC mp_obj_t mp_lv_clamp_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t width = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t min_width = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t max_width = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t ref_width = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t _res = ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))lv_func_ptr)(width, min_width, max_width, ref_width);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_clamp_width_mpobj, 4, mp_lv_clamp_width, lv_clamp_width);
    
/* Reusing lv_clamp_width for lv_clamp_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_clamp_height_mpobj, 4, mp_lv_clamp_width, lv_clamp_height);
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_group_create(void)
 */

STATIC mp_obj_t mp_lv_group_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_group_t * _res = ((lv_group_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_create_mpobj, 0, mp_lv_group_create, lv_group_create);
    
/* Reusing lv_group_create for lv_group_get_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_get_default_mpobj, 0, mp_lv_group_create, lv_group_get_default);
    
/* Reusing lv_obj_set_parent for lv_group_swap_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_swap_obj_mpobj, 2, mp_lv_obj_set_parent, lv_group_swap_obj);
    
/* Reusing lv_obj_center for lv_group_remove_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_obj_mpobj, 1, mp_lv_obj_center, lv_group_remove_obj);
    
/* Reusing lv_obj_center for lv_group_focus_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_obj_mpobj, 1, mp_lv_obj_center, lv_group_focus_obj);
    
/* Reusing funcptr_lv_tick_get_cb_t for lv_group_get_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_get_count_mpobj, 0, mp_funcptr_lv_tick_get_cb_t, lv_group_get_count);
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_group_by_index(uint32_t index)
 */

STATIC mp_obj_t mp_lv_group_by_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_group_t * _res = ((lv_group_t *(*)(uint32_t))lv_func_ptr)(index);
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_by_index_mpobj, 1, mp_lv_group_by_index, lv_group_by_index);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_create(void)
 */

STATIC mp_obj_t mp_lv_indev_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_indev_t * _res = ((lv_indev_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_create_mpobj, 0, mp_lv_indev_create, lv_indev_create);
    
/* Reusing funcptr_lv_timer_cb_t for lv_indev_read_timer_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_read_timer_cb_mpobj, 1, mp_funcptr_lv_timer_cb_t, lv_indev_read_timer_cb);
    
/* Reusing lv_indev_create for lv_indev_active */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_active_mpobj, 0, mp_lv_indev_create, lv_indev_active);
    
/* Reusing lv_screen_active for lv_indev_get_active_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_active_obj_mpobj, 0, mp_lv_screen_active, lv_indev_get_active_obj);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_indev_search_obj(lv_obj_t *obj, lv_point_t *point)
 */

STATIC mp_obj_t mp_lv_indev_search_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, point);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_search_obj_mpobj, 2, mp_lv_indev_search_obj, lv_indev_search_obj);
    
/* Reusing lv_display_delete for lv_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_refr_now_mpobj, 1, mp_lv_display_delete, lv_refr_now);
    

/*
 * lvgl extension definition for:
 * lv_font_t *lv_binfont_create(const char *font_name)
 */

STATIC mp_obj_t mp_lv_binfont_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *font_name = (const char *)(char*)convert_from_str(mp_args[0]);
    lv_font_t * _res = ((lv_font_t *(*)(const char *))lv_func_ptr)(font_name);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_binfont_create_mpobj, 1, mp_lv_binfont_create, lv_binfont_create);
    

/*
 * lvgl extension definition for:
 * lv_font_t *lv_binfont_create_from_buffer(void *buffer, uint32_t size)
 */

STATIC mp_obj_t mp_lv_binfont_create_from_buffer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *buffer = mp_to_ptr(mp_args[0]);
    uint32_t size = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_font_t * _res = ((lv_font_t *(*)(void *, uint32_t))lv_func_ptr)(buffer, size);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_binfont_create_from_buffer_mpobj, 2, mp_lv_binfont_create_from_buffer, lv_binfont_create_from_buffer);
    

/*
 * lvgl extension definition for:
 * void lv_binfont_destroy(lv_font_t *font)
 */

STATIC mp_obj_t mp_lv_binfont_destroy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    ((void (*)(lv_font_t *))lv_func_ptr)(font);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_binfont_destroy_mpobj, 1, mp_lv_binfont_destroy, lv_binfont_destroy);
    
/* Reusing lv_init for lv_span_stack_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_span_stack_init_mpobj, 0, mp_lv_init, lv_span_stack_init);
    
/* Reusing lv_init for lv_span_stack_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_span_stack_deinit_mpobj, 0, mp_lv_init, lv_span_stack_deinit);
    

/*
 * lvgl extension definition for:
 * lv_image_dsc_t *lv_snapshot_take(lv_obj_t *obj, lv_color_format_t cf)
 */

STATIC mp_obj_t mp_lv_snapshot_take(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_image_dsc_t * _res = ((lv_image_dsc_t *(*)(lv_obj_t *, lv_color_format_t))lv_func_ptr)(obj, cf);
    return mp_read_ptr_lv_image_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_take_mpobj, 2, mp_lv_snapshot_take, lv_snapshot_take);
    
/* Reusing lv_image_buf_free for lv_snapshot_free */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_snapshot_free_mpobj, 1, mp_lv_image_buf_free, lv_snapshot_free);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_snapshot_buf_size_needed(lv_obj_t *obj, lv_color_format_t cf)
 */

STATIC mp_obj_t mp_lv_snapshot_buf_size_needed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *, lv_color_format_t))lv_func_ptr)(obj, cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_buf_size_needed_mpobj, 2, mp_lv_snapshot_buf_size_needed, lv_snapshot_buf_size_needed);
    

/*
 * lvgl extension definition for:
 * lv_result_t lv_snapshot_take_to_buf(lv_obj_t *obj, lv_color_format_t cf, lv_image_dsc_t *dsc, void *buf, uint32_t buf_size)
 */

STATIC mp_obj_t mp_lv_snapshot_take_to_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_format_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_image_dsc_t *dsc = mp_write_ptr_lv_image_dsc_t(mp_args[2]);
    void *buf = mp_to_ptr(mp_args[3]);
    uint32_t buf_size = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_result_t _res = ((lv_result_t (*)(lv_obj_t *, lv_color_format_t, lv_image_dsc_t *, void *, uint32_t))lv_func_ptr)(obj, cf, dsc, buf, buf_size);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_take_to_buf_mpobj, 5, mp_lv_snapshot_take_to_buf, lv_snapshot_take_to_buf);
    

/*
 * Callback function lv_imgfont_create_path_cb
 * const void *lv_imgfont_get_path_cb_t(const lv_font_t *font, uint32_t unicode, uint32_t unicode_next, int32_t *offset_y, void *user_data)
 */

GENMPY_UNUSED STATIC const void * lv_imgfont_create_path_cb_callback(const lv_font_t *arg0, uint32_t arg1, uint32_t arg2, int32_t *arg3, void *arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_array_from_i32ptr((void*)arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg4);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_imgfont_create_path_cb)) , 5, 0, mp_args);
    _nesting--;
    return mp_to_ptr(callback_result);
}


/*
 * lvgl extension definition for:
 * lv_font_t *lv_imgfont_create(uint16_t height, lv_imgfont_get_path_cb_t path_cb, void *user_data)
 */

STATIC mp_obj_t mp_lv_imgfont_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *path_cb = mp_lv_callback(mp_args[1], &lv_imgfont_create_path_cb_callback, MP_QSTR_lv_imgfont_create_path_cb, &user_data, NULL, (mp_lv_get_user_data)NULL, (mp_lv_set_user_data)NULL);
    uint16_t height = (uint16_t)mp_obj_get_int(mp_args[0]);
    lv_font_t * _res = ((lv_font_t *(*)(uint16_t, lv_imgfont_get_path_cb_t, void *))lv_func_ptr)(height, path_cb, user_data);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_imgfont_create_mpobj, 3, mp_lv_imgfont_create, lv_imgfont_create);
    
/* Reusing lv_binfont_destroy for lv_imgfont_destroy */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_imgfont_destroy_mpobj, 1, mp_lv_binfont_destroy, lv_imgfont_destroy);
    
/* Reusing lv_init for lv_bin_decoder_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bin_decoder_init_mpobj, 0, mp_lv_init, lv_bin_decoder_init);
    
/* Reusing funcptr_lv_image_decoder_info_f_t for lv_bin_decoder_info */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bin_decoder_info_mpobj, 3, mp_funcptr_lv_image_decoder_info_f_t, lv_bin_decoder_info);
    
/* Reusing funcptr_lv_image_decoder_get_area_cb_t for lv_bin_decoder_get_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bin_decoder_get_area_mpobj, 4, mp_funcptr_lv_image_decoder_get_area_cb_t, lv_bin_decoder_get_area);
    
/* Reusing funcptr_lv_image_decoder_open_f_t for lv_bin_decoder_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bin_decoder_open_mpobj, 2, mp_funcptr_lv_image_decoder_open_f_t, lv_bin_decoder_open);
    
/* Reusing funcptr_lv_image_decoder_close_f_t for lv_bin_decoder_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bin_decoder_close_mpobj, 2, mp_funcptr_lv_image_decoder_close_f_t, lv_bin_decoder_close);
    
/* Reusing lv_init for lv_fs_memfs_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_memfs_init_mpobj, 0, mp_lv_init, lv_fs_memfs_init);
    
/* Reusing lv_init for lv_lodepng_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_lodepng_init_mpobj, 0, mp_lv_init, lv_lodepng_init);
    
/* Reusing lv_init for lv_lodepng_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_lodepng_deinit_mpobj, 0, mp_lv_init, lv_lodepng_deinit);
    

/*
 * lvgl extension definition for:
 * gd_GIF *gd_open_gif_file(const char *fname)
 */

STATIC mp_obj_t mp_gd_open_gif_file(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fname = (const char *)(char*)convert_from_str(mp_args[0]);
    gd_GIF * _res = ((gd_GIF *(*)(const char *))lv_func_ptr)(fname);
    return mp_read_ptr_gd_GIF((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gd_open_gif_file_mpobj, 1, mp_gd_open_gif_file, gd_open_gif_file);
    

/*
 * lvgl extension definition for:
 * gd_GIF *gd_open_gif_data(const void *data)
 */

STATIC mp_obj_t mp_gd_open_gif_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *data = (const void *)mp_to_ptr(mp_args[0]);
    gd_GIF * _res = ((gd_GIF *(*)(const void *))lv_func_ptr)(data);
    return mp_read_ptr_gd_GIF((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gd_open_gif_data_mpobj, 1, mp_gd_open_gif_data, gd_open_gif_data);
    
/* Reusing lv_init for lv_tjpgd_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tjpgd_init_mpobj, 0, mp_lv_init, lv_tjpgd_init);
    
/* Reusing lv_init for lv_tjpgd_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tjpgd_deinit_mpobj, 0, mp_lv_init, lv_tjpgd_deinit);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_get_from_obj(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_theme_get_from_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_from_obj_mpobj, 1, mp_lv_theme_get_from_obj, lv_theme_get_from_obj);
    
/* Reusing lv_obj_center for lv_theme_apply */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_apply_mpobj, 1, mp_lv_obj_center, lv_theme_apply);
    

/*
 * lvgl extension definition for:
 * const lv_font_t *lv_theme_get_font_small(lv_obj_t *obj)
 */

STATIC mp_obj_t mp_lv_theme_get_font_small(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_font_t * _res = ((const lv_font_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_small_mpobj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_small);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_normal */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_normal_mpobj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_normal);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_large */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_large_mpobj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_large);
    
/* Reusing lv_barcode_get_dark_color for lv_theme_get_color_primary */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_color_primary_mpobj, 1, mp_lv_barcode_get_dark_color, lv_theme_get_color_primary);
    
/* Reusing lv_barcode_get_dark_color for lv_theme_get_color_secondary */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_color_secondary_mpobj, 1, mp_lv_barcode_get_dark_color, lv_theme_get_color_secondary);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_default_init(lv_display_t *disp, lv_color_t color_primary, lv_color_t color_secondary, bool dark, const lv_font_t *font)
 */

STATIC mp_obj_t mp_lv_theme_default_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_display_t *disp = mp_write_ptr_lv_display_t(mp_args[0]);
    lv_color_t color_primary = mp_write_lv_color_t(mp_args[1]);
    lv_color_t color_secondary = mp_write_lv_color_t(mp_args[2]);
    bool dark = mp_obj_is_true(mp_args[3]);
    const lv_font_t *font = (const lv_font_t *)mp_write_ptr_lv_font_t(mp_args[4]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_display_t *, lv_color_t, lv_color_t, bool, const lv_font_t *))lv_func_ptr)(disp, color_primary, color_secondary, dark, font);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_default_init_mpobj, 5, mp_lv_theme_default_init, lv_theme_default_init);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_default_get(void)
 */

STATIC mp_obj_t mp_lv_theme_default_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_theme_t * _res = ((lv_theme_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_default_get_mpobj, 0, mp_lv_theme_default_get, lv_theme_default_get);
    
/* Reusing lv_is_initialized for lv_theme_default_is_inited */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_default_is_inited_mpobj, 0, mp_lv_is_initialized, lv_theme_default_is_inited);
    
/* Reusing lv_init for lv_theme_default_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_default_deinit_mpobj, 0, mp_lv_init, lv_theme_default_deinit);
    
/* Reusing lv_init for lv_draw_sw_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_init_mpobj, 0, mp_lv_init, lv_draw_sw_init);
    
/* Reusing lv_init for lv_draw_sw_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_deinit_mpobj, 0, mp_lv_init, lv_draw_sw_deinit);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_rgb565_swap(void *buf, uint32_t buf_size_px)
 */

STATIC mp_obj_t mp_lv_draw_sw_rgb565_swap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *buf = mp_to_ptr(mp_args[0]);
    uint32_t buf_size_px = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, uint32_t))lv_func_ptr)(buf, buf_size_px);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_rgb565_swap_mpobj, 2, mp_lv_draw_sw_rgb565_swap, lv_draw_sw_rgb565_swap);
    

/*
 * lvgl extension definition for:
 * void lv_draw_sw_rotate(const void *src, void *dest, int32_t src_width, int32_t src_height, int32_t src_sride, int32_t dest_stride, lv_display_rotation_t rotation, lv_color_format_t color_format)
 */

STATIC mp_obj_t mp_lv_draw_sw_rotate(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = (const void *)mp_to_ptr(mp_args[0]);
    void *dest = mp_to_ptr(mp_args[1]);
    int32_t src_width = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t src_height = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t src_sride = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t dest_stride = (int32_t)mp_obj_get_int(mp_args[5]);
    lv_display_rotation_t rotation = (int)mp_obj_get_int(mp_args[6]);
    lv_color_format_t color_format = (uint8_t)mp_obj_get_int(mp_args[7]);
    ((void (*)(const void *, void *, int32_t, int32_t, int32_t, int32_t, lv_display_rotation_t, lv_color_format_t))lv_func_ptr)(src, dest, src_width, src_height, src_sride, dest_stride, rotation, color_format);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_rotate_mpobj, 8, mp_lv_draw_sw_rotate, lv_draw_sw_rotate);
    
/* Reusing lv_init for lv_draw_sw_mask_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_mask_init_mpobj, 0, mp_lv_init, lv_draw_sw_mask_init);
    
/* Reusing lv_init for lv_draw_sw_mask_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_mask_deinit_mpobj, 0, mp_lv_init, lv_draw_sw_mask_deinit);
    

/*
 * lvgl extension definition for:
 * lv_draw_sw_mask_res_t lv_draw_sw_mask_apply(void *masks[], lv_opa_t *mask_buf, int32_t abs_x, int32_t abs_y, int32_t len)
 */

STATIC mp_obj_t mp_lv_draw_sw_mask_apply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void **masks = mp_arr_to_void_ptr____(mp_args[0]);
    lv_opa_t *mask_buf = mp_array_to_u8ptr(mp_args[1]);
    int32_t abs_x = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t abs_y = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t len = (int32_t)mp_obj_get_int(mp_args[4]);
    lv_draw_sw_mask_res_t _res = ((lv_draw_sw_mask_res_t (*)(void *[], lv_opa_t *, int32_t, int32_t, int32_t))lv_func_ptr)(masks, mask_buf, abs_x, abs_y, len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_mask_apply_mpobj, 5, mp_lv_draw_sw_mask_apply, lv_draw_sw_mask_apply);
    
/* Reusing funcptr_lv_timer_handler_resume_cb_t for lv_draw_sw_mask_free_param */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_sw_mask_free_param_mpobj, 1, mp_funcptr_lv_timer_handler_resume_cb_t, lv_draw_sw_mask_free_param);
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_layout_dsc_t_cb_callback'
 * lv_layout_update_cb_t cb
 */
    

/*
 * Struct lv_layout_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_layout_dsc_t_type();

STATIC inline void* mp_write_ptr_lv_layout_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_layout_dsc_t_type()));
    return (lv_layout_dsc_t*)self->data;
}

#define mp_write_lv_layout_dsc_t(struct_obj) *((lv_layout_dsc_t*)mp_write_ptr_lv_layout_dsc_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_layout_dsc_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_layout_dsc_t_type(), field);
}

#define mp_read_lv_layout_dsc_t(field) mp_read_ptr_lv_layout_dsc_t(copy_buffer(&field, sizeof(lv_layout_dsc_t)))
#define mp_read_byref_lv_layout_dsc_t(field) mp_read_ptr_lv_layout_dsc_t(&field)

STATIC void mp_lv_layout_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_layout_dsc_t *data = (lv_layout_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_layout_update_cb_t_mpobj, data->cb, NULL ,MP_QSTR_lv_layout_dsc_t_cb, NULL); break; // converting from callback lv_layout_update_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_layout_dsc_t_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_layout_update_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_layout_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_layout_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_layout_dsc_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_layout_dsc_t_type,
    MP_QSTR_lv_layout_dsc_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_layout_dsc_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_layout_dsc_t_attr,
    locals_dict, &mp_lv_layout_dsc_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_layout_dsc_t_type()
{
    return &mp_lv_layout_dsc_t_type;
}
    

/*
 * Struct lv_area_transform_cache_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_area_transform_cache_t_type();

STATIC inline void* mp_write_ptr_lv_area_transform_cache_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_area_transform_cache_t_type()));
    return (lv_area_transform_cache_t*)self->data;
}

#define mp_write_lv_area_transform_cache_t(struct_obj) *((lv_area_transform_cache_t*)mp_write_ptr_lv_area_transform_cache_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_area_transform_cache_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_area_transform_cache_t_type(), field);
}

#define mp_read_lv_area_transform_cache_t(field) mp_read_ptr_lv_area_transform_cache_t(copy_buffer(&field, sizeof(lv_area_transform_cache_t)))
#define mp_read_byref_lv_area_transform_cache_t(field) mp_read_ptr_lv_area_transform_cache_t(&field)

STATIC void mp_lv_area_transform_cache_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_area_transform_cache_t *data = (lv_area_transform_cache_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_angle_prev: dest[0] = mp_obj_new_int(data->angle_prev); break; // converting from int32_t;
            case MP_QSTR_sinma: dest[0] = mp_obj_new_int(data->sinma); break; // converting from int32_t;
            case MP_QSTR_cosma: dest[0] = mp_obj_new_int(data->cosma); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_angle_prev: data->angle_prev = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_sinma: data->sinma = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_cosma: data->cosma = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_area_transform_cache_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_area_transform_cache_t");
}

STATIC const mp_obj_dict_t mp_lv_area_transform_cache_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_area_transform_cache_t_type,
    MP_QSTR_lv_area_transform_cache_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_area_transform_cache_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_area_transform_cache_t_attr,
    locals_dict, &mp_lv_area_transform_cache_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_area_transform_cache_t_type()
{
    return &mp_lv_area_transform_cache_t_type;
}
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_timer_state_t_resume_cb_callback'
 * lv_timer_handler_resume_cb_t resume_cb
 */
    

/*
 * Struct lv_timer_state_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_timer_state_t_type();

STATIC inline void* mp_write_ptr_lv_timer_state_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_timer_state_t_type()));
    return (lv_timer_state_t*)self->data;
}

#define mp_write_lv_timer_state_t(struct_obj) *((lv_timer_state_t*)mp_write_ptr_lv_timer_state_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_timer_state_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_timer_state_t_type(), field);
}

#define mp_read_lv_timer_state_t(field) mp_read_ptr_lv_timer_state_t(copy_buffer(&field, sizeof(lv_timer_state_t)))
#define mp_read_byref_lv_timer_state_t(field) mp_read_ptr_lv_timer_state_t(&field)

STATIC void mp_lv_timer_state_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_timer_state_t *data = (lv_timer_state_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_timer_ll: dest[0] = mp_read_byref_lv_ll_t(data->timer_ll); break; // converting from lv_ll_t;
            case MP_QSTR_lv_timer_run: dest[0] = convert_to_bool(data->lv_timer_run); break; // converting from bool;
            case MP_QSTR_idle_last: dest[0] = mp_obj_new_int_from_uint(data->idle_last); break; // converting from uint8_t;
            case MP_QSTR_timer_deleted: dest[0] = convert_to_bool(data->timer_deleted); break; // converting from bool;
            case MP_QSTR_timer_created: dest[0] = convert_to_bool(data->timer_created); break; // converting from bool;
            case MP_QSTR_timer_time_until_next: dest[0] = mp_obj_new_int_from_uint(data->timer_time_until_next); break; // converting from uint32_t;
            case MP_QSTR_already_running: dest[0] = convert_to_bool(data->already_running); break; // converting from bool;
            case MP_QSTR_periodic_last_tick: dest[0] = mp_obj_new_int_from_uint(data->periodic_last_tick); break; // converting from uint32_t;
            case MP_QSTR_busy_time: dest[0] = mp_obj_new_int_from_uint(data->busy_time); break; // converting from uint32_t;
            case MP_QSTR_idle_period_start: dest[0] = mp_obj_new_int_from_uint(data->idle_period_start); break; // converting from uint32_t;
            case MP_QSTR_run_cnt: dest[0] = mp_obj_new_int_from_uint(data->run_cnt); break; // converting from uint32_t;
            case MP_QSTR_resume_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_timer_handler_resume_cb_t_mpobj, data->resume_cb, NULL ,MP_QSTR_lv_timer_state_t_resume_cb, NULL); break; // converting from callback lv_timer_handler_resume_cb_t;
            case MP_QSTR_resume_data: dest[0] = ptr_to_mp((void*)data->resume_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_timer_ll: data->timer_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_lv_timer_run: data->lv_timer_run = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_idle_last: data->idle_last = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_timer_deleted: data->timer_deleted = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_timer_created: data->timer_created = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_timer_time_until_next: data->timer_time_until_next = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_already_running: data->already_running = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_periodic_last_tick: data->periodic_last_tick = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_busy_time: data->busy_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_idle_period_start: data->idle_period_start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_run_cnt: data->run_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_resume_cb: data->resume_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_timer_state_t_resume_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_timer_handler_resume_cb_t;
                case MP_QSTR_resume_data: data->resume_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_timer_state_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_timer_state_t");
}

STATIC const mp_obj_dict_t mp_lv_timer_state_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_timer_state_t_type,
    MP_QSTR_lv_timer_state_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_timer_state_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_timer_state_t_attr,
    locals_dict, &mp_lv_timer_state_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_timer_state_t_type()
{
    return &mp_lv_timer_state_t_type;
}
    

/*
 * Struct lv_anim_state_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_state_t_type();

STATIC inline void* mp_write_ptr_lv_anim_state_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_state_t_type()));
    return (lv_anim_state_t*)self->data;
}

#define mp_write_lv_anim_state_t(struct_obj) *((lv_anim_state_t*)mp_write_ptr_lv_anim_state_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_anim_state_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_state_t_type(), field);
}

#define mp_read_lv_anim_state_t(field) mp_read_ptr_lv_anim_state_t(copy_buffer(&field, sizeof(lv_anim_state_t)))
#define mp_read_byref_lv_anim_state_t(field) mp_read_ptr_lv_anim_state_t(&field)

STATIC void mp_lv_anim_state_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_anim_state_t *data = (lv_anim_state_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_anim_list_changed: dest[0] = convert_to_bool(data->anim_list_changed); break; // converting from bool;
            case MP_QSTR_anim_run_round: dest[0] = convert_to_bool(data->anim_run_round); break; // converting from bool;
            case MP_QSTR_timer: dest[0] = mp_read_ptr_lv_timer_t((void*)data->timer); break; // converting from lv_timer_t *;
            case MP_QSTR_anim_ll: dest[0] = mp_read_byref_lv_ll_t(data->anim_ll); break; // converting from lv_ll_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_anim_list_changed: data->anim_list_changed = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_anim_run_round: data->anim_run_round = mp_obj_is_true(dest[1]); break; // converting to bool;
                case MP_QSTR_timer: data->timer = (void*)mp_write_ptr_lv_timer_t(dest[1]); break; // converting to lv_timer_t *;
                case MP_QSTR_anim_ll: data->anim_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_state_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_state_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_state_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_anim_state_t_type,
    MP_QSTR_lv_anim_state_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_anim_state_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_anim_state_t_attr,
    locals_dict, &mp_lv_anim_state_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_anim_state_t_type()
{
    return &mp_lv_anim_state_t_type;
}
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_tick_state_t_tick_get_cb_callback'
 * lv_tick_get_cb_t tick_get_cb
 */
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_tick_state_t_delay_cb_callback'
 * lv_delay_cb_t delay_cb
 */
    

/*
 * Struct lv_tick_state_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_tick_state_t_type();

STATIC inline void* mp_write_ptr_lv_tick_state_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_tick_state_t_type()));
    return (lv_tick_state_t*)self->data;
}

#define mp_write_lv_tick_state_t(struct_obj) *((lv_tick_state_t*)mp_write_ptr_lv_tick_state_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_tick_state_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_tick_state_t_type(), field);
}

#define mp_read_lv_tick_state_t(field) mp_read_ptr_lv_tick_state_t(copy_buffer(&field, sizeof(lv_tick_state_t)))
#define mp_read_byref_lv_tick_state_t(field) mp_read_ptr_lv_tick_state_t(&field)

STATIC void mp_lv_tick_state_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_tick_state_t *data = (lv_tick_state_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_sys_time: dest[0] = mp_obj_new_int_from_uint(data->sys_time); break; // converting from uint32_t;
            case MP_QSTR_sys_irq_flag: dest[0] = mp_obj_new_int_from_uint(data->sys_irq_flag); break; // converting from uint8_t;
            case MP_QSTR_tick_get_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_tick_get_cb_t_mpobj, data->tick_get_cb, NULL ,MP_QSTR_lv_tick_state_t_tick_get_cb, NULL); break; // converting from callback lv_tick_get_cb_t;
            case MP_QSTR_delay_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_delay_cb_t_mpobj, data->delay_cb, NULL ,MP_QSTR_lv_tick_state_t_delay_cb, NULL); break; // converting from callback lv_delay_cb_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_sys_time: data->sys_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_sys_irq_flag: data->sys_irq_flag = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_tick_get_cb: data->tick_get_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_tick_state_t_tick_get_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_tick_get_cb_t;
                case MP_QSTR_delay_cb: data->delay_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_tick_state_t_delay_cb, NULL, NULL, NULL, NULL); break; // converting to callback lv_delay_cb_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_tick_state_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_tick_state_t");
}

STATIC const mp_obj_dict_t mp_lv_tick_state_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_tick_state_t_type,
    MP_QSTR_lv_tick_state_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_tick_state_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_tick_state_t_attr,
    locals_dict, &mp_lv_tick_state_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_tick_state_t_type()
{
    return &mp_lv_tick_state_t_type;
}
    

/*
 * Struct lv_draw_global_info_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_global_info_t_type();

STATIC inline void* mp_write_ptr_lv_draw_global_info_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_global_info_t_type()));
    return (lv_draw_global_info_t*)self->data;
}

#define mp_write_lv_draw_global_info_t(struct_obj) *((lv_draw_global_info_t*)mp_write_ptr_lv_draw_global_info_t(struct_obj))

STATIC inline mp_obj_t mp_read_ptr_lv_draw_global_info_t(void *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_global_info_t_type(), field);
}

#define mp_read_lv_draw_global_info_t(field) mp_read_ptr_lv_draw_global_info_t(copy_buffer(&field, sizeof(lv_draw_global_info_t)))
#define mp_read_byref_lv_draw_global_info_t(field) mp_read_ptr_lv_draw_global_info_t(&field)

STATIC void mp_lv_draw_global_info_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    GENMPY_UNUSED lv_draw_global_info_t *data = (lv_draw_global_info_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_unit_head: dest[0] = mp_read_ptr_lv_draw_unit_t((void*)data->unit_head); break; // converting from lv_draw_unit_t *;
            case MP_QSTR_used_memory_for_layers_kb: dest[0] = mp_obj_new_int_from_uint(data->used_memory_for_layers_kb); break; // converting from uint32_t;
            case MP_QSTR_dispatch_req: dest[0] = mp_obj_new_int(data->dispatch_req); break; // converting from int;
            case MP_QSTR_circle_cache_mutex: dest[0] = mp_obj_new_int(data->circle_cache_mutex); break; // converting from lv_mutex_t;
            case MP_QSTR_task_running: dest[0] = convert_to_bool(data->task_running); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_unit_head: data->unit_head = (void*)mp_write_ptr_lv_draw_unit_t(dest[1]); break; // converting to lv_draw_unit_t *;
                case MP_QSTR_used_memory_for_layers_kb: data->used_memory_for_layers_kb = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_dispatch_req: data->dispatch_req = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_circle_cache_mutex: data->circle_cache_mutex = (int)mp_obj_get_int(dest[1]); break; // converting to lv_mutex_t;
                case MP_QSTR_task_running: data->task_running = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_global_info_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_global_info_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_global_info_t_locals_dict;

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mp_lv_draw_global_info_t_type,
    MP_QSTR_lv_draw_global_info_t,
    MP_TYPE_FLAG_NONE,
    print, mp_lv_draw_global_info_t_print,
    make_new, make_new_lv_struct,
    binary_op, lv_struct_binary_op,
    subscr, lv_struct_subscr,
    attr, mp_lv_draw_global_info_t_attr,
    locals_dict, &mp_lv_draw_global_info_t_locals_dict,
    buffer, mp_blob_get_buffer,
    parent, &mp_lv_base_struct_type
);

STATIC inline const mp_obj_type_t *get_mp_lv_draw_global_info_t_type()
{
    return &mp_lv_draw_global_info_t_type;
}
    

/*
 * Function NOT generated:
 * Missing conversion to _lv_draw_sw_mask_radius_circle_dsc_arr_t when generating struct lv_global_t.sw_circle_cache
 * lv_global_t *lv_global_default(void)
 */
    

/*
 * Callback function lv_font_t_get_glyph_dsc
 * bool get_glyph_dsc(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */

GENMPY_UNUSED STATIC bool lv_font_t_get_glyph_dsc_callback(const lv_font_t *arg0, lv_font_glyph_dsc_t *arg1, uint32_t arg2, uint32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_font_glyph_dsc_t((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_get_glyph_dsc)) , 4, 0, mp_args);
    _nesting--;
    return mp_obj_is_true(callback_result);
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! const void *get_glyph_bitmap(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *)
 * const void *get_glyph_bitmap(lv_font_glyph_dsc_t *, uint32_t, lv_draw_buf_t *)
 */
    

/*
 * Callback function lv_font_t_release_glyph
 * void release_glyph(const lv_font_t *, lv_font_glyph_dsc_t *)
 */

GENMPY_UNUSED STATIC void lv_font_t_release_glyph_callback(const lv_font_t *arg0, lv_font_glyph_dsc_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_font_glyph_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_release_glyph)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_color_filter_dsc_t_filter_cb
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */

GENMPY_UNUSED STATIC lv_color_t lv_color_filter_dsc_t_filter_cb_callback(const struct _lv_color_filter_dsc_t *arg0, lv_color_t arg1, lv_opa_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_color_filter_dsc_t((void*)arg0);
    mp_args[1] = mp_read_lv_color_t(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_color_filter_dsc_t_filter_cb)) , 3, 0, mp_args);
    _nesting--;
    return mp_write_lv_color_t(callback_result);
}


/*
 * Callback function lv_anim_t_custom_exec_cb
 * void lv_anim_custom_exec_cb_t(lv_anim_t *, int32_t)
 */

GENMPY_UNUSED STATIC void lv_anim_t_custom_exec_cb_callback(lv_anim_t *arg0, int32_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_args[1] = mp_obj_new_int(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_custom_exec_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_style_transition_dsc_t_path_xcb
 * int32_t lv_anim_path_cb_t(const lv_anim_t *)
 */

GENMPY_UNUSED STATIC int32_t lv_style_transition_dsc_t_path_xcb_callback(const lv_anim_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_style_transition_dsc_t_path_xcb)) , 1, 0, mp_args);
    _nesting--;
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_obj_class_t_constructor_cb
 * void constructor_cb(const lv_obj_class_t *class_p, lv_obj_t *obj)
 */

GENMPY_UNUSED STATIC void lv_obj_class_t_constructor_cb_callback(const lv_obj_class_t *arg0, lv_obj_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_constructor_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_obj_class_t_destructor_cb
 * void destructor_cb(const lv_obj_class_t *class_p, lv_obj_t *obj)
 */

GENMPY_UNUSED STATIC void lv_obj_class_t_destructor_cb_callback(const lv_obj_class_t *arg0, lv_obj_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_destructor_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_obj_class_t_event_cb
 * void event_cb(const lv_obj_class_t *class_p, lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_obj_class_t_event_cb_callback(const lv_obj_class_t *arg0, lv_event_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_event_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_event_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_event_dsc_t_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

GENMPY_UNUSED STATIC void lv_event_dsc_t_cb_callback(lv_event_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_event_dsc_t_cb)) , 1, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_observer_t_cb
 * void lv_observer_cb_t(lv_observer_t *observer, lv_subject_t *subject)
 */

GENMPY_UNUSED STATIC void lv_observer_t_cb_callback(lv_observer_t *arg0, lv_subject_t *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_observer_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_subject_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_observer_t_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Callback function lv_image_decoder_t_get_area_cb
 * lv_result_t lv_image_decoder_get_area_cb_t(lv_image_decoder_t *decoder, lv_image_decoder_dsc_t *dsc, const lv_area_t *full_area, lv_area_t *decoded_area)
 */

GENMPY_UNUSED STATIC lv_result_t lv_image_decoder_t_get_area_cb_callback(lv_image_decoder_t *arg0, lv_image_decoder_dsc_t *arg1, const lv_area_t *arg2, lv_area_t *arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_image_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_image_decoder_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_args[3] = mp_read_ptr_lv_area_t((void*)arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_image_decoder_t_get_area_cb)) , 4, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_free_cb_t(void *node, void *user_data)
 * void lv_cache_free_cb_t(void *node, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void *lv_cache_alloc_cb_t(void)
 * void *lv_cache_alloc_cb_t(void)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! bool lv_cache_init_cb_t(lv_cache_t *cache)
 * bool lv_cache_init_cb_t(lv_cache_t *cache)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_destroy_cb_t(lv_cache_t *cache, void *user_data)
 * void lv_cache_destroy_cb_t(lv_cache_t *cache, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_cache_entry_t *lv_cache_get_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 * lv_cache_entry_t *lv_cache_get_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_cache_entry_t *lv_cache_add_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 * lv_cache_entry_t *lv_cache_add_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_remove_cb_t(lv_cache_t *cache, lv_cache_entry_t *entry, void *user_data)
 * void lv_cache_remove_cb_t(lv_cache_t *cache, lv_cache_entry_t *entry, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_drop_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 * void lv_cache_drop_cb_t(lv_cache_t *cache, const void *key, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_clear_cb_t(lv_cache_t *cache, void *user_data)
 * void lv_cache_clear_cb_t(lv_cache_t *cache, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_cache_compare_res_t lv_cache_compare_cb_t(const void *a, const void *b)
 * lv_cache_compare_res_t lv_cache_compare_cb_t(const void *a, const void *b)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! bool lv_cache_create_cb_t(void *node, void *user_data)
 * bool lv_cache_create_cb_t(void *node, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_cache_free_cb_t(void *node, void *user_data)
 * void lv_cache_free_cb_t(void *node, void *user_data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_rb_compare_res_t lv_rb_compare_t(const void *a, const void *b)
 * lv_rb_compare_res_t lv_rb_compare_t(const void *a, const void *b)
 */
    

/*
 * Callback function lv_fs_drv_t_ready_cb
 * bool ready_cb(lv_fs_drv_t *drv)
 */

GENMPY_UNUSED STATIC bool lv_fs_drv_t_ready_cb_callback(lv_fs_drv_t *arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_ready_cb)) , 1, 0, mp_args);
    _nesting--;
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_fs_drv_t_open_cb
 * void *open_cb(lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
 */

GENMPY_UNUSED STATIC void * lv_fs_drv_t_open_cb_callback(lv_fs_drv_t *arg0, const char *arg1, lv_fs_mode_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_open_cb)) , 3, 0, mp_args);
    _nesting--;
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_fs_drv_t_close_cb
 * lv_fs_res_t close_cb(lv_fs_drv_t *drv, void *file_p)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(lv_fs_drv_t *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_close_cb)) , 2, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_read_cb
 * lv_fs_res_t read_cb(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(lv_fs_drv_t *arg0, void *arg1, void *arg2, uint32_t arg3, uint32_t *arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = mp_array_from_u32ptr((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_read_cb)) , 5, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_write_cb
 * lv_fs_res_t write_cb(lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(lv_fs_drv_t *arg0, void *arg1, const void *arg2, uint32_t arg3, uint32_t *arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = mp_array_from_u32ptr((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_write_cb)) , 5, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_seek_cb
 * lv_fs_res_t seek_cb(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(lv_fs_drv_t *arg0, void *arg1, uint32_t arg2, lv_fs_whence_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_seek_cb)) , 4, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_tell_cb
 * lv_fs_res_t tell_cb(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(lv_fs_drv_t *arg0, void *arg1, uint32_t *arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_array_from_u32ptr((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_tell_cb)) , 3, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_open_cb
 * void *dir_open_cb(lv_fs_drv_t *drv, const char *path)
 */

GENMPY_UNUSED STATIC void * lv_fs_drv_t_dir_open_cb_callback(lv_fs_drv_t *arg0, const char *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_open_cb)) , 2, 0, mp_args);
    _nesting--;
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_read_cb
 * lv_fs_res_t dir_read_cb(lv_fs_drv_t *drv, void *rddir_p, char *fn, uint32_t fn_len)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(lv_fs_drv_t *arg0, void *arg1, char *arg2, uint32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_read_cb)) , 4, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_close_cb
 * lv_fs_res_t dir_close_cb(lv_fs_drv_t *drv, void *rddir_p)
 */

GENMPY_UNUSED STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(lv_fs_drv_t *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_close_cb)) , 2, 0, mp_args);
    _nesting--;
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! int32_t dispatch_cb(lv_draw_unit_t *draw_unit, lv_layer_t *layer)
 * int32_t dispatch_cb(lv_draw_unit_t *draw_unit, lv_layer_t *layer)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! int32_t evaluate_cb(lv_draw_unit_t *draw_unit, lv_draw_task_t *task)
 * int32_t evaluate_cb(lv_draw_unit_t *draw_unit, lv_draw_task_t *task)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! int32_t delete_cb(lv_draw_unit_t *draw_unit)
 * int32_t delete_cb(lv_draw_unit_t *draw_unit)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void plain_text(struct _gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 * void plain_text(struct _gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void comment(struct _gd_GIF *gif)
 * void comment(struct _gd_GIF *gif)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void application(struct _gd_GIF *gif, char id[8], char auth[3])
 * void application(struct _gd_GIF *gif, char id[8], char auth[3])
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_draw_sw_mask_res_t lv_draw_sw_mask_xcb_t(lv_opa_t *mask_buf, int32_t abs_x, int32_t abs_y, int32_t len, void *p)
 * lv_draw_sw_mask_res_t lv_draw_sw_mask_xcb_t(lv_opa_t *mask_buf, int32_t abs_x, int32_t abs_y, int32_t len, void *p)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void *lv_draw_buf_malloc_cb(size_t size, lv_color_format_t color_format)
 * void *lv_draw_buf_malloc_cb(size_t size, lv_color_format_t color_format)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_draw_buf_free_cb(void *draw_buf)
 * void lv_draw_buf_free_cb(void *draw_buf)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void *lv_draw_buf_align_cb(void *buf, lv_color_format_t color_format)
 * void *lv_draw_buf_align_cb(void *buf, lv_color_format_t color_format)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_draw_buf_invalidate_cache_cb(void *buf, uint32_t stride, lv_color_format_t color_format, const lv_area_t *area)
 * void lv_draw_buf_invalidate_cache_cb(void *buf, uint32_t stride, lv_color_format_t color_format, const lv_area_t *area)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! uint32_t lv_draw_buf_width_to_stride_cb(uint32_t w, lv_color_format_t color_format)
 * uint32_t lv_draw_buf_width_to_stride_cb(uint32_t w, lv_color_format_t color_format)
 */
    

/*
 * Callback function lv_layout_dsc_t_cb
 * void lv_layout_update_cb_t(lv_obj_t *, void *user_data)
 */

GENMPY_UNUSED STATIC void lv_layout_dsc_t_cb_callback(lv_obj_t *arg0, void *arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    _nesting++;
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_layout_dsc_t_cb)) , 2, 0, mp_args);
    _nesting--;
    return;
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_timer_handler_resume_cb_t(void *data)
 * void lv_timer_handler_resume_cb_t(void *data)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! uint32_t lv_tick_get_cb_t(void)
 * uint32_t lv_tick_get_cb_t(void)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void lv_delay_cb_t(uint32_t ms)
 * void lv_delay_cb_t(uint32_t ms)
 */
    


/*
 * lvgl module definitions
 */

STATIC const mp_rom_map_elem_t lvgl_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_lvgl) },
    { MP_ROM_QSTR(MP_QSTR_obj), MP_ROM_PTR(&mp_lv_obj_type_base) },
    { MP_ROM_QSTR(MP_QSTR_image), MP_ROM_PTR(&mp_lv_image_type_base) },
    { MP_ROM_QSTR(MP_QSTR_animimg), MP_ROM_PTR(&mp_lv_animimg_type_base) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_lv_arc_type_base) },
    { MP_ROM_QSTR(MP_QSTR_label), MP_ROM_PTR(&mp_lv_label_type_base) },
    { MP_ROM_QSTR(MP_QSTR_bar), MP_ROM_PTR(&mp_lv_bar_type_base) },
    { MP_ROM_QSTR(MP_QSTR_button), MP_ROM_PTR(&mp_lv_button_type_base) },
    { MP_ROM_QSTR(MP_QSTR_buttonmatrix), MP_ROM_PTR(&mp_lv_buttonmatrix_type_base) },
    { MP_ROM_QSTR(MP_QSTR_calendar), MP_ROM_PTR(&mp_lv_calendar_type_base) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_arrow), MP_ROM_PTR(&mp_lv_calendar_header_arrow_type_base) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_dropdown), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_type_base) },
    { MP_ROM_QSTR(MP_QSTR_canvas), MP_ROM_PTR(&mp_lv_canvas_type_base) },
    { MP_ROM_QSTR(MP_QSTR_chart), MP_ROM_PTR(&mp_lv_chart_type_base) },
    { MP_ROM_QSTR(MP_QSTR_checkbox), MP_ROM_PTR(&mp_lv_checkbox_type_base) },
    { MP_ROM_QSTR(MP_QSTR_dropdown), MP_ROM_PTR(&mp_lv_dropdown_type_base) },
    { MP_ROM_QSTR(MP_QSTR_imagebutton), MP_ROM_PTR(&mp_lv_imagebutton_type_base) },
    { MP_ROM_QSTR(MP_QSTR_keyboard), MP_ROM_PTR(&mp_lv_keyboard_type_base) },
    { MP_ROM_QSTR(MP_QSTR_led), MP_ROM_PTR(&mp_lv_led_type_base) },
    { MP_ROM_QSTR(MP_QSTR_line), MP_ROM_PTR(&mp_lv_line_type_base) },
    { MP_ROM_QSTR(MP_QSTR_list), MP_ROM_PTR(&mp_lv_list_type_base) },
    { MP_ROM_QSTR(MP_QSTR_menu), MP_ROM_PTR(&mp_lv_menu_type_base) },
    { MP_ROM_QSTR(MP_QSTR_menu_page), MP_ROM_PTR(&mp_lv_menu_page_type_base) },
    { MP_ROM_QSTR(MP_QSTR_menu_cont), MP_ROM_PTR(&mp_lv_menu_cont_type_base) },
    { MP_ROM_QSTR(MP_QSTR_menu_section), MP_ROM_PTR(&mp_lv_menu_section_type_base) },
    { MP_ROM_QSTR(MP_QSTR_menu_separator), MP_ROM_PTR(&mp_lv_menu_separator_type_base) },
    { MP_ROM_QSTR(MP_QSTR_msgbox), MP_ROM_PTR(&mp_lv_msgbox_type_base) },
    { MP_ROM_QSTR(MP_QSTR_roller), MP_ROM_PTR(&mp_lv_roller_type_base) },
    { MP_ROM_QSTR(MP_QSTR_scale), MP_ROM_PTR(&mp_lv_scale_type_base) },
    { MP_ROM_QSTR(MP_QSTR_slider), MP_ROM_PTR(&mp_lv_slider_type_base) },
    { MP_ROM_QSTR(MP_QSTR_spangroup), MP_ROM_PTR(&mp_lv_spangroup_type_base) },
    { MP_ROM_QSTR(MP_QSTR_textarea), MP_ROM_PTR(&mp_lv_textarea_type_base) },
    { MP_ROM_QSTR(MP_QSTR_spinbox), MP_ROM_PTR(&mp_lv_spinbox_type_base) },
    { MP_ROM_QSTR(MP_QSTR_spinner), MP_ROM_PTR(&mp_lv_spinner_type_base) },
    { MP_ROM_QSTR(MP_QSTR_switch), MP_ROM_PTR(&mp_lv_switch_type_base) },
    { MP_ROM_QSTR(MP_QSTR_table), MP_ROM_PTR(&mp_lv_table_type_base) },
    { MP_ROM_QSTR(MP_QSTR_tabview), MP_ROM_PTR(&mp_lv_tabview_type_base) },
    { MP_ROM_QSTR(MP_QSTR_tileview), MP_ROM_PTR(&mp_lv_tileview_type_base) },
    { MP_ROM_QSTR(MP_QSTR_win), MP_ROM_PTR(&mp_lv_win_type_base) },
    { MP_ROM_QSTR(MP_QSTR_barcode), MP_ROM_PTR(&mp_lv_barcode_type_base) },
    { MP_ROM_QSTR(MP_QSTR_gif), MP_ROM_PTR(&mp_lv_gif_type_base) },
    { MP_ROM_QSTR(MP_QSTR_qrcode), MP_ROM_PTR(&mp_lv_qrcode_type_base) },
    
    { MP_ROM_QSTR(MP_QSTR_memzero), MP_ROM_PTR(&mp_lv_memzero_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_handler_run_in_period), MP_ROM_PTR(&mp_lv_timer_handler_run_in_period_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_trigo_cos), MP_ROM_PTR(&mp_lv_trigo_cos_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bezier3), MP_ROM_PTR(&mp_lv_bezier3_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pct), MP_ROM_PTR(&mp_lv_pct_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pct_to_px), MP_ROM_PTR(&mp_lv_pct_to_px_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_format_get_size), MP_ROM_PTR(&mp_lv_color_format_get_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex), MP_ROM_PTR(&mp_lv_color_hex_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_make), MP_ROM_PTR(&mp_lv_color_make_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color32_make), MP_ROM_PTR(&mp_lv_color32_make_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex3), MP_ROM_PTR(&mp_lv_color_hex3_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_16_16_mix), MP_ROM_PTR(&mp_lv_color_16_16_mix_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_white), MP_ROM_PTR(&mp_lv_color_white_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_black), MP_ROM_PTR(&mp_lv_color_black_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_font_default), MP_ROM_PTR(&mp_lv_font_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bidi_calculate_align), MP_ROM_PTR(&mp_lv_bidi_calculate_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_grid_fr), MP_ROM_PTR(&mp_lv_grid_fr_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_prop_has_flag), MP_ROM_PTR(&mp_lv_style_prop_has_flag_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_screen_active), MP_ROM_PTR(&mp_lv_screen_active_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_layer_top), MP_ROM_PTR(&mp_lv_layer_top_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_layer_sys), MP_ROM_PTR(&mp_lv_layer_sys_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_layer_bottom), MP_ROM_PTR(&mp_lv_layer_bottom_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_dpx_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_task_handler), MP_ROM_PTR(&mp_lv_task_handler_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_version_major), MP_ROM_PTR(&mp_lv_version_major_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_version_minor), MP_ROM_PTR(&mp_lv_version_minor_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_version_patch), MP_ROM_PTR(&mp_lv_version_patch_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_version_info), MP_ROM_PTR(&mp_lv_version_info_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mp_lv_init_gc), MP_ROM_PTR(&mp_mp_lv_init_gc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&mp_lv_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_is_initialized), MP_ROM_PTR(&mp_lv_is_initialized_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_init), MP_ROM_PTR(&mp_lv_mem_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_deinit), MP_ROM_PTR(&mp_lv_mem_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_add_pool), MP_ROM_PTR(&mp_lv_mem_add_pool_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_remove_pool), MP_ROM_PTR(&mp_lv_mem_remove_pool_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_malloc), MP_ROM_PTR(&mp_lv_malloc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_malloc_zeroed), MP_ROM_PTR(&mp_lv_malloc_zeroed_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_free), MP_ROM_PTR(&mp_lv_free_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_realloc), MP_ROM_PTR(&mp_lv_realloc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_malloc_core), MP_ROM_PTR(&mp_lv_malloc_core_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_free_core), MP_ROM_PTR(&mp_lv_free_core_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_realloc_core), MP_ROM_PTR(&mp_lv_realloc_core_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_test_core), MP_ROM_PTR(&mp_lv_mem_test_core_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mem_test), MP_ROM_PTR(&mp_lv_mem_test_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_memcpy), MP_ROM_PTR(&mp_lv_memcpy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_memset), MP_ROM_PTR(&mp_lv_memset_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_memmove), MP_ROM_PTR(&mp_lv_memmove_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strlen), MP_ROM_PTR(&mp_lv_strlen_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strncpy), MP_ROM_PTR(&mp_lv_strncpy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strcpy), MP_ROM_PTR(&mp_lv_strcpy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strcmp), MP_ROM_PTR(&mp_lv_strcmp_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strdup), MP_ROM_PTR(&mp_lv_strdup_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_strdup), MP_ROM_PTR(&mp_lv_strdup_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tick_inc), MP_ROM_PTR(&mp_lv_tick_inc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tick_get), MP_ROM_PTR(&mp_lv_tick_get_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tick_elaps), MP_ROM_PTR(&mp_lv_tick_elaps_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delay_ms), MP_ROM_PTR(&mp_lv_delay_ms_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tick_set_cb), MP_ROM_PTR(&mp_lv_tick_set_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_delay_set_cb), MP_ROM_PTR(&mp_lv_delay_set_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_handler), MP_ROM_PTR(&mp_lv_timer_handler_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_periodic_handler), MP_ROM_PTR(&mp_lv_timer_periodic_handler_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_handler_set_resume_cb), MP_ROM_PTR(&mp_lv_timer_handler_set_resume_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_create_basic), MP_ROM_PTR(&mp_lv_timer_create_basic_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_create), MP_ROM_PTR(&mp_lv_timer_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_enable), MP_ROM_PTR(&mp_lv_timer_enable_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_get_idle), MP_ROM_PTR(&mp_lv_timer_get_idle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_timer_get_time_until_next), MP_ROM_PTR(&mp_lv_timer_get_time_until_next_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_trigo_sin), MP_ROM_PTR(&mp_lv_trigo_sin_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cubic_bezier), MP_ROM_PTR(&mp_lv_cubic_bezier_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_atan2), MP_ROM_PTR(&mp_lv_atan2_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_lv_sqrt_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_lv_pow_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_map), MP_ROM_PTR(&mp_lv_map_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_rand_set_seed), MP_ROM_PTR(&mp_lv_rand_set_seed_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_rand), MP_ROM_PTR(&mp_lv_rand_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_async_call), MP_ROM_PTR(&mp_lv_async_call_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_async_call_cancel), MP_ROM_PTR(&mp_lv_async_call_cancel_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_delete), MP_ROM_PTR(&mp_lv_anim_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_delete_all), MP_ROM_PTR(&mp_lv_anim_delete_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_get), MP_ROM_PTR(&mp_lv_anim_get_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_get_timer), MP_ROM_PTR(&mp_lv_anim_get_timer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_count_running), MP_ROM_PTR(&mp_lv_anim_count_running_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_speed), MP_ROM_PTR(&mp_lv_anim_speed_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_speed_clamped), MP_ROM_PTR(&mp_lv_anim_speed_clamped_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_refr_now), MP_ROM_PTR(&mp_lv_anim_refr_now_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_create), MP_ROM_PTR(&mp_lv_anim_timeline_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_format_get_bpp), MP_ROM_PTR(&mp_lv_color_format_get_bpp_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_format_has_alpha), MP_ROM_PTR(&mp_lv_color_format_has_alpha_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_to_rgb), MP_ROM_PTR(&mp_lv_color_hsv_to_rgb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_color_rgb_to_hsv), MP_ROM_PTR(&mp_lv_color_rgb_to_hsv_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_palette_main), MP_ROM_PTR(&mp_lv_palette_main_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_palette_lighten), MP_ROM_PTR(&mp_lv_palette_lighten_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_palette_darken), MP_ROM_PTR(&mp_lv_palette_darken_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_get_handlers), MP_ROM_PTR(&mp_lv_draw_buf_get_handlers_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_align), MP_ROM_PTR(&mp_lv_draw_buf_align_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_invalidate_cache), MP_ROM_PTR(&mp_lv_draw_buf_invalidate_cache_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_width_to_stride), MP_ROM_PTR(&mp_lv_draw_buf_width_to_stride_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_create), MP_ROM_PTR(&mp_lv_draw_buf_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_init), MP_ROM_PTR(&mp_lv_thread_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_delete), MP_ROM_PTR(&mp_lv_thread_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mutex_init), MP_ROM_PTR(&mp_lv_mutex_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mutex_lock), MP_ROM_PTR(&mp_lv_mutex_lock_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mutex_lock_isr), MP_ROM_PTR(&mp_lv_mutex_lock_isr_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mutex_unlock), MP_ROM_PTR(&mp_lv_mutex_unlock_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_mutex_delete), MP_ROM_PTR(&mp_lv_mutex_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_sync_init), MP_ROM_PTR(&mp_lv_thread_sync_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_sync_wait), MP_ROM_PTR(&mp_lv_thread_sync_wait_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_sync_signal), MP_ROM_PTR(&mp_lv_thread_sync_signal_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_thread_sync_delete), MP_ROM_PTR(&mp_lv_thread_sync_delete_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cache_entry_get_size), MP_ROM_PTR(&mp_lv_cache_entry_get_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cache_entry_get_entry), MP_ROM_PTR(&mp_lv_cache_entry_get_entry_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_cache_entry_alloc), MP_ROM_PTR(&mp_lv_cache_entry_alloc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_text_get_size), MP_ROM_PTR(&mp_lv_text_get_size_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_text_get_width), MP_ROM_PTR(&mp_lv_text_get_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_layout_register), MP_ROM_PTR(&mp_lv_layout_register_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_flex_init), MP_ROM_PTR(&mp_lv_flex_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_grid_init), MP_ROM_PTR(&mp_lv_grid_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_register_prop), MP_ROM_PTR(&mp_lv_style_register_prop_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_num_custom_props), MP_ROM_PTR(&mp_lv_style_get_num_custom_props_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_style_prop_get_default), MP_ROM_PTR(&mp_lv_style_prop_get_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_send), MP_ROM_PTR(&mp_lv_event_send_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_add), MP_ROM_PTR(&mp_lv_event_add_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_get_count), MP_ROM_PTR(&mp_lv_event_get_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_get_dsc), MP_ROM_PTR(&mp_lv_event_get_dsc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_remove), MP_ROM_PTR(&mp_lv_event_remove_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_remove_all), MP_ROM_PTR(&mp_lv_event_remove_all_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_event_register_id), MP_ROM_PTR(&mp_lv_event_register_id_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_drv), MP_ROM_PTR(&mp_lv_fs_get_drv_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_is_ready), MP_ROM_PTR(&mp_lv_fs_is_ready_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_letters), MP_ROM_PTR(&mp_lv_fs_get_letters_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_ext), MP_ROM_PTR(&mp_lv_fs_get_ext_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_up), MP_ROM_PTR(&mp_lv_fs_up_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_last), MP_ROM_PTR(&mp_lv_fs_get_last_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_init), MP_ROM_PTR(&mp_lv_draw_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_deinit), MP_ROM_PTR(&mp_lv_draw_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_create_unit), MP_ROM_PTR(&mp_lv_draw_create_unit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_add_task), MP_ROM_PTR(&mp_lv_draw_add_task_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_finalize_task_creation), MP_ROM_PTR(&mp_lv_draw_finalize_task_creation_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_dispatch), MP_ROM_PTR(&mp_lv_draw_dispatch_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_dispatch_wait_for_request), MP_ROM_PTR(&mp_lv_draw_dispatch_wait_for_request_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_dispatch_request), MP_ROM_PTR(&mp_lv_draw_dispatch_request_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_get_next_available_task), MP_ROM_PTR(&mp_lv_draw_get_next_available_task_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer_create), MP_ROM_PTR(&mp_lv_draw_layer_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer_alloc_buf), MP_ROM_PTR(&mp_lv_draw_layer_alloc_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer_go_to_xy), MP_ROM_PTR(&mp_lv_draw_layer_go_to_xy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect), MP_ROM_PTR(&mp_lv_draw_rect_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_label), MP_ROM_PTR(&mp_lv_draw_label_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_character), MP_ROM_PTR(&mp_lv_draw_character_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_image), MP_ROM_PTR(&mp_lv_draw_image_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer), MP_ROM_PTR(&mp_lv_draw_layer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc), MP_ROM_PTR(&mp_lv_draw_arc_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc_get_area), MP_ROM_PTR(&mp_lv_draw_arc_get_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_line), MP_ROM_PTR(&mp_lv_draw_line_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_triangle), MP_ROM_PTR(&mp_lv_draw_triangle_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_rect), MP_ROM_PTR(&mp_lv_draw_mask_rect_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_display_create), MP_ROM_PTR(&mp_lv_display_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_display_get_default), MP_ROM_PTR(&mp_lv_display_get_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_screen_load), MP_ROM_PTR(&mp_lv_screen_load_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_screen_load_anim), MP_ROM_PTR(&mp_lv_screen_load_anim_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clamp_width), MP_ROM_PTR(&mp_lv_clamp_width_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_clamp_height), MP_ROM_PTR(&mp_lv_clamp_height_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_create), MP_ROM_PTR(&mp_lv_group_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_get_default), MP_ROM_PTR(&mp_lv_group_get_default_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_swap_obj), MP_ROM_PTR(&mp_lv_group_swap_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_remove_obj), MP_ROM_PTR(&mp_lv_group_remove_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_focus_obj), MP_ROM_PTR(&mp_lv_group_focus_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_get_count), MP_ROM_PTR(&mp_lv_group_get_count_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_group_by_index), MP_ROM_PTR(&mp_lv_group_by_index_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_indev_create), MP_ROM_PTR(&mp_lv_indev_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_indev_read_timer_cb), MP_ROM_PTR(&mp_lv_indev_read_timer_cb_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_indev_active), MP_ROM_PTR(&mp_lv_indev_active_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_active_obj), MP_ROM_PTR(&mp_lv_indev_get_active_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_indev_search_obj), MP_ROM_PTR(&mp_lv_indev_search_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_refr_now), MP_ROM_PTR(&mp_lv_refr_now_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_binfont_create), MP_ROM_PTR(&mp_lv_binfont_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_binfont_create_from_buffer), MP_ROM_PTR(&mp_lv_binfont_create_from_buffer_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_binfont_destroy), MP_ROM_PTR(&mp_lv_binfont_destroy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_span_stack_init), MP_ROM_PTR(&mp_lv_span_stack_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_span_stack_deinit), MP_ROM_PTR(&mp_lv_span_stack_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_take), MP_ROM_PTR(&mp_lv_snapshot_take_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_free), MP_ROM_PTR(&mp_lv_snapshot_free_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_buf_size_needed), MP_ROM_PTR(&mp_lv_snapshot_buf_size_needed_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_take_to_buf), MP_ROM_PTR(&mp_lv_snapshot_take_to_buf_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_imgfont_create), MP_ROM_PTR(&mp_lv_imgfont_create_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_imgfont_destroy), MP_ROM_PTR(&mp_lv_imgfont_destroy_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bin_decoder_init), MP_ROM_PTR(&mp_lv_bin_decoder_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bin_decoder_info), MP_ROM_PTR(&mp_lv_bin_decoder_info_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bin_decoder_get_area), MP_ROM_PTR(&mp_lv_bin_decoder_get_area_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bin_decoder_open), MP_ROM_PTR(&mp_lv_bin_decoder_open_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_bin_decoder_close), MP_ROM_PTR(&mp_lv_bin_decoder_close_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_fs_memfs_init), MP_ROM_PTR(&mp_lv_fs_memfs_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_lodepng_init), MP_ROM_PTR(&mp_lv_lodepng_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_lodepng_deinit), MP_ROM_PTR(&mp_lv_lodepng_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_gd_open_gif_file), MP_ROM_PTR(&mp_gd_open_gif_file_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_gd_open_gif_data), MP_ROM_PTR(&mp_gd_open_gif_data_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tjpgd_init), MP_ROM_PTR(&mp_lv_tjpgd_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_tjpgd_deinit), MP_ROM_PTR(&mp_lv_tjpgd_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_from_obj), MP_ROM_PTR(&mp_lv_theme_get_from_obj_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_apply), MP_ROM_PTR(&mp_lv_theme_apply_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_small), MP_ROM_PTR(&mp_lv_theme_get_font_small_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_normal), MP_ROM_PTR(&mp_lv_theme_get_font_normal_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_large), MP_ROM_PTR(&mp_lv_theme_get_font_large_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_primary), MP_ROM_PTR(&mp_lv_theme_get_color_primary_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_secondary), MP_ROM_PTR(&mp_lv_theme_get_color_secondary_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_default_init), MP_ROM_PTR(&mp_lv_theme_default_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_default_get), MP_ROM_PTR(&mp_lv_theme_default_get_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_default_is_inited), MP_ROM_PTR(&mp_lv_theme_default_is_inited_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_theme_default_deinit), MP_ROM_PTR(&mp_lv_theme_default_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_init), MP_ROM_PTR(&mp_lv_draw_sw_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_deinit), MP_ROM_PTR(&mp_lv_draw_sw_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_rgb565_swap), MP_ROM_PTR(&mp_lv_draw_sw_rgb565_swap_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_rotate), MP_ROM_PTR(&mp_lv_draw_sw_rotate_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_init), MP_ROM_PTR(&mp_lv_draw_sw_mask_init_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_deinit), MP_ROM_PTR(&mp_lv_draw_sw_mask_deinit_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_apply), MP_ROM_PTR(&mp_lv_draw_sw_mask_apply_mpobj) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_free_param), MP_ROM_PTR(&mp_lv_draw_sw_mask_free_param_mpobj) },
    
    { MP_ROM_QSTR(MP_QSTR_RESULT), MP_ROM_PTR(&mp_lv_LV_RESULT_type_base) },
    { MP_ROM_QSTR(MP_QSTR_LOG_LEVEL), MP_ROM_PTR(&mp_lv_ENUM_LV_LOG_LEVEL_type_base) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(&mp_lv_LV_ALIGN_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DIR), MP_ROM_PTR(&mp_lv_LV_DIR_type_base) },
    { MP_ROM_QSTR(MP_QSTR_COORD), MP_ROM_PTR(&mp_lv_ENUM_LV_COORD_type_base) },
    { MP_ROM_QSTR(MP_QSTR_OPA), MP_ROM_PTR(&mp_lv_LV_OPA_type_base) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FORMAT), MP_ROM_PTR(&mp_lv_LV_COLOR_FORMAT_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FONT_SUBPX), MP_ROM_PTR(&mp_lv_LV_FONT_SUBPX_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FONT_KERNING), MP_ROM_PTR(&mp_lv_LV_FONT_KERNING_type_base) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_FLAG), MP_ROM_PTR(&mp_lv_LV_TEXT_FLAG_type_base) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_ALIGN), MP_ROM_PTR(&mp_lv_LV_TEXT_ALIGN_type_base) },
    { MP_ROM_QSTR(MP_QSTR_BASE_DIR), MP_ROM_PTR(&mp_lv_LV_BASE_DIR_type_base) },
    { MP_ROM_QSTR(MP_QSTR_BLEND_MODE), MP_ROM_PTR(&mp_lv_LV_BLEND_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(&mp_lv_LV_TEXT_DECOR_type_base) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(&mp_lv_LV_BORDER_SIDE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_GRAD_DIR), MP_ROM_PTR(&mp_lv_LV_GRAD_DIR_type_base) },
    { MP_ROM_QSTR(MP_QSTR_STYLE), MP_ROM_PTR(&mp_lv_LV_STYLE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_STYLE_RES), MP_ROM_PTR(&mp_lv_LV_STYLE_RES_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FS_RES), MP_ROM_PTR(&mp_lv_LV_FS_RES_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FS_MODE), MP_ROM_PTR(&mp_lv_LV_FS_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR_MODE), MP_ROM_PTR(&mp_lv_LV_SCROLLBAR_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_SNAP), MP_ROM_PTR(&mp_lv_LV_SCROLL_SNAP_type_base) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(&mp_lv_LV_KEY_type_base) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_lv_LV_STATE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_lv_LV_PART_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT_CMAP), MP_ROM_PTR(&mp_lv_LV_FONT_FMT_TXT_CMAP_type_base) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_IMAGE_PART), MP_ROM_PTR(&mp_lv_LV_ANIM_IMAGE_PART_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SPAN_OVERFLOW), MP_ROM_PTR(&mp_lv_LV_SPAN_OVERFLOW_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SPAN_MODE), MP_ROM_PTR(&mp_lv_LV_SPAN_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_PART_TEXTAREA), MP_ROM_PTR(&mp_lv_LV_PART_TEXTAREA_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_SW_MASK_RES), MP_ROM_PTR(&mp_lv_LV_DRAW_SW_MASK_RES_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_SW_MASK_TYPE), MP_ROM_PTR(&mp_lv_LV_DRAW_SW_MASK_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_SW_MASK_LINE_SIDE), MP_ROM_PTR(&mp_lv_LV_DRAW_SW_MASK_LINE_SIDE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_ANIM), MP_ROM_PTR(&mp_lv_LV_ANIM_type_base) },
    { MP_ROM_QSTR(MP_QSTR_RB_COLOR), MP_ROM_PTR(&mp_lv_LV_RB_COLOR_type_base) },
    { MP_ROM_QSTR(MP_QSTR_PALETTE), MP_ROM_PTR(&mp_lv_LV_PALETTE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_THREAD_PRIO), MP_ROM_PTR(&mp_lv_LV_THREAD_PRIO_type_base) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT), MP_ROM_PTR(&mp_lv_LV_LAYOUT_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_ALIGN), MP_ROM_PTR(&mp_lv_LV_FLEX_ALIGN_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_FLOW), MP_ROM_PTR(&mp_lv_LV_FLEX_FLOW_type_base) },
    { MP_ROM_QSTR(MP_QSTR_GRID_ALIGN), MP_ROM_PTR(&mp_lv_LV_GRID_ALIGN_type_base) },
    { MP_ROM_QSTR(MP_QSTR_EVENT), MP_ROM_PTR(&mp_lv_LV_EVENT_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FS_SEEK), MP_ROM_PTR(&mp_lv_LV_FS_SEEK_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_TASK_TYPE), MP_ROM_PTR(&mp_lv_LV_DRAW_TASK_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_TASK_STATE), MP_ROM_PTR(&mp_lv_LV_DRAW_TASK_STATE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_LETTER), MP_ROM_PTR(&mp_lv_LV_DRAW_LETTER_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DISPLAY_ROTATION), MP_ROM_PTR(&mp_lv_LV_DISPLAY_ROTATION_type_base) },
    { MP_ROM_QSTR(MP_QSTR_DISPLAY_RENDER_MODE), MP_ROM_PTR(&mp_lv_LV_DISPLAY_RENDER_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SCR_LOAD_ANIM), MP_ROM_PTR(&mp_lv_LV_SCR_LOAD_ANIM_type_base) },
    { MP_ROM_QSTR(MP_QSTR_LAYER_TYPE), MP_ROM_PTR(&mp_lv_LV_LAYER_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_GROUP_REFOCUS_POLICY), MP_ROM_PTR(&mp_lv_LV_GROUP_REFOCUS_POLICY_type_base) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_TYPE), MP_ROM_PTR(&mp_lv_LV_INDEV_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_STATE), MP_ROM_PTR(&mp_lv_LV_INDEV_STATE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_MODE), MP_ROM_PTR(&mp_lv_LV_INDEV_MODE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_COVER_RES), MP_ROM_PTR(&mp_lv_LV_COVER_RES_type_base) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT), MP_ROM_PTR(&mp_lv_LV_FONT_FMT_TXT_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SUBJECT_TYPE), MP_ROM_PTR(&mp_lv_LV_SUBJECT_TYPE_type_base) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(&mp_lv_LV_SYMBOL_type_base) },
    
    { MP_ROM_QSTR(MP_QSTR_C_Pointer), MP_ROM_PTR(&mp_C_Pointer_type) },
    { MP_ROM_QSTR(MP_QSTR_color_t), MP_ROM_PTR(&mp_lv_color_t_type) },
    { MP_ROM_QSTR(MP_QSTR_grad_dsc_t), MP_ROM_PTR(&mp_lv_grad_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_gradient_stop_t), MP_ROM_PTR(&mp_lv_gradient_stop_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_t), MP_ROM_PTR(&mp_lv_font_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_glyph_dsc_t), MP_ROM_PTR(&mp_lv_font_glyph_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_cache_entry_t), MP_ROM_PTR(&mp_lv_cache_entry_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_t), MP_ROM_PTR(&mp_lv_draw_buf_t_type) },
    { MP_ROM_QSTR(MP_QSTR_image_header_t), MP_ROM_PTR(&mp_lv_image_header_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color_filter_dsc_t), MP_ROM_PTR(&mp_lv_color_filter_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_t), MP_ROM_PTR(&mp_lv_anim_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_parameter_t), MP_ROM_PTR(&mp_lv_anim_parameter_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_bezier3_para_t), MP_ROM_PTR(&mp_lv_anim_bezier3_para_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_transition_dsc_t), MP_ROM_PTR(&mp_lv_style_transition_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_display_t), MP_ROM_PTR(&mp_lv_display_t_type) },
    { MP_ROM_QSTR(MP_QSTR_obj_class_t), MP_ROM_PTR(&mp_lv_obj_class_t_type) },
    { MP_ROM_QSTR(MP_QSTR_event_t), MP_ROM_PTR(&mp_lv_event_t_type) },
    { MP_ROM_QSTR(MP_QSTR_area_t), MP_ROM_PTR(&mp_lv_area_t_type) },
    { MP_ROM_QSTR(MP_QSTR_point_t), MP_ROM_PTR(&mp_lv_point_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_t), MP_ROM_PTR(&mp_lv_style_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_value_t), MP_ROM_PTR(&mp_lv_style_value_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect_dsc_t), MP_ROM_PTR(&mp_lv_draw_rect_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_dsc_base_t), MP_ROM_PTR(&mp_lv_draw_dsc_base_t_type) },
    { MP_ROM_QSTR(MP_QSTR_layer_t), MP_ROM_PTR(&mp_lv_layer_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_task_t), MP_ROM_PTR(&mp_lv_draw_task_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_dsc_t), MP_ROM_PTR(&mp_lv_draw_label_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_hint_t), MP_ROM_PTR(&mp_lv_draw_label_hint_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_image_dsc_t), MP_ROM_PTR(&mp_lv_draw_image_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_image_sup_t), MP_ROM_PTR(&mp_lv_draw_image_sup_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color32_t), MP_ROM_PTR(&mp_lv_color32_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_line_dsc_t), MP_ROM_PTR(&mp_lv_draw_line_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_point_precise_t), MP_ROM_PTR(&mp_lv_point_precise_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc_dsc_t), MP_ROM_PTR(&mp_lv_draw_arc_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_event_dsc_t), MP_ROM_PTR(&mp_lv_event_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_group_t), MP_ROM_PTR(&mp_lv_group_t_type) },
    { MP_ROM_QSTR(MP_QSTR_ll_t), MP_ROM_PTR(&mp_lv_ll_t_type) },
    { MP_ROM_QSTR(MP_QSTR_observer_t), MP_ROM_PTR(&mp_lv_observer_t_type) },
    { MP_ROM_QSTR(MP_QSTR_subject_t), MP_ROM_PTR(&mp_lv_subject_t_type) },
    { MP_ROM_QSTR(MP_QSTR_subject_value_t), MP_ROM_PTR(&mp_lv_subject_value_t_type) },
    { MP_ROM_QSTR(MP_QSTR_image_dsc_t), MP_ROM_PTR(&mp_lv_image_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_image_decoder_dsc_t), MP_ROM_PTR(&mp_lv_image_decoder_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_image_decoder_t), MP_ROM_PTR(&mp_lv_image_decoder_t_type) },
    { MP_ROM_QSTR(MP_QSTR_image_decoder_args_t), MP_ROM_PTR(&mp_lv_image_decoder_args_t_type) },
    { MP_ROM_QSTR(MP_QSTR_cache_t), MP_ROM_PTR(&mp_lv_cache_t_type) },
    { MP_ROM_QSTR(MP_QSTR_cache_class_t), MP_ROM_PTR(&mp_lv_cache_class_t_type) },
    { MP_ROM_QSTR(MP_QSTR_cache_ops_t), MP_ROM_PTR(&mp_lv_cache_ops_t_type) },
    { MP_ROM_QSTR(MP_QSTR_calendar_date_t), MP_ROM_PTR(&mp_lv_calendar_date_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_series_t), MP_ROM_PTR(&mp_lv_chart_series_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_cursor_t), MP_ROM_PTR(&mp_lv_chart_cursor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_scale_section_t), MP_ROM_PTR(&mp_lv_scale_section_t_type) },
    { MP_ROM_QSTR(MP_QSTR_span_t), MP_ROM_PTR(&mp_lv_span_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_mp_int_wrapper), MP_ROM_PTR(&mp__lv_mp_int_wrapper_type) },
    { MP_ROM_QSTR(MP_QSTR_timer_t), MP_ROM_PTR(&mp_lv_timer_t_type) },
    { MP_ROM_QSTR(MP_QSTR_array_t), MP_ROM_PTR(&mp_lv_array_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color16_t), MP_ROM_PTR(&mp_lv_color16_t_type) },
    { MP_ROM_QSTR(MP_QSTR_mem_monitor_t), MP_ROM_PTR(&mp_lv_mem_monitor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_t), MP_ROM_PTR(&mp_lv_anim_timeline_t_type) },
    { MP_ROM_QSTR(MP_QSTR_rb_t), MP_ROM_PTR(&mp_lv_rb_t_type) },
    { MP_ROM_QSTR(MP_QSTR_rb_node_t), MP_ROM_PTR(&mp_lv_rb_node_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_drv_t), MP_ROM_PTR(&mp_lv_fs_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_file_t), MP_ROM_PTR(&mp_lv_fs_file_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_file_cache_t), MP_ROM_PTR(&mp_lv_fs_file_cache_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_path_ex_t), MP_ROM_PTR(&mp_lv_fs_path_ex_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_dir_t), MP_ROM_PTR(&mp_lv_fs_dir_t_type) },
    { MP_ROM_QSTR(MP_QSTR_grad_t), MP_ROM_PTR(&mp_lv_grad_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_fill_dsc_t), MP_ROM_PTR(&mp_lv_draw_fill_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_border_dsc_t), MP_ROM_PTR(&mp_lv_draw_border_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_box_shadow_dsc_t), MP_ROM_PTR(&mp_lv_draw_box_shadow_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_glyph_dsc_t), MP_ROM_PTR(&mp_lv_draw_glyph_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_unit_t), MP_ROM_PTR(&mp_lv_draw_unit_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_triangle_dsc_t), MP_ROM_PTR(&mp_lv_draw_triangle_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_rect_dsc_t), MP_ROM_PTR(&mp_lv_draw_mask_rect_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_t), MP_ROM_PTR(&mp_lv_indev_t_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_GIF), MP_ROM_PTR(&mp_gd_GIF_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_GCE), MP_ROM_PTR(&mp_gd_GCE_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_Palette), MP_ROM_PTR(&mp_gd_Palette_type) },
    { MP_ROM_QSTR(MP_QSTR_theme_t), MP_ROM_PTR(&mp_lv_theme_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_line_param_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_line_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_draw_sw_mask_common_dsc_t), MP_ROM_PTR(&mp__lv_draw_sw_mask_common_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_line_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_line_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_angle_param_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_angle_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_angle_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_angle_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_radius_param_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_radius_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_radius_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_radius_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_draw_sw_mask_radius_circle_dsc_t), MP_ROM_PTR(&mp__lv_draw_sw_mask_radius_circle_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_fade_param_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_fade_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_fade_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_fade_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_map_param_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_map_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_mask_map_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_sw_mask_map_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_t), MP_ROM_PTR(&mp_lv_color_hsv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_hit_test_info_t), MP_ROM_PTR(&mp_lv_hit_test_info_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_sw_blend_dsc_t), MP_ROM_PTR(&mp_lv_draw_sw_blend_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_data_t), MP_ROM_PTR(&mp_lv_indev_data_t_type) },
    { MP_ROM_QSTR(MP_QSTR_sqrt_res_t), MP_ROM_PTR(&mp_lv_sqrt_res_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_buf_handlers_t), MP_ROM_PTR(&mp_lv_draw_buf_handlers_t_type) },
    { MP_ROM_QSTR(MP_QSTR_layout_dsc_t), MP_ROM_PTR(&mp_lv_layout_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_area_transform_cache_t), MP_ROM_PTR(&mp_lv_area_transform_cache_t_type) },
    { MP_ROM_QSTR(MP_QSTR_timer_state_t), MP_ROM_PTR(&mp_lv_timer_state_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_state_t), MP_ROM_PTR(&mp_lv_anim_state_t_type) },
    { MP_ROM_QSTR(MP_QSTR_tick_state_t), MP_ROM_PTR(&mp_lv_tick_state_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_global_info_t), MP_ROM_PTR(&mp_lv_draw_global_info_t_type) },
    
    
    { MP_ROM_QSTR(MP_QSTR_color_filter_shade), MP_ROM_PTR(&mp_lv_color_filter_shade) },
    { MP_ROM_QSTR(MP_QSTR_cache_class_lru_rb_count), MP_ROM_PTR(&mp_lv_cache_class_lru_rb_count) },
    { MP_ROM_QSTR(MP_QSTR_cache_class_lru_rb_size), MP_ROM_PTR(&mp_lv_cache_class_lru_rb_size) },
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_14), MP_ROM_PTR(&mp_lv_font_montserrat_14) },
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_16), MP_ROM_PTR(&mp_lv_font_montserrat_16) },
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_24), MP_ROM_PTR(&mp_lv_font_montserrat_24) },
    { MP_ROM_QSTR(MP_QSTR_style_const_prop_id_inv), MP_ROM_PTR(&mp_lv_style_const_prop_id_inv) },
    { MP_ROM_QSTR(MP_QSTR_obj_class), MP_ROM_PTR(&mp_lv_obj_class) },
    { MP_ROM_QSTR(MP_QSTR_image_class), MP_ROM_PTR(&mp_lv_image_class) },
    { MP_ROM_QSTR(MP_QSTR_animimg_class), MP_ROM_PTR(&mp_lv_animimg_class) },
    { MP_ROM_QSTR(MP_QSTR_arc_class), MP_ROM_PTR(&mp_lv_arc_class) },
    { MP_ROM_QSTR(MP_QSTR_label_class), MP_ROM_PTR(&mp_lv_label_class) },
    { MP_ROM_QSTR(MP_QSTR_bar_class), MP_ROM_PTR(&mp_lv_bar_class) },
    { MP_ROM_QSTR(MP_QSTR_button_class), MP_ROM_PTR(&mp_lv_button_class) },
    { MP_ROM_QSTR(MP_QSTR_buttonmatrix_class), MP_ROM_PTR(&mp_lv_buttonmatrix_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_class), MP_ROM_PTR(&mp_lv_calendar_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_arrow_class), MP_ROM_PTR(&mp_lv_calendar_header_arrow_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_dropdown_class), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_class) },
    { MP_ROM_QSTR(MP_QSTR_canvas_class), MP_ROM_PTR(&mp_lv_canvas_class) },
    { MP_ROM_QSTR(MP_QSTR_chart_class), MP_ROM_PTR(&mp_lv_chart_class) },
    { MP_ROM_QSTR(MP_QSTR_checkbox_class), MP_ROM_PTR(&mp_lv_checkbox_class) },
    { MP_ROM_QSTR(MP_QSTR_dropdown_class), MP_ROM_PTR(&mp_lv_dropdown_class) },
    { MP_ROM_QSTR(MP_QSTR_dropdownlist_class), MP_ROM_PTR(&mp_lv_dropdownlist_class) },
    { MP_ROM_QSTR(MP_QSTR_imagebutton_class), MP_ROM_PTR(&mp_lv_imagebutton_class) },
    { MP_ROM_QSTR(MP_QSTR_keyboard_class), MP_ROM_PTR(&mp_lv_keyboard_class) },
    { MP_ROM_QSTR(MP_QSTR_led_class), MP_ROM_PTR(&mp_lv_led_class) },
    { MP_ROM_QSTR(MP_QSTR_line_class), MP_ROM_PTR(&mp_lv_line_class) },
    { MP_ROM_QSTR(MP_QSTR_list_class), MP_ROM_PTR(&mp_lv_list_class) },
    { MP_ROM_QSTR(MP_QSTR_list_text_class), MP_ROM_PTR(&mp_lv_list_text_class) },
    { MP_ROM_QSTR(MP_QSTR_list_button_class), MP_ROM_PTR(&mp_lv_list_button_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_class), MP_ROM_PTR(&mp_lv_menu_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_page_class), MP_ROM_PTR(&mp_lv_menu_page_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_cont_class), MP_ROM_PTR(&mp_lv_menu_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_section_class), MP_ROM_PTR(&mp_lv_menu_section_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_separator_class), MP_ROM_PTR(&mp_lv_menu_separator_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_sidebar_cont_class), MP_ROM_PTR(&mp_lv_menu_sidebar_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_main_cont_class), MP_ROM_PTR(&mp_lv_menu_main_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_sidebar_header_cont_class), MP_ROM_PTR(&mp_lv_menu_sidebar_header_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_main_header_cont_class), MP_ROM_PTR(&mp_lv_menu_main_header_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_class), MP_ROM_PTR(&mp_lv_msgbox_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_header_class), MP_ROM_PTR(&mp_lv_msgbox_header_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_content_class), MP_ROM_PTR(&mp_lv_msgbox_content_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_footer_class), MP_ROM_PTR(&mp_lv_msgbox_footer_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_header_button_class), MP_ROM_PTR(&mp_lv_msgbox_header_button_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_footer_button_class), MP_ROM_PTR(&mp_lv_msgbox_footer_button_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_backdrop_class), MP_ROM_PTR(&mp_lv_msgbox_backdrop_class) },
    { MP_ROM_QSTR(MP_QSTR_roller_class), MP_ROM_PTR(&mp_lv_roller_class) },
    { MP_ROM_QSTR(MP_QSTR_scale_class), MP_ROM_PTR(&mp_lv_scale_class) },
    { MP_ROM_QSTR(MP_QSTR_slider_class), MP_ROM_PTR(&mp_lv_slider_class) },
    { MP_ROM_QSTR(MP_QSTR_spangroup_class), MP_ROM_PTR(&mp_lv_spangroup_class) },
    { MP_ROM_QSTR(MP_QSTR_textarea_class), MP_ROM_PTR(&mp_lv_textarea_class) },
    { MP_ROM_QSTR(MP_QSTR_spinbox_class), MP_ROM_PTR(&mp_lv_spinbox_class) },
    { MP_ROM_QSTR(MP_QSTR_spinner_class), MP_ROM_PTR(&mp_lv_spinner_class) },
    { MP_ROM_QSTR(MP_QSTR_switch_class), MP_ROM_PTR(&mp_lv_switch_class) },
    { MP_ROM_QSTR(MP_QSTR_table_class), MP_ROM_PTR(&mp_lv_table_class) },
    { MP_ROM_QSTR(MP_QSTR_tabview_class), MP_ROM_PTR(&mp_lv_tabview_class) },
    { MP_ROM_QSTR(MP_QSTR_tileview_class), MP_ROM_PTR(&mp_lv_tileview_class) },
    { MP_ROM_QSTR(MP_QSTR_tileview_tile_class), MP_ROM_PTR(&mp_lv_tileview_tile_class) },
    { MP_ROM_QSTR(MP_QSTR_win_class), MP_ROM_PTR(&mp_lv_win_class) },
    { MP_ROM_QSTR(MP_QSTR_barcode_class), MP_ROM_PTR(&mp_lv_barcode_class) },
    { MP_ROM_QSTR(MP_QSTR_gif_class), MP_ROM_PTR(&mp_lv_gif_class) },
    { MP_ROM_QSTR(MP_QSTR_qrcode_class), MP_ROM_PTR(&mp_lv_qrcode_class) },
    { MP_ROM_QSTR(MP_QSTR__nesting), MP_ROM_PTR(&mp__nesting) },
    
    { MP_ROM_QSTR(MP_QSTR_DPI_DEF), MP_ROM_PTR(MP_ROM_INT(LV_DPI_DEF)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_BUF_STRIDE_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_BUF_STRIDE_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_BUF_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_BUF_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_REPEAT_INFINITE), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_REPEAT_INFINITE)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_PLAYTIME_INFINITE), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_PLAYTIME_INFINITE)) },
    { MP_ROM_QSTR(MP_QSTR_SIZE_CONTENT), MP_ROM_PTR(MP_ROM_INT(LV_SIZE_CONTENT)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_DEPTH), MP_ROM_PTR(MP_ROM_INT(LV_COLOR_DEPTH)) },
    { MP_ROM_QSTR(MP_QSTR_STRIDE_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_STRIDE_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_CONTENT), MP_ROM_PTR(MP_ROM_INT(LV_GRID_CONTENT)) },
    { MP_ROM_QSTR(MP_QSTR_GRID_TEMPLATE_LAST), MP_ROM_PTR(MP_ROM_INT(LV_GRID_TEMPLATE_LAST)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS_CIRCLE), MP_ROM_PTR(MP_ROM_INT(LV_RADIUS_CIRCLE)) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_DOT_NUM), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_DOT_NUM)) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_POS_LAST), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_POS_LAST)) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_TEXT_SELECTION_OFF), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_TEXT_SELECTION_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_BUTTONMATRIX_BUTTON_NONE), MP_ROM_PTR(MP_ROM_INT(LV_BUTTONMATRIX_BUTTON_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_CHART_POINT_NONE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_POINT_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_DROPDOWN_POS_LAST), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_POS_LAST)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_TOTAL_TICK_COUNT_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_TOTAL_TICK_COUNT_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_MAJOR_TICK_EVERY_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_MAJOR_TICK_EVERY_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_LABEL_ENABLED_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_SCALE_LABEL_ENABLED_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_TEXTAREA_CURSOR_LAST), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_CURSOR_LAST)) },
    { MP_ROM_QSTR(MP_QSTR_TABLE_CELL_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_NONE)) },
    
#ifdef LV_OBJ_T
    { MP_ROM_QSTR(MP_QSTR_LvReferenceError), MP_ROM_PTR(&mp_type_LvReferenceError) },
#endif // LV_OBJ_T
};


STATIC MP_DEFINE_CONST_DICT (
    mp_module_lvgl_globals,
    lvgl_globals_table
);

const mp_obj_module_t mp_module_lvgl = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&mp_module_lvgl_globals
};

MP_REGISTER_MODULE(MP_QSTR_lvgl, mp_module_lvgl);



STATIC const mp_lv_obj_type_t *mp_lv_obj_types[] = {
    &mp_lv_obj_type,
    &mp_lv_image_type,
    &mp_lv_animimg_type,
    &mp_lv_arc_type,
    &mp_lv_label_type,
    &mp_lv_bar_type,
    &mp_lv_button_type,
    &mp_lv_buttonmatrix_type,
    &mp_lv_calendar_type,
    &mp_lv_calendar_header_arrow_type,
    &mp_lv_calendar_header_dropdown_type,
    &mp_lv_canvas_type,
    &mp_lv_chart_type,
    &mp_lv_checkbox_type,
    &mp_lv_dropdown_type,
    &mp_lv_imagebutton_type,
    &mp_lv_keyboard_type,
    &mp_lv_led_type,
    &mp_lv_line_type,
    &mp_lv_list_type,
    &mp_lv_menu_type,
    &mp_lv_menu_page_type,
    &mp_lv_menu_cont_type,
    &mp_lv_menu_section_type,
    &mp_lv_menu_separator_type,
    &mp_lv_msgbox_type,
    &mp_lv_roller_type,
    &mp_lv_scale_type,
    &mp_lv_slider_type,
    &mp_lv_spangroup_type,
    &mp_lv_textarea_type,
    &mp_lv_spinbox_type,
    &mp_lv_spinner_type,
    &mp_lv_switch_type,
    &mp_lv_table_type,
    &mp_lv_tabview_type,
    &mp_lv_tileview_type,
    &mp_lv_win_type,
    &mp_lv_barcode_type,
    &mp_lv_gif_type,
    &mp_lv_qrcode_type,
    NULL
};
    
